// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

import "schemas/arc/types"

@ts output  "client/ts/src/arc/ir"
@go output  "arc/go/ir"
@cpp output "arc/cpp/ir"
@pb

Handle struct {
    node  string {
        @doc value "is the node identifier."
    }
    param string {
        @doc value "is the parameter name (input or output)."
    }

    @doc value "is a reference to a specific parameter on a specific node in the dataflow graph."
}

EdgeKind enum {
    unspecified = 0
    continuous  = 1
    one_shot    = 2

    @doc value "defines execution semantics for dataflow edges between nodes."
}

Edge struct {
    source Handle    {
        @doc value "is the source node parameter producing data."
    }
    target Handle    {
        @doc value "is the target node parameter consuming data."
    }
    kind   EdgeKind? {
        @doc value "defines execution semantics for this connection."
    }

    @doc value "is a dataflow connection between node parameters in the Arc graph."
}

Edges Edge[] {
    @doc value "is a collection of dataflow edges in an Arc graph."
}

Stage struct {
    key    string   {
        @doc value "is the stage identifier."
    }
    nodes  string[] {
        @doc value "contains node keys active in this stage."
    }
    strata Strata   {
        @doc value "contains execution stratification for nodes in this stage."
    }

    @doc value """
        is a stage in a sequence state machine, containing active nodes and their
        execution stratification.
    """
}

Stages Stage[] {
    @doc value "is a collection of stages in an Arc sequence."
}

Sequence struct {
    key    string  {
        @doc value "is the sequence identifier."
    }
    stages Stage[] {
        @doc value "contains ordered stages in this sequence."
    }

    @doc value """
        is a state machine defining ordered stages of execution, where entry point
        is always the first stage.
    """
}

Sequences Sequence[] {
    @doc value "is a collection of sequences in an Arc module."
}

Body struct {
    raw string {
        @doc value "is the raw source code text."
    }

    @doc value  "is raw function body source code with optional parsed AST."
    @go fields  "AST antlr.ParserRuleContext `json:\"-\"`"
    @go imports "github.com/antlr4-go/antlr/v4"
}

Function struct {
    key      string          {
        @doc value "is the function identifier (template name)."
    }
    body     Body?           {
        @doc value "is raw source code for user-defined functions."
    }
    config   types.Params?   {
        @doc value "contains configuration parameter definitions."
    }
    inputs   types.Params?   {
        @doc value "contains input parameter definitions."
    }
    outputs  types.Params?   {
        @doc value "contains output parameter definitions."
    }
    channels types.Channels? {
        @doc value "contains channel read/write declarations."
    }

    @doc value """
        is a function template definition with typed parameters, serving as a
        blueprint for node instantiation.
    """
}

Functions Function[] {
    @doc value "is a collection of function definitions in an Arc module."
}

Stratum = string[] {
    @doc value """
        is a single execution layer containing node keys that can execute in
        parallel.
    """
}

Strata Stratum[] {
    @doc value """
        contains stratified execution layers where stratum N depends only on
        strata 0 to N-1, enabling glitch-free reactive evaluation.
    """
}

Node struct {
    key      string          {
        @doc value "is the unique identifier for this node instance."
    }
    type     string          {
        @doc value "is the function type being instantiated."
    }
    config   types.Params?   {
        @doc value "contains configuration parameter values."
    }
    inputs   types.Params?   {
        @doc value "contains input parameter type signatures."
    }
    outputs  types.Params?   {
        @doc value "contains output parameter type signatures."
    }
    channels types.Channels? {
        @doc value "contains channel read/write mappings."
    }

    @doc value """
        is a concrete instantiation of a function with typed parameters and
        configuration values.
    """
}

Nodes Node[] {
    @doc value "is a collection of node instantiations in an Arc module."
}

IR struct {
    functions Functions? {
        @doc value "contains function template definitions."
    }
    nodes     Nodes?     {
        @doc value "contains node instantiations."
    }
    edges     Edges?     {
        @doc value "contains dataflow connections."
    }
    strata    Strata?    {
        @doc value "contains execution stratification layers."
    }
    sequences Sequences? {
        @doc value "contains state machine definitions."
    }

    @doc value           """
        is the intermediate representation of an Arc program as a dataflow graph
        with stratified execution, bridging semantic analysis and WebAssembly
        compilation.
    """
    @go fields           "Symbols *symbol.Scope `json:\"-\"`" "TypeMap map[antlr.ParserRuleContext]types.Type `json:\"-\"`"
    @go imports          "github.com/antlr4-go/antlr/v4" "github.com/synnaxlabs/arc/symbol" "github.com/synnaxlabs/arc/types"
    @cpp methods         "[[nodiscard]] const Node& node(const std::string& key) const" "[[nodiscard]] const Function& function(const std::string& key) const" "[[nodiscard]] std::optional<Edge> edge_to(const Handle& target) const" "[[nodiscard]] std::unordered_map<std::string, std::vector<Edge>> edges_from(const std::string& node_key) const"
    @cpp system_includes "optional" "unordered_map"
}
