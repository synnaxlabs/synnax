//go:build ignore

// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in
// the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business
// Source License, use of this software will be governed by the Apache License,
// Version 2.0, included in the file licenses/APL.txt.

package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

type TypeInfo struct {
	Name       string
	GoType     string
	Size       int
	IsFloat    bool
	IsSigned   bool
	IsUnsigned bool
}

var types = []TypeInfo{
	{Name: "F64", GoType: "float64", Size: 8, IsFloat: true},
	{Name: "F32", GoType: "float32", Size: 4, IsFloat: true},
	{Name: "I64", GoType: "int64", Size: 8, IsSigned: true},
	{Name: "I32", GoType: "int32", Size: 4, IsSigned: true},
	{Name: "I16", GoType: "int16", Size: 2, IsSigned: true},
	{Name: "I8", GoType: "int8", Size: 1, IsSigned: true},
	{Name: "U64", GoType: "uint64", Size: 8, IsUnsigned: true},
	{Name: "U32", GoType: "uint32", Size: 4, IsUnsigned: true},
	{Name: "U16", GoType: "uint16", Size: 2, IsUnsigned: true},
	{Name: "U8", GoType: "uint8", Size: 1, IsUnsigned: true},
}

type Operation struct {
	Name     string
	FuncName string
	Op       string
	IsComp   bool
}

var operations = []Operation{
	// Comparison operations (return uint8/bool)
	{Name: "GreaterThan", FuncName: "Gt", Op: ">", IsComp: true},
	{Name: "GreaterThanOrEqual", FuncName: "Gte", Op: ">=", IsComp: true},
	{Name: "LessThan", FuncName: "Lt", Op: "<", IsComp: true},
	{Name: "LessThanOrEqual", FuncName: "Lte", Op: "<=", IsComp: true},
	{Name: "Equal", FuncName: "Eq", Op: "==", IsComp: true},
	{Name: "NotEqual", FuncName: "Neq", Op: "!=", IsComp: true},
	// Arithmetic operations (return same type)
	{Name: "Add", FuncName: "Add", Op: "+", IsComp: false},
	{Name: "Subtract", FuncName: "Sub", Op: "-", IsComp: false},
	{Name: "Multiply", FuncName: "Mul", Op: "*", IsComp: false},
	{Name: "Divide", FuncName: "Div", Op: "/", IsComp: false},
}

const headerTemplate = `// Code generated by gen.go. DO NOT EDIT.

// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in
// the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business
// Source License, use of this software will be governed by the Apache License,
// Version 2.0, included in the file licenses/APL.txt.

package op

import (
	"unsafe"
	"github.com/synnaxlabs/x/telem"
)
`

const funcTemplate = `{{range $.Operations}}{{if .IsComp}}
func {{.Name}}{{$.Type.Name}}(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*{{$.Type.GoType}})(unsafe.Pointer(&a.Data[0])), len(a.Data)/{{$.Type.Size}})
	bData := unsafe.Slice((*{{$.Type.GoType}})(unsafe.Pointer(&b.Data[0])), len(b.Data)/{{$.Type.Size}})
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast {{$.Type.GoType}}
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal {{.Op}} bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}
{{else}}
func {{.Name}}{{$.Type.Name}}(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*{{$.Type.GoType}})(unsafe.Pointer(&a.Data[0])), len(a.Data)/{{$.Type.Size}})
	bData := unsafe.Slice((*{{$.Type.GoType}})(unsafe.Pointer(&b.Data[0])), len(b.Data)/{{$.Type.Size}})
	outData := unsafe.Slice((*{{$.Type.GoType}})(unsafe.Pointer(&output.Data[0])), len(output.Data)/{{$.Type.Size}})

	var aLast, bLast {{$.Type.GoType}}
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal {{.Op}} bVal
	}
}
{{end}}{{end}}`

func main() {
	tmpl := template.Must(template.New("funcs").Parse(funcTemplate))

	var buf strings.Builder
	buf.WriteString(headerTemplate)

	for _, typ := range types {
		err := tmpl.Execute(&buf, map[string]interface{}{
			"Type":       typ,
			"Operations": operations,
		})
		if err != nil {
			panic(err)
		}
	}

	output := buf.String()
	err := os.WriteFile("op.go", []byte(output), 0644)
	if err != nil {
		panic(err)
	}

	fmt.Println("Generated op.go successfully")
}
