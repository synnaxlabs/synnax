// Code generated by gen.go. DO NOT EDIT.

// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in
// the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business
// Source License, use of this software will be governed by the Apache License,
// Version 2.0, included in the file licenses/APL.txt.

package op

import (
	"unsafe"
	"github.com/synnaxlabs/x/telem"
)

func GreaterThanF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*float64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*float64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*float64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideF64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*float64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast float64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*float32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*float32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*float32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideF32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*float32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast float32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*int64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*int64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*int64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideI64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*int64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast int64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*int32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*int32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*int32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideI32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*int32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast int32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*int16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*int16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*int16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideI16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*int16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)

	var aLast, bLast int16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*int8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*int8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*int8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideI8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*int8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)

	var aLast, bLast int8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideU64(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)

	var aLast, bLast uint64
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideU32(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)

	var aLast, bLast uint32
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideU16(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)

	var aLast, bLast uint16
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}

func GreaterThanU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal > bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal >= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal < bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal <= bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal == bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		if aVal != bVal {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal + bVal
	}
}

func SubtractU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal - bVal
	}
}

func MultiplyU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal * bVal
	}
}

func DivideU8(a, b telem.Series, output *telem.Series) {
	aLen := a.Len()
	bLen := b.Len()
	maxLen := aLen
	if bLen > maxLen {
		maxLen = bLen
	}
	output.Resize(maxLen)

	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)

	var aLast, bLast uint8
	if aLen > 0 {
		aLast = aData[aLen-1]
	}
	if bLen > 0 {
		bLast = bData[bLen-1]
	}

	for i := int64(0); i < maxLen; i++ {
		aVal := aLast
		if i < aLen {
			aVal = aData[i]
			aLast = aVal
		}
		bVal := bLast
		if i < bLen {
			bVal = bData[i]
			bLast = bVal
		}
		outData[i] = aVal / bVal
	}
}
