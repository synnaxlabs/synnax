// Code generated by gen.go. DO NOT EDIT.

// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in
// the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business
// Source License, use of this software will be governed by the Apache License,
// Version 2.0, included in the file licenses/APL.txt.

package op

import (
	"unsafe"
	"github.com/synnaxlabs/x/telem"
)

type Binary = func(a, b, output telem.Series)

func GreaterThanF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*float64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*float64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*float64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideF64(a, b, output telem.Series) {
	aData := unsafe.Slice((*float64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*float64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*float64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*float32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*float32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*float32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideF32(a, b, output telem.Series) {
	aData := unsafe.Slice((*float32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*float32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*float32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*int64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*int64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*int64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideI64(a, b, output telem.Series) {
	aData := unsafe.Slice((*int64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*int64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*int64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*int32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*int32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*int32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideI32(a, b, output telem.Series) {
	aData := unsafe.Slice((*int32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*int32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*int32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*int16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*int16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*int16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideI16(a, b, output telem.Series) {
	aData := unsafe.Slice((*int16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*int16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*int16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*int8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*int8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*int8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideI8(a, b, output telem.Series) {
	aData := unsafe.Slice((*int8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*int8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*int8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideU64(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint64)(unsafe.Pointer(&a.Data[0])), len(a.Data)/8)
	bData := unsafe.Slice((*uint64)(unsafe.Pointer(&b.Data[0])), len(b.Data)/8)
	outData := unsafe.Slice((*uint64)(unsafe.Pointer(&output.Data[0])), len(output.Data)/8)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideU32(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint32)(unsafe.Pointer(&a.Data[0])), len(a.Data)/4)
	bData := unsafe.Slice((*uint32)(unsafe.Pointer(&b.Data[0])), len(b.Data)/4)
	outData := unsafe.Slice((*uint32)(unsafe.Pointer(&output.Data[0])), len(output.Data)/4)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideU16(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint16)(unsafe.Pointer(&a.Data[0])), len(a.Data)/2)
	bData := unsafe.Slice((*uint16)(unsafe.Pointer(&b.Data[0])), len(b.Data)/2)
	outData := unsafe.Slice((*uint16)(unsafe.Pointer(&output.Data[0])), len(output.Data)/2)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}

func GreaterThanU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] > bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func GreaterThanOrEqualU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] >= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] < bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func LessThanOrEqualU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] <= bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func EqualU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] == bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func NotEqualU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data))
	for i := range aData {
		if aData[i] != bData[i] {
			outData[i] = 1
		} else {
			outData[i] = 0
		}
	}
}

func AddU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)
	for i := range aData {
		outData[i] = aData[i] + bData[i]
	}
}

func SubtractU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)
	for i := range aData {
		outData[i] = aData[i] - bData[i]
	}
}

func MultiplyU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)
	for i := range aData {
		outData[i] = aData[i] * bData[i]
	}
}

func DivideU8(a, b, output telem.Series) {
	aData := unsafe.Slice((*uint8)(unsafe.Pointer(&a.Data[0])), len(a.Data)/1)
	bData := unsafe.Slice((*uint8)(unsafe.Pointer(&b.Data[0])), len(b.Data)/1)
	outData := unsafe.Slice((*uint8)(unsafe.Pointer(&output.Data[0])), len(output.Data)/1)
	for i := range aData {
		outData[i] = aData[i] / bData[i]
	}
}
