// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package address

import (
	"strconv"

	"github.com/synnaxlabs/x/atomic"
)

// Factory creates a set of sequential addresses from a template. Factory is safe for
// concurrent use.
type Factory struct {
	// Host is the hostname of the address. ex. "localhost".
	Host string
	// PortStart is the starting point for the sequential addresses generated.
	// A PortStart of 9090 would mean the first address is 9090, the second is 9091,
	// and so on.
	PortStart int
	currPort  *atomic.Int64Counter
	generated []Address
}

func (f *Factory) initialize() {
	if f.currPort == nil {
		f.currPort = &atomic.Int64Counter{}
	}
}

// Generated returns all generated addresses.
func (f *Factory) Generated() []Address { return f.generated }

// Next returns the next address in the sequence. This address is guaranteed to be
// unique against all other addresses previously generated by the factory.
func (f *Factory) Next() Address {
	f.initialize()
	addr := Address(f.Host + ":" + strconv.Itoa(f.PortStart+int(f.currPort.Value())))
	f.currPort.Add(1)
	f.generated = append(f.generated, addr)
	return addr
}

// NextN returns a slice containing the next N addresses in the sequence.
// These addresses are guaranteed to be unique against all other addresses previously
// generated by the factory.
func (f *Factory) NextN(n int) (addresses []Address) {
	for range n {
		addresses = append(addresses, f.Next())
	}
	return addresses
}

// NewLocalFactory creates a new address Factory with localhost as its host name.
func NewLocalFactory(portStart int) *Factory {
	f := &Factory{Host: "localhost", PortStart: portStart}
	f.initialize()
	return f
}
