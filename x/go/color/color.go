// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package color

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/vmihailenco/msgpack/v5"
)

// Color is [4]uint8 representing RGBA (generated by Oracle in types.gen.go)

// R returns the red component (0-255).
func (c Color) R() uint8 { return c[0] }

// G returns the green component (0-255).
func (c Color) G() uint8 { return c[1] }

// B returns the blue component (0-255).
func (c Color) B() uint8 { return c[2] }

// A returns the alpha component (0-255).
func (c Color) A() uint8 { return c[3] }

// IsZero returns true if the color is the zero value (all components are 0).
func (c Color) IsZero() bool {
	return c[0] == 0 && c[1] == 0 && c[2] == 0 && c[3] == 0
}

// Bytes returns the color as a byte slice (for protobuf serialization).
func (c Color) Bytes() []byte {
	return c[:]
}

// FromBytes creates a Color from a byte slice.
// If the slice is nil or shorter than 4 bytes, missing values are zero.
func FromBytes(b []byte) Color {
	var c Color
	copy(c[:], b)
	return c
}

// FromHex parses a hex color string (#RRGGBB or #RRGGBBAA) into a Color.
// If no alpha is specified, defaults to 255 (fully opaque).
func FromHex(s string) (Color, error) {
	s = strings.TrimPrefix(s, "#")
	if len(s) != 6 && len(s) != 8 {
		return Color{}, fmt.Errorf("invalid hex color: %q (must be 6 or 8 hex digits)", s)
	}
	b, err := hex.DecodeString(s)
	if err != nil {
		return Color{}, fmt.Errorf("invalid hex color: %q: %w", s, err)
	}
	if len(b) == 3 {
		return Color{b[0], b[1], b[2], 255}, nil
	}
	return Color{b[0], b[1], b[2], b[3]}, nil
}

// Hex returns the hex representation of the color.
// Returns #RRGGBB if alpha is 255, otherwise #RRGGBBAA.
func (c Color) Hex() string {
	if c[3] == 255 {
		return fmt.Sprintf("#%02x%02x%02x", c[0], c[1], c[2])
	}
	return fmt.Sprintf("#%02x%02x%02x%02x", c[0], c[1], c[2], c[3])
}

// MarshalJSON outputs the color as a [R, G, B, A] array.
func (c Color) MarshalJSON() ([]byte, error) {
	return json.Marshal([]uint16{
		uint16(c[0]),
		uint16(c[1]),
		uint16(c[2]),
		uint16(c[3]),
	})
}

// UnmarshalJSON accepts BOTH hex string AND [R,G,B,A] array for backward compatibility.
func (c *Color) UnmarshalJSON(data []byte) error {
	// Handle null - leave as zero value
	if string(data) == "null" {
		return nil
	}
	var arr []uint8
	if err := json.Unmarshal(data, &arr); err == nil && len(arr) == 4 {
		c[0], c[1], c[2], c[3] = arr[0], arr[1], arr[2], arr[3]
		return nil
	}
	var hexStr string
	if err := json.Unmarshal(data, &hexStr); err == nil {
		parsed, err := FromHex(hexStr)
		if err != nil {
			return err
		}
		*c = parsed
		return nil
	}
	return fmt.Errorf("color must be [R,G,B,A] array or hex string")
}

// EncodeMsgpack outputs the color as 4-byte binary.
func (c Color) EncodeMsgpack(enc *msgpack.Encoder) error {
	return enc.EncodeBytes(c[:])
}

// DecodeMsgpack accepts bytes, array, or hex string for backward compatibility.
func (c *Color) DecodeMsgpack(dec *msgpack.Decoder) error {
	// Peek at the type
	code, err := dec.PeekCode()
	if err != nil {
		return err
	}

	// Handle null - leave as zero value
	if code == 0xc0 {
		return dec.DecodeNil()
	}

	// Binary data (new format)
	if code >= 0xc4 && code <= 0xc6 {
		b, err := dec.DecodeBytes()
		if err != nil {
			return err
		}
		if len(b) != 4 {
			return fmt.Errorf("color bytes must be exactly 4 bytes, got %d", len(b))
		}
		copy(c[:], b)
		return nil
	}

	// Array format
	if code >= 0x90 && code <= 0x9f || code == 0xdc || code == 0xdd {
		var arr []uint8
		if err := dec.Decode(&arr); err != nil {
			return err
		}
		if len(arr) != 4 {
			return fmt.Errorf("color array must have exactly 4 elements, got %d", len(arr))
		}
		copy(c[:], arr)
		return nil
	}

	// String format (hex - old format)
	if code >= 0xa0 && code <= 0xbf || code >= 0xd9 && code <= 0xdb {
		var hexStr string
		if err := dec.Decode(&hexStr); err != nil {
			return err
		}
		parsed, err := FromHex(hexStr)
		if err != nil {
			return err
		}
		*c = parsed
		return nil
	}

	return fmt.Errorf("color must be bytes, array, or hex string")
}
