// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package pb

import (
	"context"
	"github.com/synnaxlabs/x/spatial"
)

// XYToPB converts XY to XY.
func XYToPB(_ context.Context, r spatial.XY) (*XY, error) {
	pb := &XY{
		X: r.X,
		Y: r.Y,
	}
	return pb, nil
}

// XYFromPB converts XY to XY.
func XYFromPB(_ context.Context, pb *XY) (spatial.XY, error) {
	var r spatial.XY
	if pb == nil {
		return r, nil
	}
	r.X = pb.X
	r.Y = pb.Y
	return r, nil
}

// XYsToPB converts a slice of XY to XY.
func XYsToPB(ctx context.Context, rs []spatial.XY) ([]*XY, error) {
	result := make([]*XY, len(rs))
	for i := range rs {
		var err error
		result[i], err = XYToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// XYsFromPB converts a slice of XY to XY.
func XYsFromPB(ctx context.Context, pbs []*XY) ([]spatial.XY, error) {
	result := make([]spatial.XY, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = XYFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ClientXYToPB converts ClientXY to ClientXY.
func ClientXYToPB(_ context.Context, r spatial.ClientXY) (*ClientXY, error) {
	pb := &ClientXY{
		ClientX: r.ClientX,
		ClientY: r.ClientY,
	}
	return pb, nil
}

// ClientXYFromPB converts ClientXY to ClientXY.
func ClientXYFromPB(_ context.Context, pb *ClientXY) (spatial.ClientXY, error) {
	var r spatial.ClientXY
	if pb == nil {
		return r, nil
	}
	r.ClientX = pb.ClientX
	r.ClientY = pb.ClientY
	return r, nil
}

// ClientXYsToPB converts a slice of ClientXY to ClientXY.
func ClientXYsToPB(ctx context.Context, rs []spatial.ClientXY) ([]*ClientXY, error) {
	result := make([]*ClientXY, len(rs))
	for i := range rs {
		var err error
		result[i], err = ClientXYToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ClientXYsFromPB converts a slice of ClientXY to ClientXY.
func ClientXYsFromPB(ctx context.Context, pbs []*ClientXY) ([]spatial.ClientXY, error) {
	result := make([]spatial.ClientXY, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = ClientXYFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// DimensionsToPB converts Dimensions to Dimensions.
func DimensionsToPB(_ context.Context, r spatial.Dimensions) (*Dimensions, error) {
	pb := &Dimensions{
		Width:  r.Width,
		Height: r.Height,
	}
	return pb, nil
}

// DimensionsFromPB converts Dimensions to Dimensions.
func DimensionsFromPB(_ context.Context, pb *Dimensions) (spatial.Dimensions, error) {
	var r spatial.Dimensions
	if pb == nil {
		return r, nil
	}
	r.Width = pb.Width
	r.Height = pb.Height
	return r, nil
}

// DimensionssToPB converts a slice of Dimensions to Dimensions.
func DimensionssToPB(ctx context.Context, rs []spatial.Dimensions) ([]*Dimensions, error) {
	result := make([]*Dimensions, len(rs))
	for i := range rs {
		var err error
		result[i], err = DimensionsToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// DimensionssFromPB converts a slice of Dimensions to Dimensions.
func DimensionssFromPB(ctx context.Context, pbs []*Dimensions) ([]spatial.Dimensions, error) {
	result := make([]spatial.Dimensions, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = DimensionsFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// SignedDimensionsToPB converts SignedDimensions to SignedDimensions.
func SignedDimensionsToPB(_ context.Context, r spatial.SignedDimensions) (*SignedDimensions, error) {
	pb := &SignedDimensions{
		SignedWidth:  r.SignedWidth,
		SignedHeight: r.SignedHeight,
	}
	return pb, nil
}

// SignedDimensionsFromPB converts SignedDimensions to SignedDimensions.
func SignedDimensionsFromPB(_ context.Context, pb *SignedDimensions) (spatial.SignedDimensions, error) {
	var r spatial.SignedDimensions
	if pb == nil {
		return r, nil
	}
	r.SignedWidth = pb.SignedWidth
	r.SignedHeight = pb.SignedHeight
	return r, nil
}

// SignedDimensionssToPB converts a slice of SignedDimensions to SignedDimensions.
func SignedDimensionssToPB(ctx context.Context, rs []spatial.SignedDimensions) ([]*SignedDimensions, error) {
	result := make([]*SignedDimensions, len(rs))
	for i := range rs {
		var err error
		result[i], err = SignedDimensionsToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// SignedDimensionssFromPB converts a slice of SignedDimensions to SignedDimensions.
func SignedDimensionssFromPB(ctx context.Context, pbs []*SignedDimensions) ([]spatial.SignedDimensions, error) {
	result := make([]spatial.SignedDimensions, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = SignedDimensionsFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// BoundsToPB converts Bounds to Bounds.
func BoundsToPB(_ context.Context, r spatial.Bounds) (*Bounds, error) {
	pb := &Bounds{
		Lower: r.Lower,
		Upper: r.Upper,
	}
	return pb, nil
}

// BoundsFromPB converts Bounds to Bounds.
func BoundsFromPB(_ context.Context, pb *Bounds) (spatial.Bounds, error) {
	var r spatial.Bounds
	if pb == nil {
		return r, nil
	}
	r.Lower = pb.Lower
	r.Upper = pb.Upper
	return r, nil
}

// BoundssToPB converts a slice of Bounds to Bounds.
func BoundssToPB(ctx context.Context, rs []spatial.Bounds) ([]*Bounds, error) {
	result := make([]*Bounds, len(rs))
	for i := range rs {
		var err error
		result[i], err = BoundsToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// BoundssFromPB converts a slice of Bounds to Bounds.
func BoundssFromPB(ctx context.Context, pbs []*Bounds) ([]spatial.Bounds, error) {
	result := make([]spatial.Bounds, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = BoundsFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AlignmentToPB converts spatial.Alignment to Alignment.
func AlignmentToPB(v spatial.Alignment) Alignment {
	switch v {
	case spatial.AlignmentStart:
		return Alignment_ALIGNMENT_START
	case spatial.AlignmentCenter:
		return Alignment_ALIGNMENT_CENTER
	case spatial.AlignmentEnd:
		return Alignment_ALIGNMENT_END
	default:
		return Alignment_ALIGNMENT_UNSPECIFIED
	}
}

// AlignmentFromPB converts Alignment to spatial.Alignment.
func AlignmentFromPB(v Alignment) spatial.Alignment {
	switch v {
	case Alignment_ALIGNMENT_START:
		return spatial.AlignmentStart
	case Alignment_ALIGNMENT_CENTER:
		return spatial.AlignmentCenter
	case Alignment_ALIGNMENT_END:
		return spatial.AlignmentEnd
	default:
		return spatial.AlignmentStart
	}
}

// OrderToPB converts spatial.Order to Order.
func OrderToPB(v spatial.Order) Order {
	switch v {
	case spatial.OrderFirst:
		return Order_ORDER_FIRST
	case spatial.OrderLast:
		return Order_ORDER_LAST
	default:
		return Order_ORDER_UNSPECIFIED
	}
}

// OrderFromPB converts Order to spatial.Order.
func OrderFromPB(v Order) spatial.Order {
	switch v {
	case Order_ORDER_FIRST:
		return spatial.OrderFirst
	case Order_ORDER_LAST:
		return spatial.OrderLast
	default:
		return spatial.OrderFirst
	}
}

// DirectionToPB converts spatial.Direction to Direction.
func DirectionToPB(v spatial.Direction) Direction {
	switch v {
	case spatial.DirectionX:
		return Direction_DIRECTION_X
	case spatial.DirectionY:
		return Direction_DIRECTION_Y
	default:
		return Direction_DIRECTION_UNSPECIFIED
	}
}

// DirectionFromPB converts Direction to spatial.Direction.
func DirectionFromPB(v Direction) spatial.Direction {
	switch v {
	case Direction_DIRECTION_X:
		return spatial.DirectionX
	case Direction_DIRECTION_Y:
		return spatial.DirectionY
	default:
		return spatial.DirectionX
	}
}

// OuterLocationToPB converts spatial.OuterLocation to OuterLocation.
func OuterLocationToPB(v spatial.OuterLocation) OuterLocation {
	switch v {
	case spatial.OuterLocationTop:
		return OuterLocation_OUTER_LOCATION_TOP
	case spatial.OuterLocationRight:
		return OuterLocation_OUTER_LOCATION_RIGHT
	case spatial.OuterLocationBottom:
		return OuterLocation_OUTER_LOCATION_BOTTOM
	case spatial.OuterLocationLeft:
		return OuterLocation_OUTER_LOCATION_LEFT
	default:
		return OuterLocation_OUTER_LOCATION_UNSPECIFIED
	}
}

// OuterLocationFromPB converts OuterLocation to spatial.OuterLocation.
func OuterLocationFromPB(v OuterLocation) spatial.OuterLocation {
	switch v {
	case OuterLocation_OUTER_LOCATION_TOP:
		return spatial.OuterLocationTop
	case OuterLocation_OUTER_LOCATION_RIGHT:
		return spatial.OuterLocationRight
	case OuterLocation_OUTER_LOCATION_BOTTOM:
		return spatial.OuterLocationBottom
	case OuterLocation_OUTER_LOCATION_LEFT:
		return spatial.OuterLocationLeft
	default:
		return spatial.OuterLocationTop
	}
}

// XLocationToPB converts spatial.XLocation to XLocation.
func XLocationToPB(v spatial.XLocation) XLocation {
	switch v {
	case spatial.XLocationLeft:
		return XLocation_X_LOCATION_LEFT
	case spatial.XLocationRight:
		return XLocation_X_LOCATION_RIGHT
	default:
		return XLocation_X_LOCATION_UNSPECIFIED
	}
}

// XLocationFromPB converts XLocation to spatial.XLocation.
func XLocationFromPB(v XLocation) spatial.XLocation {
	switch v {
	case XLocation_X_LOCATION_LEFT:
		return spatial.XLocationLeft
	case XLocation_X_LOCATION_RIGHT:
		return spatial.XLocationRight
	default:
		return spatial.XLocationLeft
	}
}

// YLocationToPB converts spatial.YLocation to YLocation.
func YLocationToPB(v spatial.YLocation) YLocation {
	switch v {
	case spatial.YLocationTop:
		return YLocation_Y_LOCATION_TOP
	case spatial.YLocationBottom:
		return YLocation_Y_LOCATION_BOTTOM
	default:
		return YLocation_Y_LOCATION_UNSPECIFIED
	}
}

// YLocationFromPB converts YLocation to spatial.YLocation.
func YLocationFromPB(v YLocation) spatial.YLocation {
	switch v {
	case YLocation_Y_LOCATION_TOP:
		return spatial.YLocationTop
	case YLocation_Y_LOCATION_BOTTOM:
		return spatial.YLocationBottom
	default:
		return spatial.YLocationTop
	}
}

// CenterLocationToPB converts spatial.CenterLocation to CenterLocation.
func CenterLocationToPB(v spatial.CenterLocation) CenterLocation {
	switch v {
	case spatial.CenterLocationCenter:
		return CenterLocation_CENTER_LOCATION_CENTER
	default:
		return CenterLocation_CENTER_LOCATION_UNSPECIFIED
	}
}

// CenterLocationFromPB converts CenterLocation to spatial.CenterLocation.
func CenterLocationFromPB(v CenterLocation) spatial.CenterLocation {
	switch v {
	case CenterLocation_CENTER_LOCATION_CENTER:
		return spatial.CenterLocationCenter
	default:
		return spatial.CenterLocationCenter
	}
}

// LocationToPB converts spatial.Location to Location.
func LocationToPB(v spatial.Location) Location {
	switch v {
	case spatial.LocationTop:
		return Location_LOCATION_TOP
	case spatial.LocationRight:
		return Location_LOCATION_RIGHT
	case spatial.LocationBottom:
		return Location_LOCATION_BOTTOM
	case spatial.LocationLeft:
		return Location_LOCATION_LEFT
	case spatial.LocationCenter:
		return Location_LOCATION_CENTER
	default:
		return Location_LOCATION_UNSPECIFIED
	}
}

// LocationFromPB converts Location to spatial.Location.
func LocationFromPB(v Location) spatial.Location {
	switch v {
	case Location_LOCATION_TOP:
		return spatial.LocationTop
	case Location_LOCATION_RIGHT:
		return spatial.LocationRight
	case Location_LOCATION_BOTTOM:
		return spatial.LocationBottom
	case Location_LOCATION_LEFT:
		return spatial.LocationLeft
	case Location_LOCATION_CENTER:
		return spatial.LocationCenter
	default:
		return spatial.LocationTop
	}
}
