// Code generated by jerky. DO NOT EDIT.

package {{ .SubPackageName }}

{{- range .Migrations }}
{{- if ne .FromVersion 0 }}

// MigrateV{{ .FromVersion }}ToV{{ .ToVersion }} converts V{{ .FromVersion }} to V{{ .ToVersion }} for {{ .TypeName }}.
func MigrateV{{ .FromVersion }}ToV{{ .ToVersion }}(old *V{{ .FromVersion }}) *V{{ .ToVersion }} {
	if old == nil {
		return nil
	}
	new := &V{{ .ToVersion }}{
{{- range .CommonFields }}
		{{ . }}: old.{{ . }},
{{- end }}
	}
	MigrateV{{ .FromVersion }}ToV{{ .ToVersion }}Hook(old, new)
	return new
}

// MigrateV{{ .FromVersion }}ToV{{ .ToVersion }}Slice converts a slice of V{{ .FromVersion }} to V{{ .ToVersion }}.
func MigrateV{{ .FromVersion }}ToV{{ .ToVersion }}Slice(old []*V{{ .FromVersion }}) []*V{{ .ToVersion }} {
	if old == nil {
		return nil
	}
	result := make([]*V{{ .ToVersion }}, len(old))
	for i, v := range old {
		result[i] = MigrateV{{ .FromVersion }}ToV{{ .ToVersion }}(v)
	}
	return result
}

// MigrateV{{ .FromVersion }}ToV{{ .ToVersion }}Map converts a map with V{{ .FromVersion }} values to V{{ .ToVersion }}.
func MigrateV{{ .FromVersion }}ToV{{ .ToVersion }}Map[K comparable](old map[K]*V{{ .FromVersion }}) map[K]*V{{ .ToVersion }} {
	if old == nil {
		return nil
	}
	result := make(map[K]*V{{ .ToVersion }}, len(old))
	for k, v := range old {
		result[k] = MigrateV{{ .FromVersion }}ToV{{ .ToVersion }}(v)
	}
	return result
}
{{- end }}
{{- end }}
