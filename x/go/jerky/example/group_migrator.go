// Code generated by jerky. DO NOT EDIT.

package example

import (
	"context"
	"fmt"

	"github.com/synnaxlabs/x/jerky/example/types"
	"github.com/synnaxlabs/x/gorp"
	"github.com/synnaxlabs/x/kv"
	xtypes "github.com/synnaxlabs/x/types"
)

// GroupMigrator implements migrate.TypedMigrator for Group.
type GroupMigrator struct{}

// TypeName returns the name of the type being migrated.
func (GroupMigrator) TypeName() string { return "Group" }

// CurrentVersion returns the current schema version.
func (GroupMigrator) CurrentVersion() int { return 1 }

// MigrateAll migrates all Group records from the given version to current.
func (m GroupMigrator) MigrateAll(ctx context.Context, db *gorp.DB, fromVersion int) error {
	// Compute the prefix using gorp's type naming convention.
	// gorp stores entries with a prefix of the encoded type name.
	prefix, err := db.Encode(ctx, xtypes.Name[Group]())
	if err != nil {
		return fmt.Errorf("failed to compute prefix: %w", err)
	}

	iter, err := db.OpenIterator(kv.IterPrefix(prefix))
	if err != nil {
		return fmt.Errorf("failed to open iterator: %w", err)
	}
	defer iter.Close()

	count := 0
	for iter.First(); iter.Valid(); iter.Next() {
		key := make([]byte, len(iter.Key()))
		copy(key, iter.Key())

		data := make([]byte, len(iter.Value()))
		copy(data, iter.Value())

		// Run migrations sequentially from fromVersion to current
		migratedData, err := types.GroupMigrations.MigrateToLatest(data, fromVersion)
		if err != nil {
			return fmt.Errorf("failed to migrate key %x: %w", key, err)
		}

		// Write back to the database
		if err := db.Set(ctx, key, migratedData); err != nil {
			return fmt.Errorf("failed to write key %x: %w", key, err)
		}

		count++
	}

	if err := iter.Error(); err != nil {
		return fmt.Errorf("iterator error: %w", err)
	}

	fmt.Printf("jerky: migrated %d Group records\n", count)
	return nil
}
