// Code generated by jerky. DO NOT EDIT.

package example

import (
	"context"
	"fmt"

	user "github.com/synnaxlabs/x/jerky/example/types/user"
	"github.com/synnaxlabs/x/errors"
	"github.com/synnaxlabs/x/gorp"
	"github.com/synnaxlabs/x/kv"
	xtypes "github.com/synnaxlabs/x/types"
)

// UserMigrator implements migrate.TypedMigrator for User.
type UserMigrator struct{}

// TypeName returns the name of the type being migrated.
func (UserMigrator) TypeName() string { return "User" }

// CurrentVersion returns the current schema version.
func (UserMigrator) CurrentVersion() int { return 1 }

// MigrateAll migrates all User records from the given version to current.
func (m UserMigrator) MigrateAll(ctx context.Context, db *gorp.DB, fromVersion int) error {
	// Compute the prefix using gorp's type naming convention.
	// gorp stores entries with a prefix of the encoded type name.
	prefix, err := db.Encode(ctx, xtypes.Name[User]())
	if err != nil {
		return errors.Newf("failed to compute prefix: %w", err)
	}

	iter, err := db.OpenIterator(kv.IterPrefix(prefix))
	if err != nil {
		return errors.Newf("failed to open iterator: %w", err)
	}
	defer iter.Close()

	count := 0
	for iter.First(); iter.Valid(); iter.Next() {
		key := make([]byte, len(iter.Key()))
		copy(key, iter.Key())

		data := make([]byte, len(iter.Value()))
		copy(data, iter.Value())

		// Run migrations sequentially from fromVersion to current
		migratedData, err := user.Migrations.MigrateToLatest(data, fromVersion)
		if err != nil {
			return errors.Newf("failed to migrate key %x: %w", key, err)
		}

		// Write back to the database
		if err := db.Set(ctx, key, migratedData); err != nil {
			return errors.Newf("failed to write key %x: %w", key, err)
		}

		count++
	}

	if err := iter.Error(); err != nil {
		return errors.Newf("iterator error: %w", err)
	}

	fmt.Printf("jerky: migrated %d User records\n", count)
	return nil
}
