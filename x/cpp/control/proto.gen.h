// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <type_traits>
#include <utility>

#include "x/cpp/control/json.gen.h"
#include "x/cpp/control/types.gen.h"
#include "x/cpp/errors/errors.h"
#include "x/cpp/json/any.h"
#include "x/cpp/json/json.h"

#include "x/go/control/pb/control.pb.h"

namespace x::control {

inline ::x::control::pb::Subject Subject::to_proto() const {
    ::x::control::pb::Subject pb;
    pb.set_key(this->key);
    pb.set_name(this->name);
    return pb;
}

inline std::pair<Subject, x::errors::Error>
Subject::from_proto(const ::x::control::pb::Subject &pb) {
    Subject cpp;
    cpp.key = pb.key();
    cpp.name = pb.name();
    return {cpp, x::errors::NIL};
}

template<typename R>
inline ::x::control::pb::State State<R>::to_proto() const {
    ::x::control::pb::State pb;
    *pb.mutable_subject() = this->subject.to_proto();
    if constexpr (std::is_same_v<R, x::json::json>) {
        *pb.mutable_resource() = x::json::to_any(this->resource);
    } else {
        *pb.mutable_resource() = x::json::to_any(this->resource.to_json());
    }
    pb.set_authority(this->authority);
    return pb;
}

template<typename R>
inline std::pair<State<R>, x::errors::Error>
State<R>::from_proto(const ::x::control::pb::State &pb) {
    State<R> cpp;
    {
        auto [val, err] = Subject::from_proto(pb.subject());
        if (err) return {{}, err};
        cpp.subject = val;
    }
    if constexpr (std::is_same_v<R, x::json::json>) {
        {
            auto [val, err] = x::json::from_any(pb.resource());
            if (err) return {{}, err};
            cpp.resource = val;
        }
    } else {
        {
            auto [val, err] = x::json::from_any(pb.resource());
            if (err) return {{}, err};
            cpp.resource = R::parse(x::json::Parser(val));
        }
    }
    cpp.authority = pb.authority();
    return {cpp, x::errors::NIL};
}

}
