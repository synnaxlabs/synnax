// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#include "x/cpp/label/translator.gen.h"
#include "x/cpp/status/translator.gen.h"

#include "x/go/status/pb/status.pb.h"

namespace synnax::status {

x::status::Variant VariantToPB(const std::string &cpp) {
    if (cpp == variant_success) return x::status::VARIANT_SUCCESS;
    if (cpp == variant_info) return x::status::VARIANT_INFO;
    if (cpp == variant_warning) return x::status::VARIANT_WARNING;
    if (cpp == variant_error) return x::status::VARIANT_ERROR;
    if (cpp == variant_loading) return x::status::VARIANT_LOADING;
    if (cpp == variant_disabled) return x::status::VARIANT_DISABLED;
    return x::status::VARIANT_UNSPECIFIED;
}

std::string VariantFromPB(x::status::Variant pb) {
    switch (pb) {
        case x::status::VARIANT_SUCCESS:
            return variant_success;
        case x::status::VARIANT_INFO:
            return variant_info;
        case x::status::VARIANT_WARNING:
            return variant_warning;
        case x::status::VARIANT_ERROR:
            return variant_error;
        case x::status::VARIANT_LOADING:
            return variant_loading;
        case x::status::VARIANT_DISABLED:
            return variant_disabled;
        default:
            return variant_success;
    }
}

x::status::Status to_pb(const Status &cpp) {
    x::status::Status pb;
    pb.set_key(cpp.key);
    pb.set_name(cpp.name);
    pb.set_message(cpp.message);
    pb.set_description(cpp.description);
    pb.set_time(cpp.time.nanoseconds());
    pb.mutable_details()->PackFrom(proto_type<Details>::to_pb(cpp.details));
    for (const auto &item: cpp.labels)
        *pb.add_labels() = synnax::label::to_pb(item);
    pb.set_variant(VariantToPB(cpp.variant));
    return pb;
}

Status from_pb(const x::status::Status &pb) {
    Status cpp;
    cpp.key = pb.key();
    cpp.name = pb.name();
    cpp.message = pb.message();
    cpp.description = pb.description();
    cpp.time = telem::TimeStamp(pb.time());
    {
        typename proto_type<Details>::type details_pb;
        if (!pb.details().UnpackTo(&details_pb))
            return {{}, errors::Error("failed to unpack details")};
        auto [details_val, details_err] = proto_type<Details>::from_pb(details_pb);
        if (details_err) return {{}, details_err};
        cpp.details = details_val;
    };
    for (const auto &item: pb.labels()) {
        auto [v, err] = synnax::label::from_pb(item);
        if (err) return {{}, err};
        cpp.labels.push_back(v);
    };
    cpp.variant = VariantFromPB(pb.variant());
    return cpp;
}

std::vector<x::status::Status> to_pb(const std::vector<Status> &cpp) {
    std::vector<x::status::Status> pb;
    pb.reserve(cpp.size());
    for (const auto &item: cpp)
        pb.push_back(to_pb(item));
    return pb;
}

std::vector<Status> from_pb(const std::vector<x::status::Status> &pb) {
    std::vector<Status> cpp;
    cpp.reserve(pb.size());
    for (const auto &item: pb)
        cpp.push_back(from_pb(item));
    return cpp;
}

}
