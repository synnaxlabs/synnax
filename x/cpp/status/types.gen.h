// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/json.h"
#include "x/cpp/label/types.gen.h"
#include "x/cpp/telem/telem.h"

namespace x::status {

constexpr const char *VARIANT_SUCCESS = "success";
constexpr const char *VARIANT_INFO = "info";
constexpr const char *VARIANT_WARNING = "warning";
constexpr const char *VARIANT_ERROR = "error";
constexpr const char *VARIANT_LOADING = "loading";
constexpr const char *VARIANT_DISABLED = "disabled";

template<typename Details>
struct Status {
    std::string key;
    std::string name;
    std::string message;
    std::string description;
    x::telem::TimeStamp time;
    Details details;
    std::vector<x::label::Label> labels;
    std::string variant;

    static Status parse(x::json::Parser parser) {
        return Status{
            .key = parser.field<std::string>("key"),
            .name = parser.field<std::string>("name"),
            .message = parser.field<std::string>("message"),
            .description = parser.field<std::string>("description", ""),
            .time = telem::TimeStamp(parser.field<std::int64_t>("time")),
            .details = [&]() -> Details {
                if constexpr (std::is_same_v<Details, x::json::json>) {
                    return parser.field<x::json::json>("details", x::json::json{});
                } else {
                    return Details::parse(parser.optional_child("details"));
                }
            }(),
            .labels = parser.field<std::vector<x::label::Label>>("labels", {}),
            .variant = parser.field<std::string>("variant"),
        };
    }

    [[nodiscard]] x::json::json to_json() const {
        x::json::json j;
        j["key"] = this->key;
        j["name"] = this->name;
        j["message"] = this->message;
        j["description"] = this->description;
        j["time"] = this->time.nanoseconds();
        if constexpr (std::is_same_v<Details, x::json::json>) {
            j["details"] = this->details;
        } else {
            j["details"] = this->details.to_json();
        }
        {
            auto arr = x::json::json::array();
            for (const auto &item: this->labels)
                arr.push_back(item.to_json());
            j["labels"] = arr;
        }
        j["variant"] = this->variant;
        return j;
    }

    using proto_type = x::status::Status;
    [[nodiscard]] x::status::Status to_proto() const;
    static std::pair<Status, x::errors::Error> from_proto(const x::status::Status &pb);
};
}
