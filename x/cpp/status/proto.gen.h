// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <type_traits>
#include <utility>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/any.h"
#include "x/cpp/label/proto.gen.h"
#include "x/cpp/status/types.gen.h"

#include "x/go/status/pb/status.pb.h"

namespace x::status {

inline ::x::status::pb::Variant VariantToPB(const std::string &cpp) {
    if (cpp == VARIANT_SUCCESS) return ::x::status::pb::VARIANT_SUCCESS;
    if (cpp == VARIANT_INFO) return ::x::status::pb::VARIANT_INFO;
    if (cpp == VARIANT_WARNING) return ::x::status::pb::VARIANT_WARNING;
    if (cpp == VARIANT_ERROR) return ::x::status::pb::VARIANT_ERROR;
    if (cpp == VARIANT_LOADING) return ::x::status::pb::VARIANT_LOADING;
    if (cpp == VARIANT_DISABLED) return ::x::status::pb::VARIANT_DISABLED;
    return ::x::status::pb::VARIANT_SUCCESS;
}

inline std::string VariantFromPB(::x::status::pb::Variant pb) {
    switch (pb) {
        case ::x::status::pb::VARIANT_SUCCESS:
            return VARIANT_SUCCESS;
        case ::x::status::pb::VARIANT_INFO:
            return VARIANT_INFO;
        case ::x::status::pb::VARIANT_WARNING:
            return VARIANT_WARNING;
        case ::x::status::pb::VARIANT_ERROR:
            return VARIANT_ERROR;
        case ::x::status::pb::VARIANT_LOADING:
            return VARIANT_LOADING;
        case ::x::status::pb::VARIANT_DISABLED:
            return VARIANT_DISABLED;
        default:
            return VARIANT_SUCCESS;
    }
}

template<typename Details>
inline ::x::status::pb::Status Status<Details>::to_proto() const {
    ::x::status::pb::Status pb;
    pb.set_key(this->key);
    pb.set_name(this->name);
    pb.set_variant(VariantToPB(this->variant));
    pb.set_message(this->message);
    pb.set_description(this->description);
    pb.set_time(this->time.to_proto());
    if constexpr (std::is_same_v<Details, x::json::json>) {
        *pb.mutable_details() = x::json::to_any(this->details);
    } else {
        pb.mutable_details()->PackFrom(this->details.to_proto());
    }
    for (const auto &item: this->labels)
        *pb.add_labels() = item.to_proto();
    return pb;
}

template<typename Details>
inline std::pair<Status<Details>, x::errors::Error>
Status<Details>::from_proto(const ::x::status::pb::Status &pb) {
    Status<Details> cpp;
    cpp.key = pb.key();
    cpp.name = pb.name();
    cpp.variant = VariantFromPB(pb.variant());
    cpp.message = pb.message();
    cpp.description = pb.description();
    cpp.time = x::telem::TimeStamp::from_proto(pb.time());
    if constexpr (std::is_same_v<Details, x::json::json>) {
        {
            auto [val, err] = x::json::from_any(pb.details());
            if (err) return {{}, err};
            cpp.details = val;
        }
    } else {
        {
            typename Details::proto_type pb_val;
            if (!pb.details().UnpackTo(&pb_val))
                return {{}, x::errors::Error("failed to unpack details")};
            auto [val, err] = Details::from_proto(pb_val);
            if (err) return {{}, err};
            cpp.details = val;
        }
    }
    for (const auto &item: pb.labels()) {
        auto [v, err] = ::x::label::Label::from_proto(item);
        if (err) return {{}, err};
        cpp.labels.push_back(v);
    }
    return {cpp, x::errors::NIL};
}

}
