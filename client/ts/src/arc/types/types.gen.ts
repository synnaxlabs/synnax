// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by Oracle. DO NOT EDIT.

import { zod } from "@synnaxlabs/x";
import { z } from "zod";


export const paramsZ = z.array(paramZ);
export type Params = z.infer<typeof paramsZ>;
export enum Kind {
  invalid = 0,
  u8 = 1,
  u16 = 2,
  u32 = 3,
  u64 = 4,
  i8 = 5,
  i16 = 6,
  i32 = 7,
  i64 = 8,
  f32 = 9,
  f64 = 10,
  string = 11,
  chan = 14,
  series = 15,
  variable = 16,
  numeric_constant = 17,
  integer_constant = 18,
  float_constant = 19,
  function = 20,
  sequence = 21,
  stage = 22,
}
export const kindZ = z.enum(Kind);

export const functionPropertiesZ = z.object({
  inputs: paramsZ.optional(),
  outputs: paramsZ.optional(),
  config: paramsZ.optional(),
});
export interface FunctionProperties extends z.infer<typeof functionPropertiesZ> {}

export const channelsZ = z.object({
  read: z.record(z.uint32(), z.string()),
  write: z.record(z.uint32(), z.string()),
});
export interface Channels extends z.infer<typeof channelsZ> {}

export const dimensionsZ = z.object({
  length: zod.int8Z,
  mass: zod.int8Z,
  time: zod.int8Z,
  current: zod.int8Z,
  temperature: zod.int8Z,
  angle: zod.int8Z,
  count: zod.int8Z,
  data: zod.int8Z,
});
export interface Dimensions extends z.infer<typeof dimensionsZ> {}

export const unitZ = z.object({
  dimensions: dimensionsZ,
  scale: z.number(),
  name: z.string(),
});
export interface Unit extends z.infer<typeof unitZ> {}

export const typeZ = functionPropertiesZ
  .extend({
    kind: kindZ,
    name: z.string(),
    get elem() {
      return typeZ.optional();
    },
    unit: unitZ.optional(),
    get constraint() {
      return typeZ.optional();
    },
  });
export interface Type extends z.infer<typeof typeZ> {}

export const paramZ = z.object({
  name: z.string(),
  type: typeZ,
  value: z.unknown().optional(),
});
export interface Param extends z.infer<typeof paramZ> {}
