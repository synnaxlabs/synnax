// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by Oracle. DO NOT EDIT.

import { array } from "@synnaxlabs/x";
import { z } from "zod";

import { types } from "@/arc/types";
export enum EdgeKind {
  unspecified = 0,
  continuous = 1,
  one_shot = 2,
}
export const edgeKindZ = z.enum(EdgeKind);

/** Handle is a reference to a specific parameter on a specific node in the dataflow graph. */
export const handleZ = z.object({
  /** node is the node identifier. */
  node: z.string(),
  /** param is the parameter name (input or output). */
  param: z.string(),
});
export interface Handle extends z.infer<typeof handleZ> {}

/** Body is raw function body source code with optional parsed AST. */
export const bodyZ = z.object({
  /** raw is the raw source code text. */
  raw: z.string(),
});
export interface Body extends z.infer<typeof bodyZ> {}

/** Node is a concrete instantiation of a function with typed parameters and configuration values. */
export const nodeZ = z.object({
  /** key is the unique identifier for this node instance. */
  key: z.string(),
  /** type is the function type being instantiated. */
  type: z.string(),
  /** config contains configuration parameter values. */
  config: types.paramsZ.optional(),
  /** inputs contains input parameter type signatures. */
  inputs: types.paramsZ.optional(),
  /** outputs contains output parameter type signatures. */
  outputs: types.paramsZ.optional(),
  /** channels contains channel read/write mappings. */
  channels: types.channelsZ.optional(),
});
export interface Node extends z.infer<typeof nodeZ> {}

export const stratumZ = array.nullishToEmpty(z.string());
export type Stratum = z.infer<typeof stratumZ>;

/** Edge is a dataflow connection between node parameters in the Arc graph. */
export const edgeZ = z.object({
  /** source is the source node parameter producing data. */
  source: handleZ,
  /** target is the target node parameter consuming data. */
  target: handleZ,
  /** kind defines execution semantics for this connection. */
  kind: edgeKindZ.optional(),
});
export interface Edge extends z.infer<typeof edgeZ> {}

/** Function is a function template definition with typed parameters, serving as a blueprint for node instantiation. */
export const functionZ = z.object({
  /** key is the function identifier (template name). */
  key: z.string(),
  /** body is raw source code for user-defined functions. */
  body: bodyZ.optional(),
  /** config contains configuration parameter definitions. */
  config: types.paramsZ.optional(),
  /** inputs contains input parameter definitions. */
  inputs: types.paramsZ.optional(),
  /** outputs contains output parameter definitions. */
  outputs: types.paramsZ.optional(),
  /** channels contains channel read/write declarations. */
  channels: types.channelsZ.optional(),
});
export interface Function extends z.infer<typeof functionZ> {}

export const nodesZ = array.nullishToEmpty(nodeZ);
export type Nodes = z.infer<typeof nodesZ>;

export const strataZ = array.nullishToEmpty(stratumZ);
export type Strata = z.infer<typeof strataZ>;

export const edgesZ = array.nullishToEmpty(edgeZ);
export type Edges = z.infer<typeof edgesZ>;

export const functionsZ = array.nullishToEmpty(functionZ);
export type Functions = z.infer<typeof functionsZ>;

/** Stage is a stage in a sequence state machine, containing active nodes and their execution stratification. */
export const stageZ = z.object({
  /** key is the stage identifier. */
  key: z.string(),
  /** nodes contains node keys active in this stage. */
  nodes: array.nullishToEmpty(z.string()),
  /** strata contains execution stratification for nodes in this stage. */
  strata: strataZ,
});
export interface Stage extends z.infer<typeof stageZ> {}

/** Sequence is a state machine defining ordered stages of execution, where entry point is always the first stage. */
export const sequenceZ = z.object({
  /** key is the sequence identifier. */
  key: z.string(),
  /** stages contains ordered stages in this sequence. */
  stages: array.nullishToEmpty(stageZ),
});
export interface Sequence extends z.infer<typeof sequenceZ> {}

export const stagesZ = array.nullishToEmpty(stageZ);
export type Stages = z.infer<typeof stagesZ>;

export const sequencesZ = array.nullishToEmpty(sequenceZ);
export type Sequences = z.infer<typeof sequencesZ>;

/** IR is the intermediate representation of an Arc program as a dataflow graph with stratified execution, bridging semantic analysis and WebAssembly compilation. */
export const irZ = z.object({
  /** functions contains function template definitions. */
  functions: functionsZ.optional(),
  /** nodes contains node instantiations. */
  nodes: nodesZ.optional(),
  /** edges contains dataflow connections. */
  edges: edgesZ.optional(),
  /** strata contains execution stratification layers. */
  strata: strataZ.optional(),
  /** sequences contains state machine definitions. */
  sequences: sequencesZ.optional(),
});
export interface IR extends z.infer<typeof irZ> {}
