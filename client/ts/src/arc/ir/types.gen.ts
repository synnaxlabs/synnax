// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by Oracle. DO NOT EDIT.

import { array } from "@synnaxlabs/x";
import { z } from "zod";

import { types } from "@/arc/types";

export const edgesZ = z.array(edgeZ);
export type Edges = z.infer<typeof edgesZ>;

export const stagesZ = z.array(stageZ);
export type Stages = z.infer<typeof stagesZ>;

export const sequencesZ = z.array(sequenceZ);
export type Sequences = z.infer<typeof sequencesZ>;

export const functionsZ = z.array(functionZ);
export type Functions = z.infer<typeof functionsZ>;

export const strataZ = z.array(stratumZ);
export type Strata = z.infer<typeof strataZ>;

export const nodesZ = z.array(nodeZ);
export type Nodes = z.infer<typeof nodesZ>;
export enum EdgeKind {
  continuous = 1,
  one_shot = 2,
}
export const edgeKindZ = z.enum(EdgeKind);

export const stratumZ = z.array(z.string());
export type Stratum = z.infer<typeof stratumZ>;

export const handleZ = z.object({
  node: z.string(),
  param: z.string(),
});
export interface Handle extends z.infer<typeof handleZ> {}

export const stageZ = z.object({
  key: z.string(),
  nodes: array.nullishToEmpty(z.string()),
  strata: strataZ,
});
export interface Stage extends z.infer<typeof stageZ> {}

export const bodyZ = z.object({
  raw: z.string(),
});
export interface Body extends z.infer<typeof bodyZ> {}

export const nodeZ = z.object({
  key: z.string(),
  type: z.string(),
  config: types.paramsZ.optional(),
  inputs: types.paramsZ.optional(),
  outputs: types.paramsZ.optional(),
  channels: types.channelsZ.optional(),
});
export interface Node extends z.infer<typeof nodeZ> {}

export const irZ = z.object({
  functions: functionsZ.optional(),
  nodes: nodesZ.optional(),
  edges: edgesZ.optional(),
  strata: strataZ.optional(),
  sequences: sequencesZ.optional(),
});
export interface IR extends z.infer<typeof irZ> {}

export const edgeZ = z.object({
  source: handleZ,
  target: handleZ,
  kind: edgeKindZ.optional(),
});
export interface Edge extends z.infer<typeof edgeZ> {}

export const sequenceZ = z.object({
  key: z.string(),
  stages: array.nullishToEmpty(stageZ),
});
export interface Sequence extends z.infer<typeof sequenceZ> {}

export const functionZ = z.object({
  key: z.string(),
  body: bodyZ.optional(),
  config: types.paramsZ.optional(),
  inputs: types.paramsZ.optional(),
  outputs: types.paramsZ.optional(),
  channels: types.channelsZ.optional(),
});
export interface Function extends z.infer<typeof functionZ> {}
