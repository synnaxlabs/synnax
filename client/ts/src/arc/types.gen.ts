// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by Oracle. DO NOT EDIT.

import { array, spatial, status, zod } from "@synnaxlabs/x";
import { z } from "zod";

import { ontology } from "@/ontology";

export const paramsZ = z.array(paramZ);
export type Params = z.infer<typeof paramsZ>;

export const edgesZ = z.array(edgeZ);
export type Edges = z.infer<typeof edgesZ>;

export const stagesZ = z.array(stageZ);
export type Stages = z.infer<typeof stagesZ>;

export const sequencesZ = z.array(sequenceZ);
export type Sequences = z.infer<typeof sequencesZ>;

export const functionsZ = z.array(functionZ);
export type Functions = z.infer<typeof functionsZ>;

export const stratumZ = z.array(z.string());
export type Stratum = z.infer<typeof stratumZ>;

export const strataZ = z.array(stratumZ);
export type Strata = z.infer<typeof strataZ>;

export const nodesZ = z.array(nodeZ);
export type Nodes = z.infer<typeof nodesZ>;

export const graphNodesZ = z.array(graphNodeZ);
export type GraphNodes = z.infer<typeof graphNodesZ>;
export enum Kind {
  invalid = 0,
  u8 = 1,
  u16 = 2,
  u32 = 3,
  u64 = 4,
  i8 = 5,
  i16 = 6,
  i32 = 7,
  i64 = 8,
  f32 = 9,
  f64 = 10,
  string = 11,
  chan = 14,
  series = 15,
  variable = 16,
  numeric_constant = 17,
  integer_constant = 18,
  float_constant = 19,
  function = 20,
  sequence = 21,
  stage = 22,
}
export const kindZ = z.enum(Kind);
export enum EdgeKind {
  continuous = 1,
  one_shot = 2,
}
export const edgeKindZ = z.enum(EdgeKind);

export const keyZ = z.uuid();
export type Key = z.infer<typeof keyZ>;

export const functionPropertiesZ = z.object({
  inputs: paramsZ.optional(),
  outputs: paramsZ.optional(),
  config: paramsZ.optional(),
});
export interface FunctionProperties extends z.infer<typeof functionPropertiesZ> {}

export const handleZ = z.object({
  node: z.string(),
  param: z.string(),
});
export interface Handle extends z.infer<typeof handleZ> {}

export const stageZ = z.object({
  key: z.string(),
  nodes: array.nullishToEmpty(z.string()),
  strata: strataZ,
});
export interface Stage extends z.infer<typeof stageZ> {}

export const bodyZ = z.object({
  raw: z.string(),
});
export interface Body extends z.infer<typeof bodyZ> {}

export const channelsZ = z.object({
  read: z.record(z.uint32(), z.string()),
  write: z.record(z.uint32(), z.string()),
});
export interface Channels extends z.infer<typeof channelsZ> {}

export const irZ = z.object({
  functions: functionsZ.optional(),
  nodes: nodesZ.optional(),
  edges: edgesZ.optional(),
  strata: strataZ.optional(),
  sequences: sequencesZ.optional(),
});
export interface IR extends z.infer<typeof irZ> {}

export const graphNodeZ = z.object({
  key: z.string(),
  type: z.string(),
  config: zod.stringifiedJSON(),
  position: spatial.xyZ,
});
export interface GraphNode extends z.infer<typeof graphNodeZ> {}

export const viewportZ = z.object({
  position: spatial.xyZ,
  zoom: z.number(),
});
export interface Viewport extends z.infer<typeof viewportZ> {}

export const textZ = z.object({
  raw: z.string(),
});
export interface Text extends z.infer<typeof textZ> {}

export const statusDetailsZ = z.object({
  running: z.boolean(),
});
export interface StatusDetails extends z.infer<typeof statusDetailsZ> {}

export const dimensionsZ = z.object({
  length: zod.int8Z,
  mass: zod.int8Z,
  time: zod.int8Z,
  current: zod.int8Z,
  temperature: zod.int8Z,
  angle: zod.int8Z,
  count: zod.int8Z,
  data: zod.int8Z,
});
export interface Dimensions extends z.infer<typeof dimensionsZ> {}

export const edgeZ = z.object({
  source: handleZ,
  target: handleZ,
  kind: edgeKindZ.optional(),
});
export interface Edge extends z.infer<typeof edgeZ> {}

export const sequenceZ = z.object({
  key: z.string(),
  stages: array.nullishToEmpty(stageZ),
});
export interface Sequence extends z.infer<typeof sequenceZ> {}

export const functionZ = z.object({
  key: z.string(),
  body: bodyZ.optional(),
  config: paramsZ.optional(),
  inputs: paramsZ.optional(),
  outputs: paramsZ.optional(),
  channels: channelsZ.optional(),
});
export interface Function extends z.infer<typeof functionZ> {}

export const nodeZ = z.object({
  key: z.string(),
  type: z.string(),
  config: paramsZ.optional(),
  inputs: paramsZ.optional(),
  outputs: paramsZ.optional(),
  channels: channelsZ.optional(),
});
export interface Node extends z.infer<typeof nodeZ> {}

export const moduleZ = z.object({
  ir: irZ,
  wasm: z.instanceof(Uint8Array),
  outputMemoryBases: z.record(z.string(), z.uint32()),
});
export interface Module extends z.infer<typeof moduleZ> {}

export const graphZ = z.object({
  viewport: viewportZ.optional(),
  functions: functionsZ.optional(),
  edges: edgesZ.optional(),
  nodes: graphNodesZ.optional(),
});
export interface Graph extends z.infer<typeof graphZ> {}

export const statusZ = status.goStatusZ(statusDetailsZ);
export type Status = z.infer<typeof statusZ>;

export const unitZ = z.object({
  dimensions: dimensionsZ,
  scale: z.number(),
  name: z.string(),
});
export interface Unit extends z.infer<typeof unitZ> {}

export const newZ = z.object({
  key: keyZ.optional(),
  name: z.string(),
  graph: graphZ,
  text: textZ,
  deploy: z.boolean(),
  version: z.string(),
});
export interface New extends z.input<typeof newZ> {}

export const arcZ = z.object({
  key: keyZ,
  name: z.string(),
  graph: graphZ,
  text: textZ,
  deploy: z.boolean(),
  version: z.string(),
  status: statusZ.optional(),
});
export interface Arc extends z.infer<typeof arcZ> {}

export const typeZ = functionPropertiesZ.extend({
  kind: kindZ,
  get elem() {
    return typeZ.optional();
  },
  name: z.string(),
  unit: unitZ.optional(),
  get constraint() {
    return typeZ.optional();
  },
});
export interface Type extends z.infer<typeof typeZ> {}

export const paramZ = z.object({
  name: z.string(),
  type: typeZ,
  value: z.unknown().optional(),
});
export interface Param extends z.infer<typeof paramZ> {}

export const ontologyID = ontology.createIDFactory<Key>("arc");
export const TYPE_ONTOLOGY_ID = ontologyID("");
