// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by Oracle. DO NOT EDIT.

import { array, spatial, status, zod } from "@synnaxlabs/x";
import { z } from "zod";

import { ontology } from "@/ontology";
export enum Kind {
  u8 = 1,
  u16 = 2,
  u32 = 3,
  u64 = 4,
  i8 = 5,
  i16 = 6,
  i32 = 7,
  i64 = 8,
  f32 = 9,
  f64 = 10,
  string = 11,
  timestamp = 12,
  timespan = 13,
  chan = 14,
  series = 15,
}
export const kindZ = z.enum(Kind);
export enum EdgeKind {
  continuous = 1,
  one_shot = 2,
}
export const edgeKindZ = z.enum(EdgeKind);

export const stageZ = z.object({
  key: z.string(),
  nodes: array.nullishToEmpty(z.string()),
});
export interface Stage extends z.infer<typeof stageZ> {}

export const channelsZ = z.object({
  read: z.record(z.uint32(), z.string()),
  write: z.record(z.uint32(), z.string()),
});
export interface Channels extends z.infer<typeof channelsZ> {}

export const stratumZ = z.object({
  nodes: array.nullishToEmpty(z.string()),
});
export interface Stratum extends z.infer<typeof stratumZ> {}

export const graphNodeZ = z.object({
  key: z.string(),
  type: z.string(),
  config: zod.stringifiedJSON(),
  position: spatial.xyZ,
});
export interface GraphNode extends z.infer<typeof graphNodeZ> {}

export const bodyZ = z.object({
  raw: z.string(),
});
export interface Body extends z.infer<typeof bodyZ> {}

export const statusDetailsZ = z.object({
  running: z.boolean(),
});
export interface StatusDetails extends z.infer<typeof statusDetailsZ> {}

export const keyZ = z.uuid();
export type Key = z.infer<typeof keyZ>;

export const typeZ = z.object({
  kind: kindZ,
  get elem() {
    return typeZ.optional();
  },
});
export interface Type extends z.infer<typeof typeZ> {}

export const handleZ = z.object({
  node: z.string(),
  param: z.string(),
});
export interface Handle extends z.infer<typeof handleZ> {}

export const viewportZ = z.object({
  position: spatial.xyZ,
  zoom: z.number(),
});
export interface Viewport extends z.infer<typeof viewportZ> {}

export const textZ = z.object({
  raw: z.string(),
});
export interface Text extends z.infer<typeof textZ> {}

export const sequenceZ = z.object({
  key: z.string(),
  stages: array.nullishToEmpty(stageZ),
});
export interface Sequence extends z.infer<typeof sequenceZ> {}

export const statusZ = status.statusZ({ details: statusDetailsZ });
export type Status = z.infer<typeof statusZ>;

export const paramZ = z.object({
  name: z.string(),
  type: typeZ,
  value: zod.stringifiedJSON().optional(),
});
export interface Param extends z.infer<typeof paramZ> {}

export const edgeZ = z.object({
  source: handleZ,
  target: handleZ,
  kind: edgeKindZ.optional(),
});
export interface Edge extends z.infer<typeof edgeZ> {}

export const functionZ = z.object({
  key: z.string(),
  body: bodyZ.optional(),
  config: array.nullToUndefined(paramZ),
  inputs: array.nullToUndefined(paramZ),
  outputs: array.nullToUndefined(paramZ),
  channels: channelsZ.optional(),
});
export interface Function extends z.infer<typeof functionZ> {}

export const nodeZ = z.object({
  key: z.string(),
  type: z.string(),
  config: array.nullToUndefined(paramZ),
  inputs: array.nullToUndefined(paramZ),
  outputs: array.nullToUndefined(paramZ),
  channels: channelsZ.optional(),
});
export interface Node extends z.infer<typeof nodeZ> {}

export const graphZ = z.object({
  viewport: viewportZ.optional(),
  functions: array.nullToUndefined(functionZ),
  edges: array.nullToUndefined(edgeZ),
  nodes: array.nullToUndefined(graphNodeZ),
});
export interface Graph extends z.infer<typeof graphZ> {}

export const irZ = z.object({
  functions: array.nullToUndefined(functionZ),
  nodes: array.nullToUndefined(nodeZ),
  edges: array.nullToUndefined(edgeZ),
  strata: array.nullToUndefined(stratumZ),
  sequences: array.nullToUndefined(sequenceZ),
});
export interface IR extends z.infer<typeof irZ> {}

export const arcZ = z.object({
  key: keyZ,
  name: z.string(),
  graph: graphZ,
  text: textZ,
  deploy: z.boolean(),
  version: z.string(),
  status: statusZ.optional(),
});
export interface Arc extends z.infer<typeof arcZ> {}

export const newZ = z.object({
  key: keyZ.optional(),
  name: z.string(),
  graph: graphZ,
  text: textZ,
  deploy: z.boolean(),
  version: z.string(),
});
export interface New extends z.input<typeof newZ> {}

export const moduleZ = z.object({
  ir: irZ,
  wasm: z.instanceof(Uint8Array),
  outputMemoryBases: z.record(z.string(), z.uint32()),
});
export interface Module extends z.infer<typeof moduleZ> {}

export const ontologyID = ontology.createIDFactory<Key>("arc");
export const TYPE_ONTOLOGY_ID = ontologyID("");
