// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by Oracle. DO NOT EDIT.

import { caseconv, optional, record, status, zod } from "@synnaxlabs/x";
import { z } from "zod";

import { ontology } from "@/ontology";

export const keyZ = z
  .string()
  .or(z.number().transform(String).or(z.bigint().transform(String)));
export type Key = z.infer<typeof keyZ>;

export type StatusDetailsZodObject<Data extends z.ZodType = z.ZodNever> = z.ZodObject<{
  task: typeof keyZ;
  running: z.ZodBoolean;
  cmd: z.ZodOptional<z.ZodString>;
  data: [Data] extends [z.ZodNever] ? z.ZodOptional<z.ZodUnknown> : Data;
}>;

export interface StatusDetailsZFunction {
  <Data extends z.ZodType>(data: Data): StatusDetailsZodObject<Data>;
  <Data extends z.ZodType = z.ZodNever>(data?: Data): StatusDetailsZodObject<Data>;
}

export const statusDetailsZ: StatusDetailsZFunction = <Data extends z.ZodType>(
  data?: Data,
) =>
  z.object({
    task: keyZ,
    running: z.boolean(),
    cmd: z.string().optional(),
    data: data ?? z.unknown().optional(),
  });
export type StatusDetails<Data extends z.ZodType = z.ZodNever> = {
  task: Key;
  running: boolean;
  cmd?: string;
} & ([Data] extends [z.ZodNever] ? {} : { data: z.infer<Data> });

export type NewStatusDetailsZodObject<Data extends z.ZodType = z.ZodNever> =
  z.ZodObject<{
    task: z.ZodOptional<typeof keyZ>;
    running: z.ZodBoolean;
    cmd: z.ZodOptional<z.ZodString>;
    data: [Data] extends [z.ZodNever] ? z.ZodOptional<z.ZodUnknown> : Data;
  }>;

export interface NewStatusDetailsZFunction {
  <Data extends z.ZodType>(data: Data): NewStatusDetailsZodObject<Data>;
  <Data extends z.ZodType = z.ZodNever>(data?: Data): NewStatusDetailsZodObject<Data>;
}

export const newStatusDetailsZ: NewStatusDetailsZFunction = <Data extends z.ZodType>(
  data?: Data,
) =>
  z.object({
    task: keyZ.optional(),
    running: z.boolean(),
    cmd: z.string().optional(),
    data: data ?? z.unknown().optional(),
  });
export type NewStatusDetails<Data extends z.ZodType = z.ZodNever> = {
  task?: Key;
  running: boolean;
  cmd?: string;
} & ([Data] extends [z.ZodNever] ? {} : { data: z.infer<Data> });

/** Command is a command to execute on a task in the Driver system. */
export const commandZ = z.object({
  /** task is the key of the target task. */
  task: keyZ,
  /** type is the command type (e.g., 'start', 'stop', 'configure'). */
  type: z.string(),
  /** key is a unique identifier for this command instance. */
  key: z.string(),
  /** args contains optional arguments for the command. */
  args: caseconv.preserveCase(zod.nullToUndefined(record.unknownZ())),
});
export interface Command extends z.infer<typeof commandZ> {}

export const statusZ = <Data extends z.ZodType = z.ZodNever>(data?: Data) =>
  status.statusZ({ details: statusDetailsZ(data) });
export type Status<Data extends z.ZodType = z.ZodNever> = z.infer<
  ReturnType<typeof statusZ<Data>>
>;

export const newStatusZ = <Data extends z.ZodType = z.ZodNever>(data?: Data) =>
  status.newZ({ details: newStatusDetailsZ(data) });
export type NewStatus<Data extends z.ZodType = z.ZodNever> = z.infer<
  ReturnType<typeof newStatusZ<Data>>
>;

export interface PayloadSchemas<
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType<record.Unknown> = z.ZodType<record.Unknown>,
  StatusData extends z.ZodType = z.ZodNever,
> {
  type?: Type;
  config?: Config;
  statusData?: StatusData;
}

export const payloadZ = <
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType<record.Unknown> = z.ZodType<record.Unknown>,
  StatusData extends z.ZodType = z.ZodNever,
>({ type, config, statusData }: PayloadSchemas<Type, Config, StatusData> = {}) =>
  z.object({
    key: keyZ,
    name: z.string(),
    type: type ?? z.string(),
    config: config ?? record.nullishToEmpty(),
    internal: z.boolean().optional(),
    snapshot: z.boolean().optional(),
    status: status.statusZ({ details: statusDetailsZ(statusData) }).optional(),
  });
export interface Payload<
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType<record.Unknown> = z.ZodType<record.Unknown>,
  StatusData extends z.ZodType = z.ZodNever,
> {
  key: Key;
  name: string;
  type: z.infer<Type>;
  config: z.infer<Config>;
  internal?: boolean;
  snapshot?: boolean;
  status?: Status<StatusData>;
}

export interface NewSchemas<
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType<record.Unknown> = z.ZodType<record.Unknown>,
  StatusData extends z.ZodType = z.ZodNever,
> {
  type?: Type;
  config?: Config;
  statusData?: StatusData;
}

export const newZ = <
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType<record.Unknown> = z.ZodType<record.Unknown>,
  StatusData extends z.ZodType = z.ZodNever,
>({ type, config, statusData }: NewSchemas<Type, Config, StatusData> = {}) =>
  payloadZ({ type, config, statusData })
    .omit({ internal: true, snapshot: true, status: true })
    .partial({ key: true })
    .extend({
      status: status.newZ({ details: newStatusDetailsZ(statusData) }).optional(),
    });
export type New<
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType<record.Unknown> = z.ZodType<record.Unknown>,
  StatusData extends z.ZodType = z.ZodNever,
> = optional.Optional<
  Omit<Payload<Type, Config, StatusData>, "internal" | "snapshot" | "status">,
  "key"
> & {
  status?: NewStatus<StatusData>;
};

export const ontologyID = ontology.createIDFactory<Key>("task");
export const TYPE_ONTOLOGY_ID = ontologyID("");
