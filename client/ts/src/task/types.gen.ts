// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by Oracle. DO NOT EDIT.

import { caseconv, type optional, record, status, zod } from "@synnaxlabs/x";
import { z } from "zod";

import { ontology } from "@/ontology";

export const keyZ = z
  .string()
  .or(z.number().transform(String).or(z.bigint().transform(String)));
export type Key = z.infer<typeof keyZ>;

export const statusDetailsZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  z.object({
    task: keyZ,
    running: z.boolean(),
    cmd: z.string().optional(),
    data: data ?? record.nullishToEmpty().optional(),
  });
export interface StatusDetails<Data extends z.ZodType = z.ZodType> {
  task: Key;
  running: boolean;
  cmd?: string;
  data?: z.infer<Data>;
}

export const newStatusDetailsZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  z.object({
    task: keyZ.optional(),
    running: z.boolean(),
    cmd: z.string().optional(),
    data: data ?? record.nullishToEmpty(),
  });
export type NewStatusDetails<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof newStatusDetailsZ<Data>>
>;

/** Command is a command to execute on a task in the Driver system. */
export const commandZ = z.object({
  /** task is the key of the target task. */
  task: keyZ,
  /** type is the command type (e.g., 'start', 'stop', 'configure'). */
  type: z.string(),
  /** key is a unique identifier for this command instance. */
  key: z.string(),
  /** args contains optional arguments for the command. */
  args: zod.nullToUndefined(record.unknownZ()),
});
export interface Command extends z.infer<typeof commandZ> {}

export const statusZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  status.statusZ({ details: statusDetailsZ(data) });
export type Status<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof statusZ<Data>>
>;

export const newStatusZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  status.newZ({ details: newStatusDetailsZ(data) });
export type NewStatus<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof newStatusZ<Data>>
>;

export interface PayloadSchemas<
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
> {
  type?: Type;
  config?: Config;
  statusData?: StatusData;
}

export const payloadZ = <
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
>({ type, config, statusData }: PayloadSchemas<Type, Config, StatusData> = {}) =>
  z.object({
    key: keyZ,
    name: z.string(),
    type: type ?? z.string(),
    config: caseconv.preserveCase(config ?? record.nullishToEmpty()),
    internal: z.boolean().optional(),
    snapshot: z.boolean().optional(),
    status: status.statusZ({ details: statusDetailsZ(statusData) }).optional(),
  });
export interface Payload<
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
> {
  key: Key;
  name: string;
  type: z.infer<Type>;
  config: z.infer<Config>;
  internal?: boolean;
  snapshot?: boolean;
  status?: Status<StatusData>;
}

export interface NewSchemas<
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
> {
  type?: Type;
  config?: Config;
  statusData?: StatusData;
}

export const newZ = <
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
>({ type, config, statusData }: NewSchemas<Type, Config, StatusData> = {}) =>
  payloadZ({ type, config, statusData })
    .omit({ internal: true, snapshot: true, status: true, config: true })
    .partial({ key: true })
    .extend({
      status: status.newZ({ details: newStatusDetailsZ(statusData) }).optional(),
      config: config ?? record.nullishToEmpty(),
    });
export type New<
  Type extends z.ZodType<string> = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
> = optional.Optional<
  Omit<
    Payload<Type, Config, StatusData>,
    "internal" | "snapshot" | "status" | "config"
  >,
  "key"
> & {
  status?: NewStatus<StatusData>;
  config: z.infer<Config>;
};

export const ontologyID = ontology.createIDFactory<Key>("task");
export const TYPE_ONTOLOGY_ID = ontologyID("");
