// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by Oracle. DO NOT EDIT.

import { type optional, status, zod } from "@synnaxlabs/x";
import { z } from "zod";

import { ontology } from "@/ontology";

export const keyZ = z.uint64();
export type Key = z.infer<typeof keyZ>;

export const newStatusDetailsZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  z.object({
    task: z.string().optional(),
    running: z.boolean(),
    cmd: z.string().optional(),
    data: zod.stringifiedJSON(data),
  });
export type NewStatusDetails<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof newStatusDetailsZ<Data>>
>;

export const commandZ = z.object({
  task: z.string(),
  type: z.string(),
  key: z.string(),
  args: zod.stringifiedJSON().optional(),
});
export interface Command extends z.infer<typeof commandZ> {}

export const statusDetailsZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  z.object({
    task: z.string().optional(),
    running: z.boolean().optional(),
    cmd: z.string().optional(),
    data: zod.stringifiedJSON(data).optional(),
  });
export type StatusDetails<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof statusDetailsZ<Data>>
>;

export const newStatusZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  status.newZ({ details: newStatusDetailsZ(data) });
export type NewStatus<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof newStatusZ<Data>>
>;

export const statusZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  status.statusZ({ details: statusDetailsZ(data) });
export type Status<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof statusZ<Data>>
>;

export interface PayloadSchemas<
  Type extends z.ZodType = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
> {
  type?: Type;
  config?: Config;
  statusData?: StatusData;
}

export const payloadZ = <
  Type extends z.ZodType = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
>({ type, config, statusData }: PayloadSchemas<Type, Config, StatusData> = {}) =>
  z.object({
    key: z.string(),
    name: z.string(),
    type: type ?? z.string(),
    config: zod.stringifiedJSON(config),
    internal: z.boolean().optional(),
    snapshot: z.boolean().optional(),
    status: status.statusZ({ details: statusDetailsZ(statusData) }).optional(),
  });
export interface Payload<
  Type extends z.ZodType = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
> {
  key: string;
  name: string;
  type: z.infer<Type>;
  config: z.infer<Config>;
  internal?: boolean;
  snapshot?: boolean;
  status?: Status<StatusData>;
}

export interface NewSchemas<
  Type extends z.ZodType = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
> {
  type?: Type;
  config?: Config;
  statusData?: StatusData;
}

export const newZ = <
  Type extends z.ZodType = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
>({ type, config, statusData }: NewSchemas<Type, Config, StatusData> = {}) =>
  payloadZ({ type, config, statusData })
    .omit({ internal: true, snapshot: true })
    .partial({ key: true })
    .extend({
      status: status.newZ({ details: newStatusDetailsZ(statusData) }).optional(),
    });
export type New<
  Type extends z.ZodType = z.ZodString,
  Config extends z.ZodType = z.ZodType,
  StatusData extends z.ZodType = z.ZodType,
> = optional.Optional<
  Omit<Payload<Type, Config, StatusData>, "internal" | "snapshot">,
  "key"
> & {
  status?: NewStatus<StatusData>;
};

export const ontologyID = ontology.createIDFactory<Key>("task");
export const TYPE_ONTOLOGY_ID = ontologyID("");
