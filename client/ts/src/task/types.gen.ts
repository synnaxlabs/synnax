// Code generated by Oracle. DO NOT EDIT.

import { status, zod } from "@synnaxlabs/x";
import { z } from "zod";

import { ontology } from "@/ontology";

export const keyZ = z.string();
export type Key = z.infer<typeof keyZ>;

export const statusDetailsZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  z.object({
    task: z.string(),
    running: z.boolean(),
    cmd: z.string().optional(),
    data: zod.stringifiedJSON(data),
  });
export type StatusDetails<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof statusDetailsZ<Data>>
>;

export const statusZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  status.statusZ(statusDetailsZ(data));
export type Status<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof statusZ<Data>>
>;

export const newStatusDetailsZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  z.object({
    task: z.string().optional(),
    running: z.boolean(),
    cmd: z.string().optional(),
    data: zod.stringifiedJSON(data),
  });
export type NewStatusDetails<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof newStatusDetailsZ<Data>>
>;

export const newStatusZ = <Data extends z.ZodType = z.ZodType>(data?: Data) =>
  status.newZ(newStatusDetailsZ(data));
export type NewStatus<Data extends z.ZodType = z.ZodType> = z.infer<
  ReturnType<typeof newStatusZ<Data>>
>;

export interface PayloadSchemas<Type extends z.ZodType = z.ZodString, Config extends z.ZodType = z.ZodType, StatusData extends z.ZodType = z.ZodType> {
  type?: Type;
  config?: Config;
  statusData?: StatusData;
}

export const payloadZ = <Type extends z.ZodType = z.ZodString, Config extends z.ZodType = z.ZodType, StatusData extends z.ZodType = z.ZodType>({
  type,
  config,
  statusData,
}: PayloadSchemas<Type, Config, StatusData> = {}) =>
  z.object({
    key: keyZ,
    name: z.string(),
    type: type ?? z.string(),
    config: zod.stringifiedJSON(config),
    internal: z.boolean().optional(),
    snapshot: z.boolean().optional(),
    status: statusZ(statusData).nullish(),
  });
export type Payload<Type extends z.ZodType = z.ZodString, Config extends z.ZodType = z.ZodType, StatusData extends z.ZodType = z.ZodType> = {
  key: Key;
  name: string;
  type: z.infer<Type>;
  config: z.infer<Config>;
  internal?: boolean;
  snapshot?: boolean;
  status?: Status<StatusData> | null;
};

export interface NewSchemas<Type extends z.ZodType = z.ZodString, Config extends z.ZodType = z.ZodType, StatusData extends z.ZodType = z.ZodType> {
  type?: Type;
  config?: Config;
  statusData?: StatusData;
}

export const newZ = <Type extends z.ZodType = z.ZodString, Config extends z.ZodType = z.ZodType, StatusData extends z.ZodType = z.ZodType>({
  type,
  config,
  statusData,
}: NewSchemas<Type, Config, StatusData> = {}) =>
  z.object({
    key: keyZ.optional(),
    name: z.string(),
    type: type ?? z.string(),
    config: zod.jsonStringifier(config),
    status: newStatusZ(statusData).nullish(),
  });
export type New<Type extends z.ZodType = z.ZodString, Config extends z.ZodType = z.ZodType, StatusData extends z.ZodType = z.ZodType> = {
  key?: Key;
  name: string;
  type: z.infer<Type>;
  config: z.infer<Config>;
  status?: NewStatus<StatusData> | null;
};

export const commandZ = z.object({
  task: z.string(),
  type: z.string(),
  key: keyZ,
  args: zod.stringifiedJSON().optional(),
});
export type Command = z.infer<typeof commandZ>;

export const ontologyID = ontology.createIDFactory<Key>("task");
export const TYPE_ONTOLOGY_ID = ontologyID("");
