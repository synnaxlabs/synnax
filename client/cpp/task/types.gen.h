// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <utility>

#include "nlohmann/json.hpp"

#include "x/cpp/status/types.gen.h"
#include "x/cpp/xerrors/errors.h"
#include "x/cpp/xjson/xjson.h"

namespace service::task {
class StatusDetails;
class Command;
class Task;
}

namespace synnax::task {
using Key = std::uint64_t;

struct StatusDetails {
    Key task;
    bool running;
    std::string cmd;
    std::optional<nlohmann::json> data;

    static StatusDetails parse(xjson::Parser parser) {
        return StatusDetails{
            .task = parser.field<Key>("task", {}),
            .running = parser.field<bool>("running", false),
            .cmd = parser.field<std::string>("cmd", ""),
            .data = parser.has("data")
                      ? std::make_optional(parser.field<nlohmann::json>("data"))
                      : std::nullopt,
        };
    }

    [[nodiscard]] json to_json() const {
        json j;
        j["task"] = this->task;
        j["running"] = this->running;
        j["cmd"] = this->cmd;
        if (this->data.has_value()) j["data"] = *this->data;
        return j;
    }

    using proto_type = service::task::StatusDetails;
    [[nodiscard]] service::task::StatusDetails to_proto() const;
    static std::pair<StatusDetails, xerrors::Error>
    from_proto(const service::task::StatusDetails &pb);
};

struct Command {
    Key task;
    std::string type;
    std::string key;
    nlohmann::json args;

    static Command parse(xjson::Parser parser) {
        return Command{
            .task = parser.field<Key>("task"),
            .type = parser.field<std::string>("type"),
            .key = parser.field<std::string>("key"),
            .args = parser.field<nlohmann::json>("args", nlohmann::json{}),
        };
    }

    [[nodiscard]] json to_json() const {
        json j;
        j["task"] = this->task;
        j["type"] = this->type;
        j["key"] = this->key;
        j["args"] = this->args;
        return j;
    }

    using proto_type = service::task::Command;
    [[nodiscard]] service::task::Command to_proto() const;
    static std::pair<Command, xerrors::Error>
    from_proto(const service::task::Command &pb);
};

using Status = synnax::status::Status<StatusDetails>;

struct Payload {
    Key key;
    std::string name;
    std::string type;
    bool internal;
    bool snapshot;
    std::string config;
    std::optional<Status> status;

    static Payload parse(xjson::Parser parser) {
        return Payload{
            .key = parser.field<Key>("key"),
            .name = parser.field<std::string>("name"),
            .type = parser.field<std::string>("type"),
            .internal = parser.field<bool>("internal", false),
            .snapshot = parser.field<bool>("snapshot", false),
            .config = parser.field<std::string>("config"),
            .status = parser.has("status")
                        ? std::make_optional(Status::parse(parser.child("status")))
                        : std::nullopt,
        };
    }

    [[nodiscard]] json to_json() const {
        json j;
        j["key"] = this->key;
        j["name"] = this->name;
        j["type"] = this->type;
        j["internal"] = this->internal;
        j["snapshot"] = this->snapshot;
        j["config"] = this->config;
        if (this->status.has_value()) j["status"] = this->status->to_json();
        return j;
    }

    using proto_type = service::task::Task;
    [[nodiscard]] service::task::Task to_proto() const;
    static std::pair<Payload, xerrors::Error> from_proto(const service::task::Task &pb);
};
}
template<typename Details>
struct Status {
