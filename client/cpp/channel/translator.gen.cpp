// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#include "client/cpp/channel/translator.gen.h"

#include "core/pkg/api/grpc/v1/channel.pb.h"

namespace synnax::channel::pb {

api::v1::OperationType OperationTypeToPB(const std::string &cpp) {
    if (cpp == OperationTypeMin) return api::v1::OperationType_MIN;
    if (cpp == OperationTypeMax) return api::v1::OperationType_MAX;
    if (cpp == OperationTypeAvg) return api::v1::OperationType_AVG;
    if (cpp == OperationTypeNone) return api::v1::OperationType_NONE;
    return api::v1::OperationType_UNSPECIFIED;
}

std::string OperationTypeFromPB(api::v1::OperationType pb) {
    switch (pb) {
        case api::v1::OperationType_MIN:
            return OperationTypeMin;
        case api::v1::OperationType_MAX:
            return OperationTypeMax;
        case api::v1::OperationType_AVG:
            return OperationTypeAvg;
        case api::v1::OperationType_NONE:
            return OperationTypeNone;
        default:
            return OperationTypeMin;
    }
}

api::v1::Operation to_pb(const Operation &cpp) {
    api::v1::Operation pb;
    pb.set_type(OperationTypeToPB(cpp.type));
    pb.set_reset_channel(static_cast<uint32_t>(cpp.reset_channel));
    pb.set_duration(static_cast<std::int64_t>(cpp.duration));
    return pb;
}

Operation from_pb(const api::v1::Operation &pb) {
    Operation cpp;
    cpp.type = OperationTypeFromPB(pb.type());
    cpp.reset_channel = ChannelKey(pb.reset_channel());
    cpp.duration = telem::TimeSpan(pb.duration());
    return cpp;
}

std::vector<api::v1::Operation> to_pb(const std::vector<Operation> &cpp) {
    std::vector<api::v1::Operation> pb;
    pb.reserve(cpp.size());
    for (const auto &item: cpp)
        pb.push_back(to_pb(item));
    return pb;
}

std::vector<Operation> from_pb(const std::vector<api::v1::Operation> &pb) {
    std::vector<Operation> cpp;
    cpp.reserve(pb.size());
    for (const auto &item: pb)
        cpp.push_back(from_pb(item));
    return cpp;
}

}
