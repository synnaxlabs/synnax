// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#include "client/cpp/channel/translator.gen.h"

#include "core/pkg/distribution/channel/pb/channel.pb.h"

namespace synnax::channel {

distribution::channel::OperationType OperationTypeToPB(const std::string &cpp) {
    if (cpp == operation_type_min) return distribution::channel::OPERATION_TYPE_MIN;
    if (cpp == operation_type_max) return distribution::channel::OPERATION_TYPE_MAX;
    if (cpp == operation_type_avg) return distribution::channel::OPERATION_TYPE_AVG;
    if (cpp == operation_type_none) return distribution::channel::OPERATION_TYPE_NONE;
    return distribution::channel::OPERATION_TYPE_UNSPECIFIED;
}

std::string OperationTypeFromPB(distribution::channel::OperationType pb) {
    switch (pb) {
        case distribution::channel::OPERATION_TYPE_MIN:
            return operation_type_min;
        case distribution::channel::OPERATION_TYPE_MAX:
            return operation_type_max;
        case distribution::channel::OPERATION_TYPE_AVG:
            return operation_type_avg;
        case distribution::channel::OPERATION_TYPE_NONE:
            return operation_type_none;
        default:
            return operation_type_min;
    }
}

distribution::channel::Operation to_pb(const Operation &cpp) {
    distribution::channel::Operation pb;
    pb.set_type(OperationTypeToPB(cpp.type));
    pb.set_reset_channel(static_cast<uint32_t>(cpp.reset_channel));
    pb.set_duration(cpp.duration.nanoseconds());
    return pb;
}

Operation from_pb(const distribution::channel::Operation &pb) {
    Operation cpp;
    cpp.type = OperationTypeFromPB(pb.type());
    cpp.reset_channel = ChannelKey(pb.reset_channel());
    cpp.duration = x::telem::TimeSpan(pb.duration());
    return cpp;
}

std::vector<distribution::channel::Operation> to_pb(const std::vector<Operation> &cpp) {
    std::vector<distribution::channel::Operation> pb;
    pb.reserve(cpp.size());
    for (const auto &item: cpp)
        pb.push_back(to_pb(item));
    return pb;
}

std::vector<Operation>
from_pb(const std::vector<distribution::channel::Operation> &pb) {
    std::vector<Operation> cpp;
    cpp.reserve(pb.size());
    for (const auto &item: pb)
        cpp.push_back(from_pb(item));
    return cpp;
}

}
