// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <string>
#include <unordered_map>
#include <utility>

#include "client/cpp/channel/json.gen.h"
#include "client/cpp/channel/types.gen.h"
#include "x/cpp/errors/errors.h"
#include "x/cpp/pb/pb.h"
#include "x/cpp/status/json.gen.h"
#include "x/cpp/status/proto.gen.h"

#include "core/pkg/api/channel/pb/channel.pb.h"
#include "core/pkg/distribution/channel/pb/channel.pb.h"

namespace synnax::channel {

inline ::distribution::channel::pb::OperationType
OperationTypeToPB(const std::string &cpp) {
    static const std::
        unordered_map<std::string, ::distribution::channel::pb::OperationType>
            kMap = {
                {OPERATION_TYPE_MIN, ::distribution::channel::pb::OPERATION_TYPE_MIN},
                {OPERATION_TYPE_MAX, ::distribution::channel::pb::OPERATION_TYPE_MAX},
                {OPERATION_TYPE_AVG, ::distribution::channel::pb::OPERATION_TYPE_AVG},
                {OPERATION_TYPE_NONE, ::distribution::channel::pb::OPERATION_TYPE_NONE},
            };
    auto it = kMap.find(cpp);
    return it != kMap.end() ? it->second
                            : ::distribution::channel::pb::OPERATION_TYPE_MIN;
}

inline std::string OperationTypeFromPB(::distribution::channel::pb::OperationType pb) {
    switch (pb) {
        case ::distribution::channel::pb::OPERATION_TYPE_MIN:
            return OPERATION_TYPE_MIN;
        case ::distribution::channel::pb::OPERATION_TYPE_MAX:
            return OPERATION_TYPE_MAX;
        case ::distribution::channel::pb::OPERATION_TYPE_AVG:
            return OPERATION_TYPE_AVG;
        case ::distribution::channel::pb::OPERATION_TYPE_NONE:
            return OPERATION_TYPE_NONE;
        default:
            return OPERATION_TYPE_MIN;
    }
}

inline ::distribution::channel::pb::Operation Operation::to_proto() const {
    ::distribution::channel::pb::Operation pb;
    pb.set_type(OperationTypeToPB(this->type));
    pb.set_reset_channel(static_cast<uint32_t>(this->reset_channel));
    pb.set_duration(this->duration.to_proto());
    return pb;
}

inline std::pair<Operation, x::errors::Error>
Operation::from_proto(const ::distribution::channel::pb::Operation &pb) {
    Operation cpp;
    cpp.type = OperationTypeFromPB(pb.type());
    cpp.reset_channel = Key(pb.reset_channel());
    cpp.duration = ::x::telem::TimeSpan::from_proto(pb.duration());
    return {cpp, x::errors::NIL};
}

inline ::api::channel::pb::Channel Channel::to_proto() const {
    ::api::channel::pb::Channel pb;
    pb.set_key(static_cast<uint32_t>(this->key));
    pb.set_name(this->name);
    pb.set_leaseholder(static_cast<uint32_t>(this->leaseholder));
    pb.set_data_type(this->data_type.to_proto());
    pb.set_is_index(this->is_index);
    pb.set_index(static_cast<uint32_t>(this->index));
    pb.set_alias(this->alias);
    pb.set_virtual_(this->is_virtual);
    pb.set_internal(this->internal);
    pb.set_expression(this->expression);
    for (const auto &item: this->operations)
        *pb.add_operations() = item.to_proto();
    pb.set_concurrency(static_cast<::x::control::pb::Concurrency>(this->concurrency));
    if (this->status.has_value()) *pb.mutable_status() = this->status->to_proto();
    return pb;
}

inline std::pair<Channel, x::errors::Error>
Channel::from_proto(const ::api::channel::pb::Channel &pb) {
    Channel cpp;
    cpp.key = Key(pb.key());
    cpp.name = pb.name();
    cpp.leaseholder = ::synnax::cluster::NodeKey(pb.leaseholder());
    cpp.data_type = ::x::telem::DataType::from_proto(pb.data_type());
    cpp.is_index = pb.is_index();
    cpp.index = Key(pb.index());
    cpp.alias = pb.alias();
    cpp.is_virtual = pb.virtual_();
    cpp.internal = pb.internal();
    cpp.expression = pb.expression();
    if (auto err = x::pb::from_proto_repeated<Operation>(
            cpp.operations,
            pb.operations()
        ))
        return {{}, err};
    cpp.concurrency = static_cast<::x::control::Concurrency>(pb.concurrency());
    if (pb.has_status()) {
        auto [v, err] = Status::from_proto(pb.status());
        if (err) return {{}, err};
        cpp.status = v;
    }
    return {cpp, x::errors::NIL};
}

}
