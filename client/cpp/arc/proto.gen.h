// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <string>
#include <unordered_map>
#include <utility>

#include "client/cpp/arc/json.gen.h"
#include "client/cpp/arc/types.gen.h"
#include "x/cpp/errors/errors.h"
#include "x/cpp/pb/pb.h"
#include "x/cpp/status/json.gen.h"
#include "x/cpp/status/proto.gen.h"

#include "arc/cpp/graph/json.gen.h"
#include "arc/cpp/graph/proto.gen.h"
#include "arc/cpp/module/json.gen.h"
#include "arc/cpp/module/proto.gen.h"
#include "arc/cpp/text/json.gen.h"
#include "arc/cpp/text/proto.gen.h"
#include "core/pkg/service/arc/pb/arc.pb.h"

namespace synnax::arc {

inline ::service::arc::pb::Mode ModeToPB(const std::string &cpp) {
    static const std::unordered_map<std::string, ::service::arc::pb::Mode> kMap = {
        {MODE_TEXT, ::service::arc::pb::MODE_TEXT},
        {MODE_GRAPH, ::service::arc::pb::MODE_GRAPH},
    };
    auto it = kMap.find(cpp);
    return it != kMap.end() ? it->second : ::service::arc::pb::MODE_TEXT;
}

inline std::string ModeFromPB(::service::arc::pb::Mode pb) {
    switch (pb) {
        case ::service::arc::pb::MODE_TEXT:
            return MODE_TEXT;
        case ::service::arc::pb::MODE_GRAPH:
            return MODE_GRAPH;
        default:
            return MODE_TEXT;
    }
}

inline ::service::arc::pb::StatusDetails StatusDetails::to_proto() const {
    ::service::arc::pb::StatusDetails pb;
    pb.set_running(this->running);
    return pb;
}

inline std::pair<StatusDetails, x::errors::Error>
StatusDetails::from_proto(const ::service::arc::pb::StatusDetails &pb) {
    StatusDetails cpp;
    cpp.running = pb.running();
    return {cpp, x::errors::NIL};
}

inline ::service::arc::pb::Arc Arc::to_proto() const {
    ::service::arc::pb::Arc pb;
    pb.set_key(this->key.to_string());
    pb.set_name(this->name);
    pb.set_mode(ModeToPB(this->mode));
    *pb.mutable_graph() = this->graph.to_proto();
    *pb.mutable_text() = this->text.to_proto();
    if (this->module.has_value()) *pb.mutable_module() = this->module->to_proto();
    if (this->status.has_value()) *pb.mutable_status() = this->status->to_proto();
    return pb;
}

inline std::pair<Arc, x::errors::Error>
Arc::from_proto(const ::service::arc::pb::Arc &pb) {
    Arc cpp;
    {
        auto [v, err] = x::uuid::UUID::parse(pb.key());
        if (err) return {{}, err};
        cpp.key = v;
    }
    cpp.name = pb.name();
    cpp.mode = ModeFromPB(pb.mode());
    {
        auto [v, err] = ::arc::graph::Graph::from_proto(pb.graph());
        if (err) return {{}, err};
        cpp.graph = v;
    }
    {
        auto [v, err] = ::arc::text::Text::from_proto(pb.text());
        if (err) return {{}, err};
        cpp.text = v;
    }
    if (pb.has_module()) {
        auto [v, err] = ::arc::module::Module::from_proto(pb.module());
        if (err) return {{}, err};
        cpp.module = v;
    }
    if (pb.has_status()) {
        auto [v, err] = Status::from_proto(pb.status());
        if (err) return {{}, err};
        cpp.status = v;
    }
    return {cpp, x::errors::NIL};
}

}
