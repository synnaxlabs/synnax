// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <type_traits>
#include <utility>

#include "client/cpp/ranger/types.gen.h"
#include "x/cpp/errors/errors.h"
#include "x/cpp/label/proto.gen.h"
#include "x/cpp/telem/proto.gen.h"

#include "core/pkg/api/ranger/pb/ranger.pb.h"
#include "core/pkg/service/ranger/pb/ranger.pb.h"

namespace synnax::ranger {

inline ::service::ranger::pb::Range Base::to_proto() const {
    ::service::ranger::pb::Range pb;
    pb.set_key(this->key);
    pb.set_name(this->name);
    *pb.mutable_time_range() = this->time_range.to_proto();
    pb.set_color(this->color);
    return pb;
}

inline std::pair<Base, x::errors::Error>
Base::from_proto(const ::service::ranger::pb::Range &pb) {
    Base cpp;
    cpp.key = pb.key();
    cpp.name = pb.name();
    {
        auto [val, err] = ::x::telem::TimeRange::from_proto(pb.time_range());
        if (err) return {{}, err};
        cpp.time_range = val;
    }
    cpp.color = pb.color();
    return {cpp, x::errors::NIL};
}

inline ::api::ranger::pb::Range Range::to_proto() const {
    ::api::ranger::pb::Range pb;
    pb.set_key(this->key);
    pb.set_name(this->name);
    *pb.mutable_time_range() = this->time_range.to_proto();
    pb.set_color(this->color);
    for (const auto &item: this->labels)
        *pb.add_labels() = item.to_proto();
    if (this->parent.has_value()) *pb.mutable_parent() = this->parent->to_proto();
    return pb;
}

inline std::pair<Range, x::errors::Error>
Range::from_proto(const ::api::ranger::pb::Range &pb) {
    Range cpp;
    cpp.key = pb.key();
    cpp.name = pb.name();
    {
        auto [val, err] = ::x::telem::TimeRange::from_proto(pb.time_range());
        if (err) return {{}, err};
        cpp.time_range = val;
    }
    cpp.color = pb.color();
    for (const auto &item: pb.labels()) {
        auto [v, err] = ::x::label::Label::from_proto(item);
        if (err) return {{}, err};
        cpp.labels.push_back(v);
    }
    if (pb.has_parent()) {
        auto [val, err] = Range::from_proto(pb.parent());
        if (err) return {{}, err};
        cpp.parent = val;
    }
    return {cpp, x::errors::NIL};
}

}
