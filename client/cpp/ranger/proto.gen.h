// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <utility>

#include "client/cpp/ranger/json.gen.h"
#include "client/cpp/ranger/types.gen.h"
#include "x/cpp/color/json.gen.h"
#include "x/cpp/color/proto.gen.h"
#include "x/cpp/errors/errors.h"
#include "x/cpp/label/json.gen.h"
#include "x/cpp/label/proto.gen.h"
#include "x/cpp/pb/pb.h"
#include "x/cpp/telem/json.gen.h"
#include "x/cpp/telem/proto.gen.h"

#include "core/pkg/api/ranger/pb/ranger.pb.h"
#include "core/pkg/service/ranger/pb/ranger.pb.h"

namespace synnax::ranger {

inline ::service::ranger::pb::Range Base::to_proto() const {
    ::service::ranger::pb::Range pb;
    pb.set_key(this->key.to_string());
    pb.set_name(this->name);
    *pb.mutable_time_range() = this->time_range.to_proto();
    *pb.mutable_color() = this->color.to_proto();
    return pb;
}

inline std::pair<Base, x::errors::Error>
Base::from_proto(const ::service::ranger::pb::Range &pb) {
    Base cpp;
    {
        auto [v, err] = x::uuid::UUID::parse(pb.key());
        if (err) return {{}, err};
        cpp.key = v;
    }
    cpp.name = pb.name();
    {
        auto [v, err] = ::x::telem::TimeRange::from_proto(pb.time_range());
        if (err) return {{}, err};
        cpp.time_range = v;
    }
    {
        auto [v, err] = ::x::color::Color::from_proto(pb.color());
        if (err) return {{}, err};
        cpp.color = v;
    }
    return {cpp, x::errors::NIL};
}

inline ::api::ranger::pb::Range Range::to_proto() const {
    ::api::ranger::pb::Range pb;
    pb.set_key(this->key.to_string());
    pb.set_name(this->name);
    *pb.mutable_time_range() = this->time_range.to_proto();
    *pb.mutable_color() = this->color.to_proto();
    for (const auto &item: this->labels)
        *pb.add_labels() = item.to_proto();
    if (this->parent.has_value()) *pb.mutable_parent() = this->parent->to_proto();
    return pb;
}

inline std::pair<Range, x::errors::Error>
Range::from_proto(const ::api::ranger::pb::Range &pb) {
    Range cpp;
    {
        auto [v, err] = x::uuid::UUID::parse(pb.key());
        if (err) return {{}, err};
        cpp.key = v;
    }
    cpp.name = pb.name();
    {
        auto [v, err] = ::x::telem::TimeRange::from_proto(pb.time_range());
        if (err) return {{}, err};
        cpp.time_range = v;
    }
    {
        auto [v, err] = ::x::color::Color::from_proto(pb.color());
        if (err) return {{}, err};
        cpp.color = v;
    }
    if (auto err = x::pb::from_proto_repeated<::x::label::Label>(
            cpp.labels,
            pb.labels()
        ))
        return {{}, err};
    if (pb.has_parent()) {
        auto [v, err] = Range::from_proto(pb.parent());
        if (err) return {{}, err};
        cpp.parent = v;
    }
    return {cpp, x::errors::NIL};
}

}
