#  Copyright 2025 Synnax Labs, Inc.
#
#  Use of this software is governed by the Business Source License included in the file
#  licenses/BSL.txt.
#
#  As of the Change Date specified in that file, in accordance with the Business Source
#  License, use of this software will be governed by the Apache License, Version 2.0,
#  included in the file licenses/APL.txt.

import json
from typing import Literal
from uuid import uuid4

from pydantic import BaseModel, Field, field_validator

from synnax.channel import ChannelKey
from synnax.hardware.task import JSONConfigMixin, MetaTask, StarterStopperMixin, Task
from synnax.telem import CrudeRate, Rate


class ReadChannel(BaseModel):
    """
    Configuration for a channel in an OPC UA read task. A list of these objects should
    be passed to the `channels` field of the `ReadConfig` constructor.
    """

    enabled: bool = True
    "Whether acquisition for this channel is enabled."
    key: str = ""
    "A unique key to identify this channel."
    channel: ChannelKey = 0
    "The Synnax channel key that will be written to during acquisition."
    node_id: str = ""
    "The OPC UA node ID to read from."
    node_name: str = ""
    "The name of the OPC UA node to read from."
    data_type: str = "float32"
    "The OPC UA data type of the channel."
    use_as_index: bool = False
    """
    Whether to use the values of this channel to store index timestamps. If no channels
    are marked as index channels within the task, timestamps will be automatically
    generated by the Synnax OPC UA driver and written to the correct index channels.
    """

    def __init__(self, **data):
        if "key" not in data:
            data["key"] = str(uuid4())
        super().__init__(**data)


# Backward compatibility alias - DEPRECATED
# Use ReadChannel instead. Channel will be removed in a future version.
def Channel(*args, **kwargs):
    warnings.warn(
        "opcua.Channel is deprecated and will be removed in a future version. "
        "Use opcua.ReadChannel instead.",
        DeprecationWarning,
        stacklevel=2
    )
    return ReadChannel(*args, **kwargs)


class WriteChannel(BaseModel):
    """
    Configuration for a channel in an OPC UA write task. A list of these objects should
    be passed to the `channels` field of the `WriteTaskConfig` constructor.

    :param enabled: Whether output for this channel is enabled. Defaults to True.
    :param key: A unique key to identify this channel. Auto-generated if not provided.
    :param cmd_channel: The Synnax channel key to read command values from. This is the
        channel that will be monitored for commands to send to the OPC UA server.
    :param node_id: The OPC UA node ID to write to. Format: "NS=<namespace>;I=<id>" or
        similar OPC UA node ID format.
    """

    enabled: bool = True
    "Whether output for this channel is enabled."
    key: str = ""
    "A unique key to identify this channel."
    cmd_channel: ChannelKey = 0
    "The Synnax channel key to read command values from."
    node_id: str = ""
    "The OPC UA node ID to write to."

    def __init__(self, **data):
        if "key" not in data:
            data["key"] = str(uuid4())
        super().__init__(**data)


class BaseReadTaskConfig(BaseModel):
    device: str = Field(min_length=1)
    "The key of the Synnax OPC UA device to read from."
    sample_rate: float = Field(gt=0, le=10000)
    "The rate at which to sample data from the OPC UA device."
    data_saving: bool
    "Whether to save data permanently within Synnax, or just stream it for real-time consumption."
    auto_start: bool = False
    "Whether to start the task automatically when it is created."
    channels: list[ReadChannel]


class NonArraySamplingReadTaskConfig(BaseReadTaskConfig):
    stream_rate: Rate = Field(gt=0, le=10000)
    array_mode: Literal[False]


class ArraySamplingReadTaskConfig(BaseReadTaskConfig):
    array_mode: Literal[True]
    array_size: int = Field(gt=0)


class WrappedReadTaskConfig(BaseModel):
    config: NonArraySamplingReadTaskConfig | ArraySamplingReadTaskConfig = Field(
        discriminator="array_mode"
    )


class ReadTask(StarterStopperMixin, JSONConfigMixin, MetaTask):
    """A read task for sampling data from OPC UA devices and writing the data to a
    Synnax cluster. This task is a programmatic representation of the OPC UA read
    task configurable within the Synnax console. For detailed information on configuring/
    operating an OPC UA read task, see https://docs.synnaxlabs.com/reference/driver/opc-ua/read-task


    :param device: The key of the Synnax OPC UA device to read from.
    :param name: A human-readable name for the task.
    :param sample_rate: The rate at which to sample data from the OPC UA device.
    :param stream_rate: The rate at which acquired data will be streamed to the Synnax
        cluster. For example, a sample rate of 100Hz and a stream rate of 25Hz will
        result in groups of 4 samples being streamed to the cluster every 40ms.
        This parameter is only relevant when array_mode is False.
    :param data_saving: Whether to save data permanently within Synnax, or just stream
        it for real-time consumption.
    :param auto_start: Whether to start the task automatically when it is created.
    :param array_mode: Whether to sample data in array mode. In array mode, the task
        will read array nodes from the OPC UA device with a consistent size (specified in
        array_size) and write the entire array to the Synnax cluster. This mode is
        far more efficient for collecting data at very high rates, but requires more
        careful setup. For more information,
        see https://docs.synnaxlabs.com/reference/driver/opc-ua/read-task#default-sampling-vs-array-sampling.
    :param: array_size: The size of the array to read from the OPC UA device. This
        field is only relevant if array_mode is set to True.
    :param: channels: A list of Channel objects that specify which OPC UA nodes to read
        from and how to write the data to the Synnax cluster.
    """

    TYPE = "opc_read"
    _internal: Task

    def __init__(
        self,
        internal: Task | None = None,
        *,
        device: str = "",
        name: str = "",
        sample_rate: CrudeRate = 1000,
        stream_rate: CrudeRate = 1000,
        data_saving: bool = False,
        auto_start: bool = False,
        array_mode: bool = False,
        array_size: int = 1,
        channels: list[Channel] = None,
    ):
        if internal is not None:
            self._internal = internal
            self.config = WrappedReadTaskConfig.model_validate(
                {"config": json.loads(internal.config)}
            ).config
            return
        self._internal = Task(name=name, type=self.TYPE)
        if array_mode:
            self.config = ArraySamplingReadTaskConfig(
                device=device,
                sample_rate=sample_rate,
                data_saving=data_saving,
                auto_start=auto_start,
                array_mode=array_mode,
                array_size=array_size,
                channels=channels if channels is not None else [],
            )
        else:
            self.config = NonArraySamplingReadTaskConfig(
                device=device,
                sample_rate=sample_rate,
                stream_rate=stream_rate,
                data_saving=data_saving,
                auto_start=auto_start,
                array_mode=array_mode,
                channels=channels if channels is not None else [],
            )

    def _update_device_properties(self, device_client):
        """Internal: Update device properties before task configuration."""
        import json

        dev = device_client.retrieve(key=self.config.device)
        props = json.loads(dev.properties) if isinstance(dev.properties, str) else dev.properties

        if "read" not in props:
            props["read"] = {"index": 0, "channels": {}}

        # Map node_id -> channel key for Console
        for ch in self.config.channels:
            if ch.node_id:
                props["read"]["channels"][ch.node_id] = ch.channel

        dev.properties = json.dumps(props)
        device_client.create(dev)


class WriteTaskConfig(BaseModel):
    """
    Configuration for an OPC UA write task.
    """

    device: str = Field(min_length=1)
    "The key of the Synnax OPC UA device to write to."
    data_saving: bool
    "Whether to save data permanently within Synnax, or just stream it for real-time consumption."
    auto_start: bool = False
    "Whether to start the task automatically when it is created."
    channels: list[WriteChannel]
    "A list of WriteChannel objects that specify which OPC UA nodes to write to."

    @field_validator("channels")
    def validate_channels_not_empty(cls, v):
        """Validate that at least one channel is provided."""
        if len(v) == 0:
            raise ValueError("Task must have at least one channel")
        return v


class WriteTask(StarterStopperMixin, JSONConfigMixin, MetaTask):
    """A write task for sending commands to OPC UA devices. This task is a programmatic
    representation of the OPC UA write task configurable within the Synnax console.
    For detailed information on configuring/operating an OPC UA write task,
    see https://docs.synnaxlabs.com/reference/driver/opc-ua/write-task


    :param device: The key of the Synnax OPC UA device to write to.
    :param name: A human-readable name for the task.
    :param data_saving: Whether to save data permanently within Synnax, or just stream
        it for real-time consumption.
    :param auto_start: Whether to start the task automatically when it is created.
    :param channels: A list of WriteChannel objects that specify which OPC UA nodes to
        write to and which Synnax channels to read command values from.
    """

    TYPE = "opc_write"
    config: WriteTaskConfig
    _internal: Task

    def __init__(
        self,
        internal: Task | None = None,
        *,
        device: str = "",
        name: str = "",
        data_saving: bool = False,
        auto_start: bool = False,
        channels: list[WriteChannel] = None,
    ):
        if internal is not None:
            self._internal = internal
            self.config = WriteTaskConfig.model_validate_json(internal.config)
            return
        self._internal = Task(name=name, type=self.TYPE)
        self.config = WriteTaskConfig(
            device=device,
            data_saving=data_saving,
            auto_start=auto_start,
            channels=channels if channels is not None else [],
        )

    def _update_device_properties(self, device_client):
        """Internal: Update device properties before task configuration."""
        import json

        dev = device_client.retrieve(key=self.config.device)
        props = json.loads(dev.properties) if isinstance(dev.properties, str) else dev.properties

        if "write" not in props:
            props["write"] = {"channels": {}}

        # Map node_id -> cmd_channel key for Console
        for ch in self.config.channels:
            if ch.node_id:
                props["write"]["channels"][ch.node_id] = ch.cmd_channel

        dev.properties = json.dumps(props)
        device_client.create(dev)


MAKE = "opc"
MODEL = "OPC UA"


def device_props(
    endpoint: str,
    username: str = "",
    password: str = "",
    security_mode: str = "None",
    security_policy: str = "None",
    client_cert: str = "",
    client_private_key: str = "",
    server_cert: str = "",
) -> dict:
    """
    Create device properties for an OPC UA connection.

    Args:
        endpoint: The OPC UA server endpoint URL (e.g., "opc.tcp://localhost:4840/")
        username: Username for authentication (optional)
        password: Password for authentication (optional)
        security_mode: Security mode - "None", "Sign", or "SignAndEncrypt" (default: "None")
        security_policy: Security policy - "None", "Basic128Rsa15", "Basic256", etc. (default: "None")
        client_cert: Client certificate for secure connections (optional)
        client_private_key: Client private key for secure connections (optional)
        server_cert: Trusted server certificate for secure connections (optional)

    Returns:
        Dictionary of device properties with the correct structure for Console
    """
    # Driver expects snake_case property names (see driver/opc/connection/connection.h)
    connection = {
        "endpoint": endpoint,
        "security_mode": security_mode,  # Always include, even if "None"
        "security_policy": security_policy,  # Always include, even if "None"
    }

    # Optional fields - only include if non-empty
    if username:
        connection["username"] = username
    if password:
        connection["password"] = password
    if client_cert:
        connection["client_certificate"] = client_cert
    if client_private_key:
        connection["client_private_key"] = client_private_key
    if server_cert:
        connection["server_certificate"] = server_cert

    return {
        "connection": connection,
        "read": {
            "index": 0,
            "channels": {}
        },
        "write": {
            "channels": {}
        }
    }


def create_device(client, **kwargs):
    """
    Create an OPC UA device with make, model, and key automatically set.

    This is a thin wrapper around client.hardware.devices.create() that
    automatically fills in:
    - make: "opc"
    - model: "OPC UA"
    - key: auto-generated UUID if not provided

    All other parameters are passed through unchanged.

    Example:
        >>> import json
        >>> from synnax.hardware import opcua
        >>> device = opcua.create_device(
        ...     client=client,
        ...     name="OPC UA Server",
        ...     location="opc.tcp://localhost:4840/",
        ...     rack=rack.key,
        ...     properties=json.dumps(opcua.device_props(endpoint="opc.tcp://localhost:4840/"))
        ... )
    """
    from uuid import uuid4

    # Auto-generate key if not provided
    if "key" not in kwargs:
        kwargs["key"] = str(uuid4())

    kwargs["make"] = MAKE
    kwargs["model"] = MODEL
    kwargs["configured"] = True
    return client.hardware.devices.create(**kwargs)
