#  Copyright 2026 Synnax Labs, Inc.
#
#  Use of this software is governed by the Business Source License included in the file
#  licenses/BSL.txt.
#
#  As of the Change Date specified in that file, in accordance with the Business Source
#  License, use of this software will be governed by the Apache License, Version 2.0,
#  included in the file licenses/APL.txt.

# Code generated by Oracle. DO NOT EDIT.

from __future__ import annotations

from typing import Any, Generic, NewType, TypeAlias, TypeVar

from pydantic import BaseModel

from synnax import status as status_
from synnax.ontology.payload import ID

Key = NewType("Key", int)


class StatusDetails(BaseModel):
    """Contains task-specific status details including execution state.

    Attributes:
        task: Is the key of the task this status pertains to.
        running: Is true if the task is currently executing.
        cmd: Is the last command executed on this task.
        data: Contains task-specific status data.
    """

    task: Key
    running: bool
    cmd: str | None = None
    data: dict[str, Any] | None = None


class Command(BaseModel):
    """Is a command to execute on a task in the Driver system.

    Attributes:
        task: Is the key of the target task.
        type: Is the command type (e.g., 'start', 'stop', 'configure').
        key: Is a unique identifier for this command instance.
        args: Contains optional arguments for the command.
    """

    task: Key
    type: str
    key: str
    args: dict[str, Any] | None = None


Status: TypeAlias = status_.Status[StatusDetails]


class Payload(BaseModel):
    """Is an executable unit of work in the Driver system. Tasks represent
    specific hardware operations such as reading sensor data, writing
    control signals, or scanning for devices.

    Attributes:
        key: Is the composite identifier for this task.
        name: Is a human-readable name for the task.
        type: Is the task type (e.g., 'modbus_read', 'labjack_write', 'opc_scan').
            Determines which hardware integration handles the task.
        config: Is task-specific configuration stored as JSON. Structure varies by
            task type.
        internal: Is true if this is an internal system task.
        snapshot: Indicates whether to persist this task's configuration.
        status: Is the current execution status of the task.
    """

    key: Key
    name: str
    type: str
    config: dict[str, Any]
    internal: bool | None = None
    snapshot: bool | None = None
    status: Status | None = None

    def __hash__(self) -> int:
        return hash(self.key)


ONTOLOGY_TYPE = ID(type="task")


def ontology_id(key: Key) -> ID:
    return ID(type="task", key=str(key))
