// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package api

import (
	"strings"
	"text/template"
)

var templateFuncs = template.FuncMap{
	"join": strings.Join,
}

// aliasFileTemplate generates a Go file with type aliases.
var aliasFileTemplate = template.Must(template.New("go-api-alias").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.

package {{.Package}}
{{- if .HasImports}}

import (
{{- range .InternalImports}}
{{- if .NeedsAlias}}
	{{.Alias}} "{{.Path}}"
{{- else}}
	"{{.Path}}"
{{- end}}
{{- end}}
)
{{- end}}
{{range .Aliases}}

type {{.Name}} = {{.AliasOf}}
{{- end}}
`))

// translatorFileTemplate generates a Go file with translator functions.
var translatorFileTemplate = template.Must(template.New("go-api-translator").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.

package {{.Package}}
{{- if .HasImports}}

import (
{{- range .ExternalImports}}
	"{{.}}"
{{- end}}
{{- if and (gt (len .ExternalImports) 0) (gt (len .InternalImports) 0)}}

{{- end}}
{{- range .InternalImports}}
{{- if .NeedsAlias}}
	{{.Alias}} "{{.Path}}"
{{- else}}
	"{{.Path}}"
{{- end}}
{{- end}}
)
{{- end}}

// Suppress unused import warnings
var _ = context.Background
{{range .Translators}}

// Translate{{.Name}}Forward converts {{.GoTypeShort}} to {{.PBTypeShort}}.
func Translate{{.Name}}Forward(ctx context.Context, r *{{.GoType}}) (*{{.PBType}}, error) {
	_ = ctx // May be unused
	if r == nil {
		return nil, nil
	}
	pb := &{{.PBType}}{
{{- range .Fields}}
		{{.PBName}}: {{.ForwardExpr}},
{{- end}}
	}
{{- range .OptionalFields}}
	if r.{{.GoName}} != nil {
{{- if .IsOptionalStruct}}
		var err error
		pb.{{.PBName}}, err = {{.ForwardExpr}}
		if err != nil {
			return nil, err
		}
{{- else}}
		pb.{{.PBName}} = {{.ForwardExpr}}
{{- end}}
	}
{{- end}}
	return pb, nil
}

// Translate{{.Name}}Backward converts {{.PBTypeShort}} to {{.GoTypeShort}}.
func Translate{{.Name}}Backward(ctx context.Context, pb *{{.PBType}}) (*{{.GoType}}, error) {
	_ = ctx // May be unused
	if pb == nil {
		return nil, nil
	}
	r := &{{.GoType}}{
{{- range .Fields}}
		{{.GoName}}: {{.BackwardExpr}},
{{- end}}
	}
{{- range .OptionalFields}}
	if pb.{{.PBName}} != nil {
{{- if .IsOptionalStruct}}
		val, err := {{.BackwardExpr}}
		if err != nil {
			return nil, err
		}
		r.{{.GoName}} = val
{{- else}}
		r.{{.GoName}} = {{.BackwardExpr}}
{{- end}}
	}
{{- end}}
	return r, nil
}

// Translate{{.Name}}sForward converts a slice of {{.GoTypeShort}} to {{.PBTypeShort}}.
func Translate{{.Name}}sForward(ctx context.Context, rs []{{.GoType}}) ([]*{{.PBType}}, error) {
	result := make([]*{{.PBType}}, len(rs))
	for i := range rs {
		var err error
		result[i], err = Translate{{.Name}}Forward(ctx, &rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// Translate{{.Name}}sBackward converts a slice of {{.PBTypeShort}} to {{.GoTypeShort}}.
func Translate{{.Name}}sBackward(ctx context.Context, pbs []*{{.PBType}}) ([]{{.GoType}}, error) {
	result := make([]{{.GoType}}, len(pbs))
	for i, pb := range pbs {
		r, err := Translate{{.Name}}Backward(ctx, pb)
		if err != nil {
			return nil, err
		}
		if r != nil {
			result[i] = *r
		}
	}
	return result, nil
}
{{- end}}
{{- range .EnumTranslators}}

func translate{{.Name}}Forward(v {{.GoType}}) {{.PBType}} {
	switch v {
{{- range .Values}}
	case {{.GoValue}}:
		return {{.PBValue}}
{{- end}}
	default:
		return {{.PBDefault}}
	}
}

func translate{{.Name}}Backward(v {{.PBType}}) {{.GoType}} {
	switch v {
{{- range .Values}}
	case {{.PBValue}}:
		return {{.GoValue}}
{{- end}}
	default:
		return {{.GoDefault}}
	}
}
{{- end}}
`))
