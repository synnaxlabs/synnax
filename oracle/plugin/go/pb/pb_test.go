// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package pb_test

import (
	"context"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/synnaxlabs/oracle/plugin/go/pb"
	"github.com/synnaxlabs/oracle/testutil"
)

func TestGoPB(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Go PB Plugin Suite")
}

var _ = Describe("Go PB Plugin", func() {
	var (
		ctx      context.Context
		loader   *testutil.MockFileLoader
		pbPlugin *pb.Plugin
	)

	BeforeEach(func() {
		ctx = context.Background()
		loader = testutil.NewMockFileLoader()
		pbPlugin = pb.New(pb.DefaultOptions())
	})

	Describe("Plugin Interface", func() {
		It("Should have correct name", func() {
			Expect(pbPlugin.Name()).To(Equal("go/pb"))
		})

		It("Should filter on pb domain", func() {
			Expect(pbPlugin.Domains()).To(Equal([]string{"pb"}))
		})

		It("Should require go/types and pb/types", func() {
			Expect(pbPlugin.Requires()).To(Equal([]string{"go/types", "pb/types"}))
		})
	})

	Describe("Generate", func() {
		Context("simple struct translation", func() {
			It("Should generate ToPB and FromPB functions", func() {
				source := `
					@go output "core/pkg/service/user"
					@pb

					User struct {
						key uuid
						name string
						age int32
					}
				`
				resp := testutil.MustGenerate(ctx, source, "user", loader, pbPlugin)
				Expect(resp.Files).To(HaveLen(1))

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(
						"// Code generated by oracle. DO NOT EDIT.",
						"package pb",
						"func UserToPB(_ context.Context, r user.User) (*User, error)",
						"func UserFromPB(_ context.Context, pb *User) (user.User, error)",
					).
					ToPreserveOrder(
						"func UserToPB",
						"func UserFromPB",
					)
			})

			It("Should generate slice translators", func() {
				source := `
					@go output "core/pkg/service/user"
					@pb

					User struct {
						key uuid
						name string
					}
				`
				resp := testutil.MustGenerate(ctx, source, "user", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(
						"func UsersToPB(ctx context.Context, rs []user.User) ([]*User, error)",
						"func UsersFromPB(ctx context.Context, pbs []*User) ([]user.User, error)",
					)
			})
		})

		Context("primitive field conversions", func() {
			DescribeTable("should convert primitive types correctly",
				func(fieldDecl, expectedForward, expectedBackward string) {
					source := `
						@go output "core/test"
						@pb

						Test struct {
							` + fieldDecl + `
						}
					`
					resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)
					content := testutil.MustContentOf(resp, "translator.gen.go")
					Expect(content).To(ContainSubstring(expectedForward))
					Expect(content).To(ContainSubstring(expectedBackward))
				},
				Entry("uuid to string",
					"key uuid",
					"Key: r.Key.String()",
					"r.Key = uuid.MustParse(pb.Key)",
				),
				Entry("string passthrough",
					"name string",
					"Name: r.Name",
					"r.Name = pb.Name",
				),
				Entry("bool passthrough",
					"active bool",
					"Active: r.Active",
					"r.Active = pb.Active",
				),
				Entry("int32 passthrough",
					"count int32",
					"Count: r.Count",
					"r.Count = pb.Count",
				),
				Entry("int64 passthrough",
					"count int64",
					"Count: r.Count",
					"r.Count = pb.Count",
				),
				Entry("uint32 passthrough",
					"count uint32",
					"Count: r.Count",
					"r.Count = pb.Count",
				),
				Entry("uint64 passthrough",
					"count uint64",
					"Count: r.Count",
					"r.Count = pb.Count",
				),
				Entry("float32 passthrough",
					"value float32",
					"Value: r.Value",
					"r.Value = pb.Value",
				),
				Entry("float64 passthrough",
					"value float64",
					"Value: r.Value",
					"r.Value = pb.Value",
				),
				Entry("bytes passthrough",
					"data bytes",
					"Data: r.Data",
					"r.Data = pb.Data",
				),
			)
		})

		Context("array field conversions", func() {
			It("Should handle uuid array to string array", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						keys uuid[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("Keys: lo.Map(r.Keys").
					ToContain("r.Keys = lo.Map(pb.Keys")
			})

			It("Should handle string array passthrough", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						tags string[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("Tags: r.Tags").
					ToContain("r.Tags = pb.Tags")
			})
		})

		Context("enum translation", func() {
			It("Should generate enum ToPB and FromPB functions", func() {
				source := `
					@go output "core/status"
					@pb

					Status enum {
						unknown = 0
						pending = 1
						active = 2
					}

					Task struct {
						key uuid
						status Status
					}
				`
				resp := testutil.MustGenerate(ctx, source, "status", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(
						"func StatusToPB(v status.Status) Status",
						"func StatusFromPB(v Status) status.Status",
					).
					ToContain(
						"case status.StatusUnknown:",
						"case status.StatusPending:",
						"case status.StatusActive:",
					)
			})

			It("Should use enum translators in struct fields", func() {
				source := `
					@go output "core/status"
					@pb

					Status enum {
						active = 0
						inactive = 1
					}

					Task struct {
						key uuid
						status Status
					}
				`
				resp := testutil.MustGenerate(ctx, source, "status", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("Status: StatusToPB(r.Status)").
					ToContain("r.Status = StatusFromPB(pb.Status)")
			})
		})

		Context("hard optional fields", func() {
			It("Should handle hard optional primitive with nil check", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						key uuid
						name string??
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("if r.Name != nil {").
					ToContain("if pb.Name != nil {")
			})
		})

		Context("struct reference fields", func() {
			It("Should call nested struct translators", func() {
				source := `
					@go output "core/task"
					@pb

					Status struct {
						code int32
						message string
					}

					Task struct {
						key uuid
						status Status
					}
				`
				resp := testutil.MustGenerate(ctx, source, "task", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("StatusToPB(ctx, r.Status)").
					ToContain("StatusFromPB(ctx, pb.Status)")
			})

			It("Should handle array of struct references", func() {
				source := `
					@go output "core/task"
					@pb

					Item struct {
						key uuid
						name string
					}

					Container struct {
						key uuid
						items Item[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "task", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("ItemsToPB(ctx, r.Items)").
					ToContain("ItemsFromPB(ctx, pb.Items)")
			})
		})

		Context("generic struct translation", func() {
			It("Should generate generic translator functions", func() {
				source := `
					@go output "core/container"
					@pb

					Container struct<T> {
						key uuid
						value T
					}
				`
				resp := testutil.MustGenerate(ctx, source, "container", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(
						"func ContainerToPB[T any](",
						"translateT func(context.Context, T) (*anypb.Any, error)",
					)
			})

			It("Should import anypb for generic types", func() {
				source := `
					@go output "core/container"
					@pb

					Container struct<T> {
						value T
					}
				`
				resp := testutil.MustGenerate(ctx, source, "container", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("google.golang.org/protobuf/types/known/anypb")
			})
		})

		Context("naming conventions", func() {
			It("Should convert snake_case to PascalCase", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						created_at timestamp
						time_range time_range
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("CreatedAt:").
					ToContain("r.CreatedAt").
					ToContain("TimeRange:")
			})
		})

		Context("import management", func() {
			It("Should import context package", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(`"context"`)
			})

			It("Should import uuid package when uuid fields present", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(`"github.com/google/uuid"`)
			})

			It("Should import lo package when array conversions needed", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						keys uuid[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(`"github.com/samber/lo"`)
			})
		})

		Context("omit directive", func() {
			It("Should skip structs with @pb omit", func() {
				source := `
					@go output "core/test"
					@pb

					Internal struct {
						secret string

						@pb omit
					}

					Public struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("func PublicToPB").
					ToNotContain("InternalToPB")
			})
		})

		Context("multiple structs", func() {
			It("Should generate translators for all structs", func() {
				source := `
					@go output "core/test"
					@pb

					User struct {
						key uuid
						name string
					}

					Group struct {
						key uuid
						name string
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("func UserToPB").
					ToContain("func UserFromPB").
					ToContain("func GroupToPB").
					ToContain("func GroupFromPB")
			})

			It("Should preserve declaration order", func() {
				source := `
					@go output "core/test"
					@pb

					First struct { key uuid }
					Second struct { key uuid }
					Third struct { key uuid }
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToPreserveOrder(
						"func FirstToPB",
						"func SecondToPB",
						"func ThirdToPB",
					)
			})
		})

		Context("no pb directive", func() {
			It("Should not generate file when @pb is absent", func() {
				source := `
					@go output "core/test"

					User struct {
						key uuid
						name string
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)
				Expect(resp.Files).To(BeEmpty())
			})
		})

		Context("output path", func() {
			It("Should generate file in pb subdirectory of go output", func() {
				source := `
					@go output "core/pkg/service/user"
					@pb

					User struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "user", loader, pbPlugin)
				Expect(resp.Files).To(HaveLen(1))
				Expect(resp.Files[0].Path).To(Equal("core/pkg/service/user/pb/translator.gen.go"))
			})
		})

		Context("timestamp and timespan conversions with telem import", func() {
			BeforeEach(func() {
				loader.Add("schemas/telem", `
					@go output "x/go/telem"
					@pb

					timestamp = uint64
					timespan = int64
				`)
			})

			It("Should convert timestamp typedef via uint64", func() {
				source := `
					import "schemas/telem"

					@go output "core/test"
					@pb

					Test struct {
						created_at telem.timestamp
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("uint64(r.CreatedAt)").
					ToContain("telem.timestamp(pb.CreatedAt)")
			})

			It("Should convert timespan typedef via int64", func() {
				source := `
					import "schemas/telem"

					@go output "core/test"
					@pb

					Test struct {
						duration telem.timespan
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("int64(r.Duration)").
					ToContain("telem.timespan(pb.Duration)")
			})
		})

		Context("typedef (distinct type) conversions", func() {
			It("Should convert typedef with numeric base", func() {
				source := `
					@go output "core/test"
					@pb

					Key = uint32

					Test struct {
						rack Key
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("uint32(r.Rack)").
					ToContain("test.Key(pb.Rack)")
			})

			It("Should convert typedef with uuid base", func() {
				source := `
					@go output "core/test"
					@pb

					ResourceKey = uuid

					Test struct {
						resource_key ResourceKey
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("r.ResourceKey.String()").
					ToContain("uuid.MustParse(pb.ResourceKey)")
			})
		})

		Context("key domain with numeric types", func() {
			It("Should convert key field with numeric key domain", func() {
				source := `
					@go output "core/test"
					@pb

					Key = uint32

					Test struct {
						@key
						rack Key
						name string
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("uint32(r.Rack)").
					ToContain("test.Key(pb.Rack)")
			})
		})

		Context("int8 conversion", func() {
			It("Should widen int8 to int32", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						priority int8
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("int32(r.Priority)").
					ToContain("int8(pb.Priority)")
			})
		})

		Context("@go name and @pb name annotations", func() {
			It("Should use custom Go name in translator", func() {
				source := `
					@go output "core/test"
					@go name "CustomName"
					@pb

					Test struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("test.CustomName")
			})

			It("Should use custom PB name in translator function", func() {
				source := `
					@go output "core/test"
					@pb name "ProtoTest"

					Test struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("func ProtoTestToPB").
					ToContain("func ProtoTestFromPB")
			})
		})

		Context("@go omit enum handling", func() {
			It("Should use hand-written enum value format when @go omit", func() {
				source := `
					@go output "core/status"
					@go omit
					@pb

					Status enum {
						active = 0
						inactive = 1
					}

					Task struct {
						key uuid
						status Status
					}
				`
				resp := testutil.MustGenerate(ctx, source, "status", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("status.ActiveStatus").
					ToContain("status.InactiveStatus")
			})
		})

		Context("json field conversion", func() {
			It("Should handle json fields with structpb", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						data json
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("structpb.NewStruct(r.Data)").
					ToContain("pb.Data.AsMap()")
			})
		})

		Context("any field conversion", func() {
			It("Should handle any fields with structpb", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						value any
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("structpb.NewValue").
					ToContain("pb.Value.AsInterface()")
			})
		})
	})

	Describe("Check", func() {
		It("Should return nil (no-op)", func() {
			req := testutil.MustGenerateRequest(ctx, `
				@go output "core/test"
				@pb

				Test struct { key uuid }
			`, "test", loader)
			Expect(pbPlugin.Check(req)).To(Succeed())
		})
	})

	Describe("PostWrite", func() {
		It("Should return nil for empty file list", func() {
			Expect(pbPlugin.PostWrite(nil)).To(Succeed())
			Expect(pbPlugin.PostWrite([]string{})).To(Succeed())
		})

		It("Should filter to only Go files", func() {
			// PostWrite filters non-.go files internally
			err := pbPlugin.PostWrite([]string{"test.proto", "config.yaml"})
			Expect(err).To(Succeed())
		})
	})

	Describe("Generate edge cases", func() {
		Context("type alias to struct", func() {
			It("Should handle alias pointing to struct type", func() {
				source := `
					@go output "core/test"
					@pb

					User struct {
						key uuid
						name string
					}

					Person = User

					Container struct {
						key uuid
						person Person
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("func UserToPB").
					ToContain("func ContainerToPB")
			})
		})

		Context("struct with extends", func() {
			It("Should handle struct that extends another", func() {
				source := `
					@go output "core/test"
					@pb

					Base struct {
						key uuid
						name string
					}

					Derived struct extends Base {
						extra string
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("func BaseToPB").
					ToContain("func DerivedToPB").
					ToContain("Extra: r.Extra")
			})
		})

		Context("struct array references", func() {
			It("Should use slice translator for struct array with error handling", func() {
				source := `
					@go output "core/test"
					@pb

					Item struct {
						key uuid
					}

					List struct {
						key uuid
						items Item[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("ItemsToPB(ctx, r.Items)").
					ToContain("if err != nil")
			})
		})

		Context("generic struct with type args", func() {
			It("Should generate generic translator with converter functions", func() {
				source := `
					@go output "core/test"
					@pb

					Wrapper struct<T> {
						key uuid
						data T
					}

					User struct {
						key uuid
					}

					UserWrapper = Wrapper<User>
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("func WrapperToPB[T any]").
					ToContain("translateT func")
			})
		})

		Context("soft optional fields", func() {
			It("Should handle soft optional with question mark", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						key uuid
						name string?
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("Name: r.Name")
			})
		})

		Context("cross-namespace struct reference", func() {
			BeforeEach(func() {
				loader.Add("schemas/common", `
					@go output "core/common"
					@pb

					Info struct {
						key uuid
						description string
					}
				`)
			})

			It("Should import pb package for cross-namespace struct", func() {
				source := `
					import "schemas/common"

					@go output "core/test"
					@pb

					Test struct {
						key uuid
						info common.Info
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("InfoToPB(ctx, r.Info)").
					ToContain("InfoFromPB(ctx, pb.Info)")
			})
		})

		Context("enum in different namespace", func() {
			BeforeEach(func() {
				loader.Add("schemas/status", `
					@go output "core/status"
					@pb

					Status enum {
						unknown = 0
						active = 1
					}
				`)
			})

			It("Should import pb package for cross-namespace enum", func() {
				source := `
					import "schemas/status"

					@go output "core/task"
					@pb

					Task struct {
						key uuid
						status status.Status
					}
				`
				resp := testutil.MustGenerate(ctx, source, "task", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("StatusToPB(r.Status)")
			})
		})
	})
})
