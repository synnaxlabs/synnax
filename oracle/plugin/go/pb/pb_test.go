// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package pb_test

import (
	"context"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/synnaxlabs/oracle/plugin/go/pb"
	"github.com/synnaxlabs/oracle/testutil"
)

func TestGoPB(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Go PB Plugin Suite")
}

var _ = Describe("Go PB Plugin", func() {
	var (
		ctx      context.Context
		loader   *testutil.MockFileLoader
		pbPlugin *pb.Plugin
	)

	BeforeEach(func() {
		ctx = context.Background()
		loader = testutil.NewMockFileLoader()
		pbPlugin = pb.New(pb.DefaultOptions())
	})

	Describe("Plugin Interface", func() {
		It("Should have correct name", func() {
			Expect(pbPlugin.Name()).To(Equal("go/pb"))
		})

		It("Should filter on pb domain", func() {
			Expect(pbPlugin.Domains()).To(Equal([]string{"pb"}))
		})

		It("Should require go/types and pb/types", func() {
			Expect(pbPlugin.Requires()).To(Equal([]string{"go/types", "pb/types"}))
		})
	})

	Describe("Generate", func() {
		Context("simple struct translation", func() {
			It("Should generate ToPB and FromPB functions", func() {
				source := `
					@go output "core/pkg/service/user"
					@pb

					User struct {
						key uuid
						name string
						age int32
					}
				`
				resp := testutil.MustGenerate(ctx, source, "user", loader, pbPlugin)
				Expect(resp.Files).To(HaveLen(1))

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(
						"// Code generated by oracle. DO NOT EDIT.",
						"package pb",
						"func UserToPB(_ context.Context, r user.User) (*User, error)",
						"func UserFromPB(_ context.Context, pb *User) (user.User, error)",
					).
					ToPreserveOrder(
						"func UserToPB",
						"func UserFromPB",
					)
			})

			It("Should generate slice translators", func() {
				source := `
					@go output "core/pkg/service/user"
					@pb

					User struct {
						key uuid
						name string
					}
				`
				resp := testutil.MustGenerate(ctx, source, "user", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(
						"func UsersToPB(ctx context.Context, rs []user.User) ([]*User, error)",
						"func UsersFromPB(ctx context.Context, pbs []*User) ([]user.User, error)",
					)
			})
		})

		Context("primitive field conversions", func() {
			DescribeTable("should convert primitive types correctly",
				func(fieldDecl, expectedForward, expectedBackward string) {
					source := `
						@go output "core/test"
						@pb

						Test struct {
							` + fieldDecl + `
						}
					`
					resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)
					content := testutil.MustContentOf(resp, "translator.gen.go")
					Expect(content).To(ContainSubstring(expectedForward))
					Expect(content).To(ContainSubstring(expectedBackward))
				},
				Entry("uuid to string",
					"key uuid",
					"Key: r.Key.String()",
					"r.Key = uuid.MustParse(pb.Key)",
				),
				Entry("string passthrough",
					"name string",
					"Name: r.Name",
					"r.Name = pb.Name",
				),
				Entry("bool passthrough",
					"active bool",
					"Active: r.Active",
					"r.Active = pb.Active",
				),
				Entry("int32 passthrough",
					"count int32",
					"Count: r.Count",
					"r.Count = pb.Count",
				),
				Entry("int64 passthrough",
					"count int64",
					"Count: r.Count",
					"r.Count = pb.Count",
				),
				Entry("uint32 passthrough",
					"count uint32",
					"Count: r.Count",
					"r.Count = pb.Count",
				),
				Entry("uint64 passthrough",
					"count uint64",
					"Count: r.Count",
					"r.Count = pb.Count",
				),
				Entry("float32 passthrough",
					"value float32",
					"Value: r.Value",
					"r.Value = pb.Value",
				),
				Entry("float64 passthrough",
					"value float64",
					"Value: r.Value",
					"r.Value = pb.Value",
				),
				Entry("timestamp to int64",
					"created_at timestamp",
					"CreatedAt: int64(r.CreatedAt)",
					"r.CreatedAt = telem.TimeStamp(pb.CreatedAt)",
				),
				Entry("timespan to int64",
					"duration timespan",
					"Duration: int64(r.Duration)",
					"r.Duration = telem.TimeSpan(pb.Duration)",
				),
				Entry("bytes passthrough",
					"data bytes",
					"Data: r.Data",
					"r.Data = pb.Data",
				),
			)
		})

		Context("array field conversions", func() {
			It("Should handle uuid array to string array", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						keys uuid[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("Keys: lo.Map(r.Keys").
					ToContain("r.Keys = lo.Map(pb.Keys")
			})

			It("Should handle string array passthrough", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						tags string[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("Tags: r.Tags").
					ToContain("r.Tags = pb.Tags")
			})
		})

		Context("enum translation", func() {
			It("Should generate enum ToPB and FromPB functions", func() {
				source := `
					@go output "core/status"
					@pb

					Status enum {
						unknown = 0
						pending = 1
						active = 2
					}

					Task struct {
						key uuid
						status Status
					}
				`
				resp := testutil.MustGenerate(ctx, source, "status", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(
						"func StatusToPB(v status.Status) Status",
						"func StatusFromPB(v Status) status.Status",
					).
					ToContain(
						"case status.StatusUnknown:",
						"case status.StatusPending:",
						"case status.StatusActive:",
					)
			})

			It("Should use enum translators in struct fields", func() {
				source := `
					@go output "core/status"
					@pb

					Status enum {
						active = 0
						inactive = 1
					}

					Task struct {
						key uuid
						status Status
					}
				`
				resp := testutil.MustGenerate(ctx, source, "status", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("Status: StatusToPB(r.Status)").
					ToContain("r.Status = StatusFromPB(pb.Status)")
			})
		})

		Context("hard optional fields", func() {
			It("Should handle hard optional primitive with nil check", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						key uuid
						name string??
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("if r.Name != nil {").
					ToContain("if pb.Name != nil {")
			})
		})

		Context("struct reference fields", func() {
			It("Should call nested struct translators", func() {
				source := `
					@go output "core/task"
					@pb

					Status struct {
						code int32
						message string
					}

					Task struct {
						key uuid
						status Status
					}
				`
				resp := testutil.MustGenerate(ctx, source, "task", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("StatusToPB(ctx, r.Status)").
					ToContain("StatusFromPB(ctx, pb.Status)")
			})

			It("Should handle array of struct references", func() {
				source := `
					@go output "core/task"
					@pb

					Item struct {
						key uuid
						name string
					}

					Container struct {
						key uuid
						items Item[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "task", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("ItemsToPB(ctx, r.Items)").
					ToContain("ItemsFromPB(ctx, pb.Items)")
			})
		})

		Context("generic struct translation", func() {
			It("Should generate generic translator functions", func() {
				source := `
					@go output "core/container"
					@pb

					Container struct<T> {
						key uuid
						value T
					}
				`
				resp := testutil.MustGenerate(ctx, source, "container", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(
						"func ContainerToPB[T any](",
						"translateT func(context.Context, T) (*anypb.Any, error)",
					)
			})

			It("Should import anypb for generic types", func() {
				source := `
					@go output "core/container"
					@pb

					Container struct<T> {
						value T
					}
				`
				resp := testutil.MustGenerate(ctx, source, "container", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("google.golang.org/protobuf/types/known/anypb")
			})
		})

		Context("naming conventions", func() {
			It("Should convert snake_case to PascalCase", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						created_at timestamp
						time_range time_range
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("CreatedAt:").
					ToContain("r.CreatedAt").
					ToContain("TimeRange:")
			})
		})

		Context("import management", func() {
			It("Should import context package", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(`"context"`)
			})

			It("Should import uuid package when uuid fields present", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(`"github.com/google/uuid"`)
			})

			It("Should import telem package when timestamp fields present", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						created_at timestamp
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(`synnaxlabs/x/telem`)
			})

			It("Should import lo package when array conversions needed", func() {
				source := `
					@go output "core/test"
					@pb

					Test struct {
						keys uuid[]
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain(`"github.com/samber/lo"`)
			})
		})

		Context("omit directive", func() {
			It("Should skip structs with @pb omit", func() {
				source := `
					@go output "core/test"
					@pb

					Internal struct {
						secret string

						@pb omit
					}

					Public struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("func PublicToPB").
					ToNotContain("InternalToPB")
			})
		})

		Context("multiple structs", func() {
			It("Should generate translators for all structs", func() {
				source := `
					@go output "core/test"
					@pb

					User struct {
						key uuid
						name string
					}

					Group struct {
						key uuid
						name string
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToContain("func UserToPB").
					ToContain("func UserFromPB").
					ToContain("func GroupToPB").
					ToContain("func GroupFromPB")
			})

			It("Should preserve declaration order", func() {
				source := `
					@go output "core/test"
					@pb

					First struct { key uuid }
					Second struct { key uuid }
					Third struct { key uuid }
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)

				testutil.ExpectContent(resp, "translator.gen.go").
					ToPreserveOrder(
						"func FirstToPB",
						"func SecondToPB",
						"func ThirdToPB",
					)
			})
		})

		Context("no pb directive", func() {
			It("Should not generate file when @pb is absent", func() {
				source := `
					@go output "core/test"

					User struct {
						key uuid
						name string
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, pbPlugin)
				Expect(resp.Files).To(BeEmpty())
			})
		})

		Context("output path", func() {
			It("Should generate file in pb subdirectory of go output", func() {
				source := `
					@go output "core/pkg/service/user"
					@pb

					User struct {
						key uuid
					}
				`
				resp := testutil.MustGenerate(ctx, source, "user", loader, pbPlugin)
				Expect(resp.Files).To(HaveLen(1))
				Expect(resp.Files[0].Path).To(Equal("core/pkg/service/user/pb/translator.gen.go"))
			})
		})
	})
})
