// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package pb

import (
	"strings"
	"text/template"
)

var templateFuncs = template.FuncMap{
	"join":    strings.Join,
	"lcFirst": lcFirst,
}

// lcFirst lowercases the first character of a string.
func lcFirst(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

// translatorFileTemplate generates a Go file with translator functions.
var translatorFileTemplate = template.Must(template.New("go-pb-translator").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.

package {{.Package}}
{{- if .HasImports}}

import (
{{- range .ExternalImports}}
	"{{.}}"
{{- end}}
{{- if and (gt (len .ExternalImports) 0) (gt (len .InternalImports) 0)}}

{{- end}}
{{- range .InternalImports}}
{{- if .NeedsAlias}}
	{{.Alias}} "{{.Path}}"
{{- else}}
	"{{.Path}}"
{{- end}}
{{- end}}
)
{{- end}}
{{- if gt (len .DistinctPrimitives) 0}}

// convertAnyForPB converts distinct primitive types to their underlying primitive types
// so that structpb.NewValue() can handle them. This handles custom type aliases like
// telem.TimeSpan (int64), telem.Rate (float64), etc.
func convertAnyForPB(v any) any {
	if v == nil {
		return nil
	}
	switch val := v.(type) {
{{- range .DistinctPrimitives}}
	case {{.GoType}}:
		return {{.PrimitiveType}}(val)
{{- end}}
	default:
		return v
	}
}
{{- end}}
{{range .Translators}}

// {{.Name}}ToPB converts {{.GoTypeShort}} to {{.PBTypeShort}}.
func {{.Name}}ToPB({{if .UsesContext}}ctx{{else}}_{{end}} context.Context, r {{.GoType}}) (*{{.PBType}}, error) {
{{- range .ErrorFields}}
{{- if .HasError}}
	{{lcFirst .GoName}}Val, err := {{.ForwardExpr}}
	if err != nil {
		return nil, err
	}
{{- end}}
{{- end}}
	pb := &{{.PBType}}{
{{- range .Fields}}
		{{.PBName}}: {{.ForwardExpr}},
{{- end}}
{{- range .ErrorFields}}
{{- if .HasError}}
		{{.PBName}}: {{lcFirst .GoName}}Val,
{{- else}}
		{{.PBName}}: {{.ForwardExpr}},
{{- end}}
{{- end}}
	}
{{- range .OptionalFields}}
	if r.{{.GoName}} != nil {
{{- if .HasError}}
		var err error
		pb.{{.PBName}}, err = {{.ForwardExpr}}
		if err != nil {
			return nil, err
		}
{{- else}}
		pb.{{.PBName}} = {{.ForwardExpr}}
{{- end}}
	}
{{- end}}
	return pb, nil
}

// {{.Name}}FromPB converts {{.PBTypeShort}} to {{.GoTypeShort}}.
func {{.Name}}FromPB({{if .UsesContext}}ctx{{else}}_{{end}} context.Context, pb *{{.PBType}}) ({{.GoType}}, error) {
	var r {{.GoType}}
	if pb == nil {
		return r, nil
	}
{{- $needsErr := false}}
{{- range .ErrorFields}}{{if .HasBackwardError}}{{$needsErr = true}}{{end}}{{end}}
{{- if $needsErr}}
	var err error
{{- end}}
{{- range .ErrorFields}}
{{- if .HasBackwardError}}
{{- if .BackwardCast}}
	parsed{{.GoName}}, err := {{.BackwardExpr}}
	if err != nil {
		return r, err
	}
	r.{{.GoName}} = {{.BackwardCast}}(parsed{{.GoName}})
{{- else}}
	r.{{.GoName}}, err = {{.BackwardExpr}}
	if err != nil {
		return r, err
	}
{{- end}}
{{- else}}
	r.{{.GoName}} = {{.BackwardExpr}}
{{- end}}
{{- end}}
{{- range .Fields}}
	r.{{.GoName}} = {{.BackwardExpr}}
{{- end}}
{{- range .OptionalFields}}
	if pb.{{.PBName}} != nil {
{{- if .IsOptionalStruct}}
		val, err := {{.BackwardExpr}}
		if err != nil {
			return r, err
		}
{{- if .BackwardCast}}
		r.{{.GoName}} = {{.BackwardCast}}(&val)
{{- else}}
		r.{{.GoName}} = &val
{{- end}}
{{- else}}
		r.{{.GoName}} = {{.BackwardExpr}}
{{- end}}
	}
{{- end}}
	return r, nil
}

// {{.Name}}sToPB converts a slice of {{.GoTypeShort}} to {{.PBTypeShort}}.
func {{.Name}}sToPB(ctx context.Context, rs []{{.GoType}}) ([]*{{.PBType}}, error) {
	result := make([]*{{.PBType}}, len(rs))
	for i := range rs {
		var err error
		result[i], err = {{.Name}}ToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// {{.Name}}sFromPB converts a slice of {{.PBTypeShort}} to {{.GoTypeShort}}.
func {{.Name}}sFromPB(ctx context.Context, pbs []*{{.PBType}}) ([]{{.GoType}}, error) {
	result := make([]{{.GoType}}, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = {{.Name}}FromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}
{{- end}}
{{- range .EnumTranslators}}

// {{.Name}}ToPB converts {{.GoType}} to {{.PBType}}.
func {{.Name}}ToPB(v {{.GoType}}) {{.PBType}} {
	switch v {
{{- range .Values}}
	case {{.GoValue}}:
		return {{.PBValue}}
{{- end}}
	default:
		return {{.PBDefault}}
	}
}

// {{.Name}}FromPB converts {{.PBType}} to {{.GoType}}.
func {{.Name}}FromPB(v {{.PBType}}) {{.GoType}} {
	switch v {
{{- range .Values}}
	case {{.PBValue}}:
		return {{.GoValue}}
{{- end}}
	default:
		return {{.GoDefault}}
	}
}
{{- end}}
{{- range .GenericTranslators}}

// {{.Name}}ToPB converts {{.GoTypeShort}} to {{.PBTypeShort}} using provided type converters.
func {{.Name}}ToPB{{if .TypeParams}}[{{range $i, $tp := .TypeParams}}{{if $i}}, {{end}}{{$tp.Name}} {{$tp.Constraint}}{{end}}]{{end}}(
	{{if .UsesContext}}ctx{{else}}_{{end}} context.Context,
	r {{.GoType}},
{{- range .TypeParams}}
	translate{{.Name}} func(context.Context, {{.Name}}) (*anypb.Any, error),
{{- end}}
) (*{{.PBType}}, error) {
{{- range .TypeParamFields}}
	{{lcFirst .GoName}}Any, err := {{.ForwardExpr}}
	if err != nil {
		return nil, err
	}
{{- end}}
{{- range .ErrorFields}}
{{- if .HasError}}
	{{lcFirst .GoName}}Val, err := {{.ForwardExpr}}
	if err != nil {
		return nil, err
	}
{{- end}}
{{- end}}
	pb := &{{.PBType}}{
{{- range .Fields}}
		{{.PBName}}: {{.ForwardExpr}},
{{- end}}
{{- range .TypeParamFields}}
		{{.PBName}}: {{lcFirst .GoName}}Any,
{{- end}}
{{- range .ErrorFields}}
{{- if .HasError}}
		{{.PBName}}: {{lcFirst .GoName}}Val,
{{- else}}
		{{.PBName}}: {{.ForwardExpr}},
{{- end}}
{{- end}}
	}
{{- range .OptionalFields}}
	if r.{{.GoName}} != nil {
{{- if .HasError}}
		var err error
		pb.{{.PBName}}, err = {{.ForwardExpr}}
		if err != nil {
			return nil, err
		}
{{- else}}
		pb.{{.PBName}} = {{.ForwardExpr}}
{{- end}}
	}
{{- end}}
	return pb, nil
}

// {{.Name}}FromPB converts {{.PBTypeShort}} to {{.GoTypeShort}} using provided type converters.
func {{.Name}}FromPB{{if .TypeParams}}[{{range $i, $tp := .TypeParams}}{{if $i}}, {{end}}{{$tp.Name}} {{$tp.Constraint}}{{end}}]{{end}}(
	{{if .UsesContext}}ctx{{else}}_{{end}} context.Context,
	pb *{{.PBType}},
{{- range .TypeParams}}
	translate{{.Name}} func(context.Context, *anypb.Any) ({{.Name}}, error),
{{- end}}
) ({{.GoType}}, error) {
	var r {{.GoType}}
	if pb == nil {
		return r, nil
	}
{{- $needsErr := false}}
{{- range .TypeParamFields}}{{$needsErr = true}}{{end}}
{{- range .ErrorFields}}{{if .HasBackwardError}}{{$needsErr = true}}{{end}}{{end}}
{{- if $needsErr}}
	var err error
{{- end}}
{{- range .TypeParamFields}}
	r.{{.GoName}}, err = {{.BackwardExpr}}
	if err != nil {
		return r, err
	}
{{- end}}
{{- range .ErrorFields}}
{{- if .HasBackwardError}}
{{- if .BackwardCast}}
	parsed{{.GoName}}, err := {{.BackwardExpr}}
	if err != nil {
		return r, err
	}
	r.{{.GoName}} = {{.BackwardCast}}(parsed{{.GoName}})
{{- else}}
	r.{{.GoName}}, err = {{.BackwardExpr}}
	if err != nil {
		return r, err
	}
{{- end}}
{{- else}}
	r.{{.GoName}} = {{.BackwardExpr}}
{{- end}}
{{- end}}
{{- range .Fields}}
	r.{{.GoName}} = {{.BackwardExpr}}
{{- end}}
{{- range .OptionalFields}}
	if pb.{{.PBName}} != nil {
{{- if .IsOptionalStruct}}
		val, err := {{.BackwardExpr}}
		if err != nil {
			return r, err
		}
{{- if .BackwardCast}}
		r.{{.GoName}} = {{.BackwardCast}}(&val)
{{- else}}
		r.{{.GoName}} = &val
{{- end}}
{{- else}}
		r.{{.GoName}} = {{.BackwardExpr}}
{{- end}}
	}
{{- end}}
	return r, nil
}

// {{.Name}}sToPB converts a slice of {{.GoTypeShort}} to {{.PBTypeShort}}.
func {{.Name}}sToPB{{if .TypeParams}}[{{range $i, $tp := .TypeParams}}{{if $i}}, {{end}}{{$tp.Name}} {{$tp.Constraint}}{{end}}]{{end}}(
	ctx context.Context,
	rs []{{.GoType}},
{{- range .TypeParams}}
	translate{{.Name}} func(context.Context, {{.Name}}) (*anypb.Any, error),
{{- end}}
) ([]*{{.PBType}}, error) {
	result := make([]*{{.PBType}}, len(rs))
	for i := range rs {
		var err error
		result[i], err = {{.Name}}ToPB(ctx, rs[i]{{range .TypeParams}}, translate{{.Name}}{{end}})
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// {{.Name}}sFromPB converts a slice of {{.PBTypeShort}} to {{.GoTypeShort}}.
func {{.Name}}sFromPB{{if .TypeParams}}[{{range $i, $tp := .TypeParams}}{{if $i}}, {{end}}{{$tp.Name}} {{$tp.Constraint}}{{end}}]{{end}}(
	ctx context.Context,
	pbs []*{{.PBType}},
{{- range .TypeParams}}
	translate{{.Name}} func(context.Context, *anypb.Any) ({{.Name}}, error),
{{- end}}
) ([]{{.GoType}}, error) {
	result := make([]{{.GoType}}, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = {{.Name}}FromPB(ctx, pb{{range .TypeParams}}, translate{{.Name}}{{end}})
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}
{{- end}}
{{- range .AnyHelpers}}

// {{.TypeName}}ToPBAny converts {{.TypeName}} to *anypb.Any for use with generic translators.
// It wraps the value in structpb.Struct (JSON) for cross-language compatibility.
func {{.TypeName}}ToPBAny(ctx context.Context, v {{.GoType}}) (*anypb.Any, error) {
	pb, err := {{.TypeName}}ToPB(ctx, v)
	if err != nil {
		return nil, err
	}
	// Convert proto to JSON bytes, then to Struct for cross-language compatibility
	jsonBytes, err := protojson.Marshal(pb)
	if err != nil {
		return nil, err
	}
	s := &structpb.Struct{}
	if err := protojson.Unmarshal(jsonBytes, s); err != nil {
		return nil, err
	}
	return anypb.New(s)
}

// {{.TypeName}}FromPBAny converts *anypb.Any to {{.TypeName}} for use with generic translators.
// It handles both typed protos and JSON (google.protobuf.Struct) for cross-language compatibility.
func {{.TypeName}}FromPBAny(ctx context.Context, a *anypb.Any) ({{.GoType}}, error) {
	if a == nil {
		return {{.GoType}}{}, nil
	}
	// First try typed proto
	var pb {{.PBType}}
	if err := a.UnmarshalTo(&pb); err == nil {
		return {{.TypeName}}FromPB(ctx, &pb)
	}
	// Fall back to JSON (structpb.Struct) for cross-language compatibility
	var s structpb.Struct
	if err := a.UnmarshalTo(&s); err != nil {
		return {{.GoType}}{}, err
	}
	// Convert map to JSON then unmarshal to Go struct
	jsonBytes, err := json.Marshal(s.AsMap())
	if err != nil {
		return {{.GoType}}{}, err
	}
	var result {{.GoType}}
	if err := json.Unmarshal(jsonBytes, &result); err != nil {
		return {{.GoType}}{}, err
	}
	return result, nil
}
{{- end}}
{{- range .DelegationTranslators}}

// {{.Name}}ToPB delegates to the underlying type's translator.
func {{.Name}}ToPB{{if .TypeParams}}[{{range $i, $tp := .TypeParams}}{{if $i}}, {{end}}{{$tp.Name}} {{$tp.Constraint}}{{end}}]{{end}}(
	ctx context.Context,
	r {{.GoType}},
{{- range .TypeParams}}
	translate{{.Name}} func(context.Context, {{.Name}}) (*anypb.Any, error),
{{- end}}
) (*{{.UnderlyingPBType}}, error) {
	return {{.UnderlyingTranslatorPrefix}}{{.UnderlyingName}}ToPB(ctx, {{.UnderlyingGoType}}(r){{range .TypeParams}}, translate{{.Name}}{{end}})
}

// {{.Name}}FromPB delegates to the underlying type's translator.
func {{.Name}}FromPB{{if .TypeParams}}[{{range $i, $tp := .TypeParams}}{{if $i}}, {{end}}{{$tp.Name}} {{$tp.Constraint}}{{end}}]{{end}}(
	ctx context.Context,
	pb *{{.UnderlyingPBType}},
{{- range .TypeParams}}
	translate{{.Name}} func(context.Context, *anypb.Any) ({{.Name}}, error),
{{- end}}
) ({{.GoType}}, error) {
	result, err := {{.UnderlyingTranslatorPrefix}}{{.UnderlyingName}}FromPB(ctx, pb{{range .TypeParams}}, translate{{.Name}}{{end}})
	return {{.GoType}}(result), err
}
{{- end}}
`))
