// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package types_test

import (
	"context"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/synnaxlabs/oracle/analyzer"
	"github.com/synnaxlabs/oracle/plugin"
	"github.com/synnaxlabs/oracle/plugin/go/types"
)

func TestGoTypes(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Go Types Plugin Suite")
}

// MockFileLoader is a file loader that serves files from memory.
type MockFileLoader struct {
	Files map[string]string
}

func (m *MockFileLoader) Load(importPath string) (string, string, error) {
	if content, ok := m.Files[importPath]; ok {
		return content, importPath + ".oracle", nil
	}
	if content, ok := m.Files[importPath+".oracle"]; ok {
		return content, importPath + ".oracle", nil
	}
	return "", "", &fileNotFoundError{path: importPath}
}

func (m *MockFileLoader) RepoRoot() string {
	return "/mock/repo"
}

type fileNotFoundError struct {
	path string
}

func (e *fileNotFoundError) Error() string {
	return "file not found: " + e.path
}

var _ = Describe("Go Types Plugin", func() {
	var (
		ctx        context.Context
		loader     *MockFileLoader
		goPlugin   *types.Plugin
	)

	BeforeEach(func() {
		ctx = context.Background()
		loader = &MockFileLoader{Files: make(map[string]string)}
		goPlugin = types.New(types.DefaultOptions())
	})

	Describe("Plugin Interface", func() {
		It("Should have correct name", func() {
			Expect(goPlugin.Name()).To(Equal("go/types"))
		})

		It("Should filter on go domain", func() {
			Expect(goPlugin.Domains()).To(Equal([]string{"go"}))
		})

		It("Should have no dependencies", func() {
			Expect(goPlugin.Requires()).To(BeNil())
		})
	})

	Describe("Generate", func() {
		It("Should generate struct for simple types", func() {
			source := `
				struct User {
					field key uuid
					field name string
					field age int32
					field active bool
					domain go { output "core/pkg/service/user" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(HaveLen(1))

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`// Code generated by oracle. DO NOT EDIT.`))
			Expect(content).To(ContainSubstring(`package user`))
			Expect(content).To(ContainSubstring(`"github.com/google/uuid"`))
			Expect(content).To(ContainSubstring(`type User struct {`))
			Expect(content).To(ContainSubstring("Key uuid.UUID `json:\"key\" msgpack:\"key\"`"))
			Expect(content).To(ContainSubstring("Name string `json:\"name\" msgpack:\"name\"`"))
			Expect(content).To(ContainSubstring("Age int32 `json:\"age\" msgpack:\"age\"`"))
			Expect(content).To(ContainSubstring("Active bool `json:\"active\" msgpack:\"active\"`"))
		})

		It("Should handle optional types with pointer", func() {
			source := `
				struct Range {
					field key uuid
					field parent uuid?
					field description string?
					domain go { output "core/ranger" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "ranger", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring("Parent *uuid.UUID `json:\"parent,omitempty\" msgpack:\"parent,omitempty\"`"))
			Expect(content).To(ContainSubstring("Description *string `json:\"description,omitempty\" msgpack:\"description,omitempty\"`"))
		})

		It("Should handle array types", func() {
			source := `
				struct Range {
					field key uuid
					field labels uuid[]
					field tags string[]
					domain go { output "core/ranger" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "ranger", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring("Labels []uuid.UUID `json:\"labels\" msgpack:\"labels\"`"))
			Expect(content).To(ContainSubstring("Tags []string `json:\"tags\" msgpack:\"tags\"`"))
		})

		It("Should handle optional array types without pointer", func() {
			source := `
				struct Range {
					field key uuid
					field tags string[]?
					domain go { output "core/ranger" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "ranger", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			// Optional arrays are just slices (nil is the zero value), not pointers to slices
			Expect(content).To(ContainSubstring("Tags []string `json:\"tags,omitempty\" msgpack:\"tags,omitempty\"`"))
		})

		It("Should convert snake_case to PascalCase for field names", func() {
			source := `
				struct Range {
					field created_at timestamp
					field time_range string
					field my_long_field_name string
					domain go { output "core/ranger" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "ranger", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`CreatedAt telem.TimeStamp`))
			Expect(content).To(ContainSubstring(`TimeRange string`))
			Expect(content).To(ContainSubstring(`MyLongFieldName string`))
		})

		It("Should handle all primitive type mappings", func() {
			source := `
				struct AllTypes {
					field a uuid
					field b string
					field c bool
					field d int8
					field e int16
					field f int32
					field g int64
					field h uint8
					field i uint16
					field j uint32
					field k uint64
					field l float32
					field m float64
					field n timestamp
					field o timespan
					field p time_range
					field q json
					field r bytes
					domain go { output "core/test" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "test", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`A uuid.UUID`))
			Expect(content).To(ContainSubstring(`B string`))
			Expect(content).To(ContainSubstring(`C bool`))
			Expect(content).To(ContainSubstring(`D int8`))
			Expect(content).To(ContainSubstring(`E int16`))
			Expect(content).To(ContainSubstring(`F int32`))
			Expect(content).To(ContainSubstring(`G int64`))
			Expect(content).To(ContainSubstring(`H uint8`))
			Expect(content).To(ContainSubstring(`I uint16`))
			Expect(content).To(ContainSubstring(`J uint32`))
			Expect(content).To(ContainSubstring(`K uint64`))
			Expect(content).To(ContainSubstring(`L float32`))
			Expect(content).To(ContainSubstring(`M float64`))
			Expect(content).To(ContainSubstring(`N telem.TimeStamp`))
			Expect(content).To(ContainSubstring(`O telem.TimeSpan`))
			Expect(content).To(ContainSubstring(`P telem.TimeRange`))
			Expect(content).To(ContainSubstring(`Q map[string]any`))
			Expect(content).To(ContainSubstring(`R []byte`))
			Expect(content).To(ContainSubstring(`"github.com/google/uuid"`))
			Expect(content).To(ContainSubstring(`"github.com/synnaxlabs/x/telem"`))
		})

		It("Should skip structs without go domain", func() {
			source := `
				struct User {
					field key uuid
					field name string
					domain ts { output "client/ts/user" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(BeEmpty())
		})

		It("Should derive package name from output path", func() {
			source := `
				struct User {
					field key uuid
					domain go { output "core/pkg/service/user" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(HaveLen(1))
			Expect(resp.Files[0].Path).To(Equal("core/pkg/service/user/types.gen.go"))

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`package user`))
		})

		It("Should group multiple structs by output path", func() {
			source := `
				struct User {
					field key uuid
					field name string
					domain go { output "core/user" }
				}

				struct Role {
					field key uuid
					field name string
					domain go { output "core/user" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(HaveLen(1))

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`type User struct {`))
			Expect(content).To(ContainSubstring(`type Role struct {`))
		})

		It("Should generate empty struct", func() {
			source := `
				struct Empty {
					domain go { output "core/empty" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "empty", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(HaveLen(1))

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`type Empty struct {`))
			Expect(content).To(ContainSubstring(`}`))
		})

		It("Should not include import block when no imports needed", func() {
			source := `
				struct Simple {
					field name string
					field count int32
					domain go { output "core/simple" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "simple", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).NotTo(ContainSubstring(`import (`))
		})

		It("Should generate doc comments from doc domain", func() {
			source := `
				struct User {
					domain doc { value "A User is a representation of a user in the Synnax cluster." }

					field key uuid {
						domain id
						domain doc { value "Key is the unique identifier for the user." }
					}

					field username string {
						domain doc { value "Username is the unique username for the user." }
					}

					field first_name string

					domain go { output "core/user" }
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := goPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(HaveLen(1))

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`// A User is a representation of a user in the Synnax cluster.`))
			Expect(content).To(ContainSubstring(`// Key is the unique identifier for the user.`))
			Expect(content).To(ContainSubstring(`// Username is the unique username for the user.`))
			// first_name has no doc, so no comment for it
			Expect(content).NotTo(ContainSubstring(`// FirstName`))
		})
	})
})
