// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package types_test

import (
	"context"
	"strings"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/synnaxlabs/oracle/analyzer"
	"github.com/synnaxlabs/oracle/plugin"
	"github.com/synnaxlabs/oracle/plugin/go/types"
	"github.com/synnaxlabs/oracle/testutil"
)

func TestGoTypes(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Go Types Plugin Suite")
}

var _ = Describe("Go Types Plugin", func() {
	var (
		ctx      context.Context
		loader   *testutil.MockFileLoader
		goPlugin *types.Plugin
	)

	BeforeEach(func() {
		ctx = context.Background()
		loader = testutil.NewMockFileLoader()
		goPlugin = types.New(types.DefaultOptions())
	})

	Describe("Plugin Interface", func() {
		It("Should have correct name", func() {
			Expect(goPlugin.Name()).To(Equal("go/types"))
		})

		It("Should filter on go domain", func() {
			Expect(goPlugin.Domains()).To(Equal([]string{"go"}))
		})

		It("Should have no dependencies", func() {
			Expect(goPlugin.Requires()).To(BeNil())
		})
	})

	Describe("Generate", func() {
		Context("basic struct generation", func() {
			It("Should generate struct for simple types", func() {
				source := `
					@go output "core/pkg/service/user"

					User struct {
						key uuid
						name string
						age int32
						active bool
					}
				`
				resp := testutil.MustGenerate(ctx, source, "user", loader, goPlugin)
				Expect(resp.Files).To(HaveLen(1))

				testutil.ExpectContent(resp, "types.gen.go").
					ToContain(
						"// Code generated by oracle. DO NOT EDIT.",
						"package user",
						`"github.com/synnaxlabs/x/uuid"`,
						"type User struct {",
						"Key uuid.UUID `json:\"key\" msgpack:\"key\"`",
						"Name string `json:\"name\" msgpack:\"name\"`",
						"Age int32 `json:\"age\" msgpack:\"age\"`",
						"Active bool `json:\"active\" msgpack:\"active\"`",
					)
			})
		})

		Context("array types", func() {
			It("Should handle array types", func() {
				source := `
				@go output "core/ranger"

				Range struct {
					key uuid
					labels uuid[]
					tags string[]
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "ranger", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring("Labels []uuid.UUID `json:\"labels\" msgpack:\"labels\"`"))
				Expect(content).To(ContainSubstring("Tags []string `json:\"tags\" msgpack:\"tags\"`"))
			})

		})

		Context("naming conventions", func() {
			It("Should convert snake_case to PascalCase for field names", func() {
				source := `
				@go output "core/ranger"

				Range struct {
					created_at int64
					time_range string
					my_long_field_name string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "ranger", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`CreatedAt int64`))
				Expect(content).To(ContainSubstring(`TimeRange string`))
				Expect(content).To(ContainSubstring(`MyLongFieldName string`))
			})

			It("Should preserve screaming case (all-uppercase) field names but use snake_case for JSON tags", func() {
				source := `
				@go output "core/compiler"

				Output struct {
					WASM bytes
					IR   string
					CPU_ID uint32
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "compiler", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Screaming case fields should preserve their Go names
				Expect(content).To(ContainSubstring(`WASM []byte`))
				Expect(content).To(ContainSubstring(`IR string`))
				Expect(content).To(ContainSubstring(`CPU_ID uint32`))
				// JSON tags should use snake_case (all lowercase)
				Expect(content).To(ContainSubstring(`json:"wasm"`))
				Expect(content).To(ContainSubstring(`json:"ir"`))
				Expect(content).To(ContainSubstring(`json:"cpu_id"`))
			})

		})

		Context("primitive type mappings", func() {
			DescribeTable("should generate correct Go type",
				func(oracleType, expectedGoType string) {
					source := `
						@go output "core/test"

						Test struct {
							field ` + oracleType + `
						}
					`
					resp := testutil.MustGenerate(ctx, source, "test", loader, goPlugin)
					testutil.ExpectContent(resp, "types.gen.go").ToContain(expectedGoType)
				},
				Entry("uuid", "uuid", "Field uuid.UUID"),
				Entry("string", "string", "Field string"),
				Entry("bool", "bool", "Field bool"),
				Entry("int8", "int8", "Field int8"),
				Entry("int16", "int16", "Field int16"),
				Entry("int32", "int32", "Field int32"),
				Entry("int64", "int64", "Field int64"),
				Entry("uint8", "uint8", "Field uint8"),
				Entry("uint16", "uint16", "Field uint16"),
				Entry("uint32", "uint32", "Field uint32"),
				Entry("uint64", "uint64", "Field uint64"),
				Entry("float32", "float32", "Field float32"),
				Entry("float64", "float64", "Field float64"),
				Entry("json", "json", "Field map[string]any"),
				Entry("bytes", "bytes", "Field []byte"),
			)

			It("Should import required packages for special types", func() {
				source := `
					@go output "core/test"

					AllTypes struct {
						a uuid
						b json
					}
				`
				resp := testutil.MustGenerate(ctx, source, "test", loader, goPlugin)
				testutil.ExpectContent(resp, "types.gen.go").
					ToContain(`"github.com/synnaxlabs/x/uuid"`)
			})
		})

		Context("skipping", func() {
			It("Should skip structs without go domain", func() {
				source := `
				@ts output "client/ts/user"

				User struct {
					key uuid
					name string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())
				Expect(resp.Files).To(BeEmpty())
			})

			It("Should skip omitted structs", func() {
				source := `
					@go output "core/status"

					Status struct {
						key uuid
						message string

						@go omit
					}

					Other struct {
						key uuid
						name string
					}
				`
				table, diag := analyzer.AnalyzeSource(ctx, source, "status", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Status should be skipped
				Expect(content).NotTo(ContainSubstring(`type Status struct {`))
				// Other should still be generated
				Expect(content).To(ContainSubstring(`type Other struct {`))
			})
		})

		Context("output organization", func() {
			It("Should derive package name from output path", func() {
				source := `
				@go output "core/pkg/service/user"

				User struct {
					key uuid
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())
				Expect(resp.Files).To(HaveLen(1))
				Expect(resp.Files[0].Path).To(Equal("core/pkg/service/user/types.gen.go"))

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`package user`))
			})

			It("Should group multiple structs by output path", func() {
				source := `
				@go output "core/user"

				User struct {
					key uuid
					name string
				}

				Role struct {
					key uuid
					name string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())
				Expect(resp.Files).To(HaveLen(1))

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`type User struct {`))
				Expect(content).To(ContainSubstring(`type Role struct {`))
			})

			It("Should generate empty struct", func() {
				source := `
				@go output "core/empty"

				Empty struct {
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "empty", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())
				Expect(resp.Files).To(HaveLen(1))

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`type Empty struct {`))
				Expect(content).To(ContainSubstring(`}`))
			})

			It("Should not include import block when no imports needed", func() {
				source := `
				@go output "core/simple"

				Simple struct {
					name string
					count int32
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "simple", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).NotTo(ContainSubstring(`import (`))
			})

		})

		Context("documentation", func() {
			It("Should generate doc comments from doc domain", func() {
				source := `
				@go output "core/user"

				User struct {
					@doc value "A User is a representation of a user in the Synnax cluster."

					key uuid @key {
						@doc value "Key is the unique identifier for the user."
					}

					username string {
						@doc value "Username is the unique username for the user."
					}

					first_name string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())
				Expect(resp.Files).To(HaveLen(1))

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`// A User is a representation of a user in the Synnax cluster.`))
				Expect(content).To(ContainSubstring(`// Key is the unique identifier for the user.`))
				Expect(content).To(ContainSubstring(`// Username is the unique username for the user.`))
				// first_name has no doc, so no comment for it
				Expect(content).NotTo(ContainSubstring(`// FirstName`))
			})

		})

		Context("enums", func() {
			It("Should generate string enum type and constants", func() {
				source := `
				@go output "core/status"

				Variant enum {
					success = "success"
					warning = "warning"
					error = "error"
				}

				Status struct {
					variant Variant
					message string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "status", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`type Variant string`))
				Expect(content).To(ContainSubstring(`VariantSuccess Variant = "success"`))
				Expect(content).To(ContainSubstring(`VariantWarning Variant = "warning"`))
				Expect(content).To(ContainSubstring(`VariantError Variant = "error"`))
				Expect(content).To(ContainSubstring(`Variant Variant`))
			})

			It("Should generate int enum type and iota constants", func() {
				source := `
				@go output "core/priority"

				Priority enum {
					low = 0
					medium = 1
					high = 2
				}

				Task struct {
					priority Priority
					name string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "priority", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`type Priority uint8`))
				Expect(content).To(ContainSubstring(`PriorityLow Priority = iota`))
				Expect(content).To(ContainSubstring(`PriorityMedium`))
				Expect(content).To(ContainSubstring(`PriorityHigh`))
			})

		})

		Context("map types", func() {
			It("Should generate map types", func() {
				source := `
				@go output "core/config"

				Config struct {
					settings map<string, string>
					counts map<string, int32>
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "config", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`Settings map[string]string`))
				Expect(content).To(ContainSubstring(`Counts map[string]int32`))
			})

		})

		Context("generics", func() {
			It("Should generate generic struct with type parameters", func() {
				source := `
				@go output "core/container"

				Box struct<T> {
					value T
					label string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "container", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`type Box[T any] struct {`))
				Expect(content).To(ContainSubstring(`Value T`))
			})

			It("Should generate generic struct with constrained type parameter", func() {
				source := `
				@go output "core/container"

				Container struct<D extends json> {
					data D
					name string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "container", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`type Container[D any] struct {`))
				Expect(content).To(ContainSubstring(`Data D`))
			})

		})

		Context("type aliases", func() {
			It("Should generate type alias", func() {
				source := `
				@go output "core/alias"

				Original struct {
					key uuid
					name string
				}

				Alias = Original
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "alias", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`type Original struct {`))
				Expect(content).To(ContainSubstring(`type Alias = Original`))
			})

			It("Should generate type alias for array types", func() {
				source := `
				@go output "core/ir"

				Stratum = string[]
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "ir", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Stratum should be an alias to []string, not just string
				Expect(content).To(ContainSubstring(`type Stratum = []string`))
				Expect(content).NotTo(ContainSubstring(`type Stratum = string`))
			})

		})

		Context("type references", func() {
			It("Should resolve same-namespace struct references", func() {
				source := `
				@go output "core/user"

				Address struct {
					street string
					city string
				}

				User struct {
					key uuid
					name string
					address Address?
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`type Address struct {`))
				Expect(content).To(ContainSubstring(`type User struct {`))
				Expect(content).To(ContainSubstring(`Address Address`))
			})

			It("Should resolve cross-namespace struct references with imports", func() {
				loader.Add("schemas/status.oracle", `
				@go output "core/status"

				Status struct {
					key uuid
					message string
				}
			`)

				source := `
				import "schemas/status"

				@go output "core/task"

				Task struct {
					key uuid
					name string
					status status.Status?
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "task", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())
				Expect(resp.Files).To(HaveLen(2))

				// Find the task file
				var taskContent string
				for _, f := range resp.Files {
					if f.Path == "core/task/types.gen.go" {
						taskContent = string(f.Content)
						break
					}
				}
				Expect(taskContent).NotTo(BeEmpty())
				Expect(taskContent).To(ContainSubstring(`"github.com/synnaxlabs/synnax/core/status"`))
				Expect(taskContent).To(ContainSubstring(`Status status.Status`))
			})

			It("Should resolve cross-namespace enum references with imports", func() {
				loader.Add("schemas/status.oracle", `
				@go output "core/status"

				Variant enum {
					success = "success"
					error = "error"
				}

				Status struct {
					variant Variant
				}
			`)

				source := `
				import "schemas/status"

				@go output "core/task"

				Task struct {
					key uuid
					variant status.Variant
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "task", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				// Find the task file
				var taskContent string
				for _, f := range resp.Files {
					if f.Path == "core/task/types.gen.go" {
						taskContent = string(f.Content)
						break
					}
				}
				Expect(taskContent).NotTo(BeEmpty())
				Expect(taskContent).To(ContainSubstring(`"github.com/synnaxlabs/synnax/core/status"`))
				Expect(taskContent).To(ContainSubstring(`Variant status.Variant`))
			})

		})

		Context("struct embedding (extends)", func() {
			It("Should generate struct embedding for basic extends", func() {
				source := `
				@go output "core/user"

				Parent struct {
					name string
					age int32
				}

				Child struct extends Parent {
					email string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Parent struct should be normal
				Expect(content).To(ContainSubstring(`type Parent struct {`))
				Expect(content).To(ContainSubstring(`Name string`))
				Expect(content).To(ContainSubstring(`Age int32`))

				// Child should use struct embedding
				Expect(content).To(ContainSubstring(`type Child struct {`))
				Expect(content).To(ContainSubstring("\tParent\n"))
				Expect(content).To(ContainSubstring(`Email string`))
			})

			It("Should flatten fields when extends has omitted fields", func() {
				source := `
				@go output "core/user"

				Parent struct {
					name string
					age int32
					status string
				}

				Child struct extends Parent {
					-age
					email string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Child should have flattened fields (no embedding due to omission)
				Expect(content).To(ContainSubstring(`type Child struct {`))
				Expect(content).NotTo(ContainSubstring("\tParent\n"))
				Expect(content).To(ContainSubstring(`Name string`))
				Expect(content).To(ContainSubstring(`Status string`))
				Expect(content).To(ContainSubstring(`Email string`))
				// Age should NOT be present (omitted)
				Expect(content).NotTo(MatchRegexp(`Child struct \{[^}]*Age`))
			})

			It("Should generate cross-namespace struct embedding with import", func() {
				loader.Add("schemas/parent.oracle", `
				@go output "core/parent"

				Parent struct {
					name string
					age int32
				}
			`)

				source := `
				import "schemas/parent"

				@go output "core/child"

				Child struct extends parent.Parent {
					email string
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "child", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				// Find the child file
				var childContent string
				for _, f := range resp.Files {
					if f.Path == "core/child/types.gen.go" {
						childContent = string(f.Content)
						break
					}
				}
				Expect(childContent).NotTo(BeEmpty())
				Expect(childContent).To(ContainSubstring(`"github.com/synnaxlabs/synnax/core/parent"`))
				Expect(childContent).To(ContainSubstring(`type Child struct {`))
				Expect(childContent).To(ContainSubstring("\tparent.Parent\n"))
				Expect(childContent).To(ContainSubstring(`Email string`))
			})

			It("Should generate struct embedding for generic parent with type args", func() {
				source := `
				@go output "core/status"

				Details struct {
					message string
				}

				Status struct<D extends json> {
					variant int32
					data D
				}

				RackStatus struct extends Status<Details> {
					timestamp int64
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "status", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// RackStatus should embed Status with type argument
				Expect(content).To(ContainSubstring(`type RackStatus struct {`))
				Expect(content).To(ContainSubstring("\tStatus[Details]\n"))
				Expect(content).To(ContainSubstring(`Timestamp int64`))
			})

			It("Should generate generic child extending generic parent with passed type param", func() {
				source := `
				@go output "core/status"

				Status struct<D extends json> {
					variant int32
					data D
				}

				RackStatus struct<D extends json> extends Status<D> {
					timestamp int64
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "status", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// RackStatus should be generic and embed Status with passed type param
				Expect(content).To(ContainSubstring(`type RackStatus[D any] struct {`))
				Expect(content).To(ContainSubstring("\tStatus[D]\n"))
				Expect(content).To(ContainSubstring(`Timestamp int64`))
			})

			It("Should generate multiple embedding for multiple extends without conflicts", func() {
				source := `
				@go output "core/entities"

				A struct {
					a string
				}

				B struct {
					b int32
				}

				C struct extends A, B {
					c bool
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "entities", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// C should embed both A and B
				Expect(content).To(ContainSubstring(`type C struct {`))
				Expect(content).To(ContainSubstring("\tA\n"))
				Expect(content).To(ContainSubstring("\tB\n"))
				Expect(content).To(ContainSubstring(`C bool`))
			})

			It("Should flatten fields when multiple extends have field conflicts", func() {
				source := `
				@go output "core/entities"

				A struct {
					shared string
					a int32
				}

				B struct {
					shared string
					b int32
				}

				C struct extends A, B {
					c bool
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "entities", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// C should have flattened fields (no embedding due to conflict)
				Expect(content).To(ContainSubstring(`type C struct {`))
				Expect(content).NotTo(ContainSubstring("\tA\n"))
				Expect(content).NotTo(ContainSubstring("\tB\n"))
				Expect(content).To(ContainSubstring(`Shared string`))
				Expect(content).To(ContainSubstring(`A int32`))
				Expect(content).To(ContainSubstring(`B int32`))
				Expect(content).To(ContainSubstring(`C bool`))
			})

			It("Should flatten fields when multiple extends has omitted fields", func() {
				source := `
				@go output "core/entities"

				A struct {
					a string
					shared string
				}

				B struct {
					b int32
				}

				C struct extends A, B {
					-shared
					c bool
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "entities", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// C should have flattened fields (no embedding due to omission)
				Expect(content).To(ContainSubstring(`type C struct {`))
				Expect(content).NotTo(ContainSubstring("\tA\n"))
				Expect(content).NotTo(ContainSubstring("\tB\n"))
				Expect(content).To(ContainSubstring(`A string`))
				Expect(content).To(ContainSubstring(`B int32`))
				Expect(content).To(ContainSubstring(`C bool`))
				// shared should NOT be present (omitted)
				Expect(content).NotTo(MatchRegexp(`C struct \{[^}]*Shared`))
			})

		})

		Context("declaration ordering", func() {
			It("Should preserve struct declaration order", func() {
				source := `
				@go output "core/animals"

				Zebra struct {
					name string
				}

				Apple struct {
					color string
				}

				Mango struct {
					ripe bool
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "animals", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				zebraIdx := strings.Index(content, "type Zebra struct")
				appleIdx := strings.Index(content, "type Apple struct")
				mangoIdx := strings.Index(content, "type Mango struct")
				Expect(zebraIdx).To(BeNumerically("<", appleIdx))
				Expect(appleIdx).To(BeNumerically("<", mangoIdx))
			})

			It("Should preserve field declaration order", func() {
				source := `
				@go output "core/order"

				Record struct {
					zebra string
					apple int32
					mango bool
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "order", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				zebraIdx := strings.Index(content, "Zebra string")
				appleIdx := strings.Index(content, "Apple int32")
				mangoIdx := strings.Index(content, "Mango bool")
				Expect(zebraIdx).To(BeNumerically("<", appleIdx))
				Expect(appleIdx).To(BeNumerically("<", mangoIdx))
			})
		})

		Context("hard optional fields", func() {
			It("Should generate pointer type with omitempty for hard optional fields", func() {
				source := `
				@go output "core/user"

				User struct {
					key uuid
					name string
					nickname string??
					age int32??
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Required fields should not have omitempty
				Expect(content).To(ContainSubstring("Key uuid.UUID `json:\"key\" msgpack:\"key\"`"))
				Expect(content).To(ContainSubstring("Name string `json:\"name\" msgpack:\"name\"`"))
				// Hard optional fields should have pointer type and omitempty
				Expect(content).To(ContainSubstring("Nickname *string `json:\"nickname,omitempty\" msgpack:\"nickname,omitempty\"`"))
				Expect(content).To(ContainSubstring("Age *int32 `json:\"age,omitempty\" msgpack:\"age,omitempty\"`"))
			})

			It("Should not use pointer for hard optional arrays", func() {
				source := `
				@go output "core/config"

				Config struct {
					tags string[]??
					counts int32[]??
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "config", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Arrays should not be pointers but should still have omitempty
				Expect(content).To(ContainSubstring("Tags []string `json:\"tags,omitempty\" msgpack:\"tags,omitempty\"`"))
				Expect(content).To(ContainSubstring("Counts []int32 `json:\"counts,omitempty\" msgpack:\"counts,omitempty\"`"))
			})

			It("Should not use pointer for hard optional maps", func() {
				source := `
				@go output "core/config"

				Config struct {
					settings map<string, string>??
				}
			`
				table, diag := analyzer.AnalyzeSource(ctx, source, "config", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Maps should not be pointers but should still have omitempty
				Expect(content).To(ContainSubstring("Settings map[string]string `json:\"settings,omitempty\" msgpack:\"settings,omitempty\"`"))
			})

		})

		Context("regression tests", func() {
			It("Should use snake_case for JSON struct tags regardless of field name casing", func() {
				// Regression test: JSON tags should always be snake_case, regardless of
				// whether the field name is PascalCase, camelCase, or SCREAMING_CASE.
				source := `
					@go output "arc/go/compiler"

					Output struct {
						WASM bytes
						OutputMemoryBases map<string, uint32>
						camelCaseField string
						PascalCaseField int32
						already_snake_case bool
					}
				`
				table, diag := analyzer.AnalyzeSource(ctx, source, "compiler", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// All JSON tags should be snake_case
				Expect(content).To(ContainSubstring(`json:"wasm"`))
				Expect(content).To(ContainSubstring(`json:"output_memory_bases"`))
				Expect(content).To(ContainSubstring(`json:"camel_case_field"`))
				Expect(content).To(ContainSubstring(`json:"pascal_case_field"`))
				Expect(content).To(ContainSubstring(`json:"already_snake_case"`))
			})

			It("Should use alias type name in struct fields instead of expanded target", func() {
				// Regression test: When a struct field references a type alias,
				// the generated code should use the alias name, not expand to the target type.
				source := `
					@go output "core/rack"

					StatusDetails struct {
						rack uint32
					}

					// Alias to a local struct type
					Details = StatusDetails

					Payload struct {
						key uint32
						details Details
					}
				`
				table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Should use the alias name "Details", not expanded "StatusDetails"
				Expect(content).To(ContainSubstring("Details Details"))
				Expect(content).NotTo(MatchRegexp(`Details\s+StatusDetails`))
			})

			It("Should use distinct type name in struct fields", func() {
				// Regression test: When a struct field references a distinct type,
				// the generated code should use the distinct type name, not the underlying primitive.
				source := `
					@go output "core/channel"

					Key int

					Channel struct {
						key Key
						name string
					}
				`
				table, diag := analyzer.AnalyzeSource(ctx, source, "channel", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// Should use the distinct type name "Key", not expanded "int"
				Expect(content).To(ContainSubstring("Key Key"))
				Expect(content).NotTo(MatchRegexp(`Key\s+int`))
			})

			It("Should respect @go name directive for embedded parent types", func() {
				// Regression test: When a struct extends a parent with @go name directive,
				// the generated embedded field should use the Go-specific name, not the schema name.
				loader.Add("schemas/compiler.oracle", `
					@go output "arc/go/compiler"

					CompilerOutput struct {
						WASM bytes
						OutputMemoryBases map<string, uint32>

						@go name "Output"
					}
				`)

				source := `
					import "schemas/compiler"

					@go output "arc/go/module"

					Module struct extends compiler.CompilerOutput {
						name string
					}
				`
				table, diag := analyzer.AnalyzeSource(ctx, source, "module", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				// Find the module file
				var moduleContent string
				for _, f := range resp.Files {
					if f.Path == "arc/go/module/types.gen.go" {
						moduleContent = string(f.Content)
						break
					}
				}
				Expect(moduleContent).NotTo(BeEmpty())
				// Should use @go name "Output", not schema name "CompilerOutput"
				Expect(moduleContent).To(ContainSubstring("compiler.Output"))
				Expect(moduleContent).NotTo(ContainSubstring("compiler.CompilerOutput"))
			})

			It("Should respect @go name directive for same-namespace embedded types", func() {
				// Regression test: When a struct extends a parent with @go name in same namespace,
				// the generated embedded field should use the Go-specific name.
				source := `
					@go output "arc/go/ir"

					InternalIR struct {
						nodes string[]

						@go name "IR"
					}

					ExtendedIR struct extends InternalIR {
						metadata string
					}
				`
				table, diag := analyzer.AnalyzeSource(ctx, source, "ir", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				content := string(resp.Files[0].Content)
				// The parent type should be named "IR" (from @go name), not "InternalIR"
				Expect(content).To(ContainSubstring("type IR struct {"))
				// The child should embed "IR", not "InternalIR"
				Expect(content).To(ContainSubstring("type ExtendedIR struct {"))
				Expect(content).To(ContainSubstring("\tIR\n"))
				Expect(content).NotTo(ContainSubstring("\tInternalIR\n"))
			})

		})

		Context("extra fields and imports", func() {
			It("Should add extra fields from @go fields directive", func() {
				source := `
					@go output "arc/go/ir"

					IR struct {
						functions string[]
						nodes     string[]

						@go fields "Symbols *symbol.Scope ` + "`" + `json:\"-\"` + "`" + `" "TypeMap map[string]any ` + "`" + `json:\"-\"` + "`" + `"
						@go imports "github.com/synnaxlabs/arc/symbol"
					}
				`
				resp := testutil.MustGenerate(ctx, source, "ir", loader, goPlugin)
				Expect(resp.Files).To(HaveLen(1))

				testutil.ExpectContent(resp, "types.gen.go").
					ToContain(
						"package ir",
						"type IR struct {",
						"Functions []string",
						"Nodes []string",
						`Symbols *symbol.Scope `+"`"+`json:"-"`+"`",
						`TypeMap map[string]any `+"`"+`json:"-"`+"`",
						`"github.com/synnaxlabs/arc/symbol"`,
					)
			})

			It("Should add multiple extra imports from @go imports directive", func() {
				source := `
					@go output "arc/go/ir"

					Node struct {
						key string

						@go fields "AST antlr.ParserRuleContext ` + "`" + `json:\"-\"` + "`" + `"
						@go imports "github.com/antlr4-go/antlr/v4" "github.com/custom/package"
					}
				`
				resp := testutil.MustGenerate(ctx, source, "ir", loader, goPlugin)
				Expect(resp.Files).To(HaveLen(1))

				content := string(resp.Files[0].Content)
				Expect(content).To(ContainSubstring(`"github.com/antlr4-go/antlr/v4"`))
				Expect(content).To(ContainSubstring(`"github.com/custom/package"`))
			})

			It("Should not duplicate imports when package is in both @go imports and type references", func() {
				// Regression test: When a package is imported via @go imports AND
				// also needed for resolving cross-namespace type references,
				// the generated code should only include the import once.
				loader.Add("schemas/types.oracle", `
					@go output "arc/go/types"

					Param struct {
						name string
						value json?
					}

					Params Param[]
				`)

				source := `
					import "schemas/types"

					@go output "arc/go/ir"

					Function struct {
						key string
						config types.Params?

						@go imports "github.com/synnaxlabs/synnax/arc/go/types"
					}
				`
				table, diag := analyzer.AnalyzeSource(ctx, source, "ir", loader)
				Expect(diag.HasErrors()).To(BeFalse())

				req := &plugin.Request{
					Resolutions: table,
				}

				resp, err := goPlugin.Generate(req)
				Expect(err).To(BeNil())

				// Find the ir file
				var irContent string
				for _, f := range resp.Files {
					if f.Path == "arc/go/ir/types.gen.go" {
						irContent = string(f.Content)
						break
					}
				}
				Expect(irContent).NotTo(BeEmpty())

				// The types import should only appear once
				importCount := strings.Count(irContent, `"github.com/synnaxlabs/synnax/arc/go/types"`)
				Expect(importCount).To(Equal(1), "Import should appear exactly once, got: %d", importCount)
			})
		})
	})
})
