// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Package marshal provides an Oracle plugin that generates gorp.Codec implementations
// in the pb/ subdirectory. Each codec uses the existing protobuf ToPB/FromPB
// translators generated by the go/pb plugin.
package marshal

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/samber/lo"
	"github.com/synnaxlabs/oracle/exec"
	"github.com/synnaxlabs/oracle/plugin"
	"github.com/synnaxlabs/oracle/plugin/go/internal/naming"
	"github.com/synnaxlabs/oracle/plugin/output"
	"github.com/synnaxlabs/oracle/resolution"
	"github.com/synnaxlabs/x/errors"
)

// Plugin generates gorp.Codec implementations for structs annotated with @go marshal.
type Plugin struct{ Options Options }

// Options configures the go/marshal plugin.
type Options struct {
	FileNamePattern string
}

// DefaultOptions returns the default plugin options.
func DefaultOptions() Options {
	return Options{FileNamePattern: "codec.gen.go"}
}

// New creates a new go/marshal plugin with the given options.
func New(opts Options) *Plugin { return &Plugin{Options: opts} }

func (p *Plugin) Name() string                { return "go/marshal" }
func (p *Plugin) Domains() []string           { return []string{"go"} }
func (p *Plugin) Requires() []string          { return []string{"go/types", "go/pb"} }
func (p *Plugin) Check(*plugin.Request) error { return nil }

var goPostWriter = &exec.PostWriter{
	Extensions: []string{".go"},
	Commands:   [][]string{{"gofmt", "-w"}},
}

func (p *Plugin) PostWrite(files []string) error {
	return goPostWriter.PostWrite(files)
}

func hasMarshalAnnotation(typ resolution.Type) bool {
	domain, ok := typ.Domains["go"]
	if !ok {
		return false
	}
	for _, expr := range domain.Expressions {
		if expr.Name == "marshal" {
			return true
		}
	}
	return false
}

func getGoName(s resolution.Type) string {
	if domain, ok := s.Domains["go"]; ok {
		for _, expr := range domain.Expressions {
			if expr.Name == "name" && len(expr.Values) > 0 {
				return expr.Values[0].StringValue
			}
		}
	}
	return ""
}

func getPBName(s resolution.Type) string {
	if domain, ok := s.Domains["pb"]; ok {
		for _, expr := range domain.Expressions {
			if expr.Name == "name" && len(expr.Values) > 0 {
				return expr.Values[0].StringValue
			}
		}
	}
	return ""
}

type codecEntry struct {
	GoName      string
	PBName      string
	ParentAlias string
	ParentPath  string
}

func (p *Plugin) Generate(req *plugin.Request) (*plugin.Response, error) {
	resp := &plugin.Response{Files: make([]plugin.File, 0)}

	outputEntries := make(map[string][]codecEntry)
	var outputOrder []string

	for _, entry := range req.Resolutions.StructTypes() {
		if !hasMarshalAnnotation(entry) {
			continue
		}
		if !output.HasPB(entry) {
			continue
		}
		goPath := output.GetPath(entry, "go")
		if goPath == "" {
			continue
		}
		pbPath := goPath + "/pb"
		if req.RepoRoot != "" {
			if err := req.ValidateOutputPath(pbPath); err != nil {
				return nil, errors.Wrapf(err, "invalid output path for %s", entry.Name)
			}
		}

		goName := getGoName(entry)
		if goName == "" {
			goName = entry.Name
		}
		pbName := getPBName(entry)
		if pbName == "" {
			pbName = entry.Name
		}
		parentAlias := naming.DerivePackageAlias(goPath, "pb")

		if _, exists := outputEntries[pbPath]; !exists {
			outputOrder = append(outputOrder, pbPath)
		}
		outputEntries[pbPath] = append(outputEntries[pbPath], codecEntry{
			GoName:      goName,
			PBName:      pbName,
			ParentAlias: parentAlias,
			ParentPath:  goPath,
		})
	}

	for _, pbPath := range outputOrder {
		entries := outputEntries[pbPath]
		content, err := p.generateFile(pbPath, entries, req)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to generate %s", pbPath)
		}
		if len(content) > 0 {
			resp.Files = append(resp.Files, plugin.File{
				Path:    fmt.Sprintf("%s/%s", pbPath, p.Options.FileNamePattern),
				Content: content,
			})
		}
	}

	return resp, nil
}

type codecData struct {
	GoName      string
	PBName      string
	ParentAlias string
}

type templateData struct {
	Package          string
	Codecs           []codecData
	ParentAlias      string
	ParentImportPath string
}

func (p *Plugin) generateFile(
	pbPath string,
	entries []codecEntry,
	req *plugin.Request,
) ([]byte, error) {
	if len(entries) == 0 {
		return nil, nil
	}

	parentAlias := entries[0].ParentAlias
	parentGoPath := entries[0].ParentPath

	parentImportPath, err := resolveGoImportPath(parentGoPath, req.RepoRoot)
	if err != nil {
		return nil, errors.Wrap(err, "failed to resolve parent package import")
	}

	codecs := make([]codecData, len(entries))
	for i, e := range entries {
		codecs[i] = codecData{
			GoName:      e.GoName,
			PBName:      e.PBName,
			ParentAlias: e.ParentAlias,
		}
	}

	data := templateData{
		Package:          "pb",
		Codecs:           codecs,
		ParentAlias:      parentAlias,
		ParentImportPath: parentImportPath,
	}

	tmpl, err := template.New("codec").Funcs(template.FuncMap{
		"lowerFirst": func(s string) string {
			if s == "" {
				return s
			}
			return strings.ToLower(s[:1]) + s[1:]
		},
		"toPascalCase": func(s string) string {
			if naming.IsScreamingCase(s) {
				return s
			}
			return lo.PascalCase(s)
		},
	}).Parse(codecTemplate)
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse template")
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, errors.Wrap(err, "failed to execute template")
	}
	return buf.Bytes(), nil
}

func resolveGoImportPath(outputPath, repoRoot string) (string, error) {
	if repoRoot == "" {
		return "github.com/synnaxlabs/synnax/" + outputPath, nil
	}
	absPath := filepath.Join(repoRoot, outputPath)
	dir := absPath
	for {
		modPath := filepath.Join(dir, "go.mod")
		if fileExists(modPath) {
			moduleName, err := parseModuleName(modPath)
			if err != nil {
				return "", errors.Wrapf(err, "failed to parse go.mod at %s", modPath)
			}
			relPath, err := filepath.Rel(dir, absPath)
			if err != nil {
				return "", errors.Wrapf(err, "failed to compute relative path")
			}
			if relPath == "." {
				return moduleName, nil
			}
			return moduleName + "/" + filepath.ToSlash(relPath), nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "github.com/synnaxlabs/synnax/" + outputPath, nil
}

func parseModuleName(modPath string) (string, error) {
	file, err := os.Open(modPath)
	if err != nil {
		return "", err
	}
	defer func() { _ = file.Close() }()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "module ") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				return parts[1], nil
			}
		}
	}
	return "", errors.New("module name not found in go.mod")
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

const codecTemplate = `// Code generated by oracle. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"google.golang.org/protobuf/proto"

	"github.com/synnaxlabs/x/gorp"

	{{.ParentAlias}} "{{.ParentImportPath}}"
)
{{range .Codecs}}
type {{lowerFirst .GoName}}Codec struct{}

func ({{lowerFirst .GoName}}Codec) Marshal(
	ctx context.Context,
	s {{.ParentAlias}}.{{.GoName}},
) ([]byte, error) {
	p, err := {{toPascalCase .PBName}}ToPB(ctx, s)
	if err != nil {
		return nil, err
	}
	return proto.Marshal(p)
}

func ({{lowerFirst .GoName}}Codec) Unmarshal(
	ctx context.Context,
	data []byte,
) ({{.ParentAlias}}.{{.GoName}}, error) {
	p := &{{toPascalCase .PBName}}{}
	if err := proto.Unmarshal(data, p); err != nil {
		return {{.ParentAlias}}.{{.GoName}}{}, err
	}
	return {{toPascalCase .PBName}}FromPB(ctx, p)
}

var {{.GoName}}Codec gorp.Codec[{{.ParentAlias}}.{{.GoName}}] = {{lowerFirst .GoName}}Codec{}
{{end}}`
