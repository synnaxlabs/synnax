// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package pb

import (
	"strings"
	"text/template"
)

var templateFuncs = template.FuncMap{
	"join": strings.Join,
}

// headerTemplate generates the translator.gen.h file
var headerTemplate = template.Must(template.New("cpp-pb-header").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.

#pragma once
{{- if .HasIncludes}}

{{range .SystemIncludes -}}
#include <{{.}}>
{{end -}}
{{if .SystemIncludes}}
{{end -}}
{{range .InternalIncludes -}}
#include "{{.}}"
{{end}}
{{- end}}
// Forward declarations for protobuf types
namespace api::v1 {
{{- range .Translators}}
class {{.PBName}};
{{- end}}
{{- range .EnumTranslators}}
enum {{.Name}} : int;
{{- end}}
}

namespace {{.PBNamespace}} {
{{- range .EnumTranslators}}

/// @brief Converts a C++ {{.Name}} enum to protobuf.
api::v1::{{.Name}} {{.Name}}ToPB(const std::string& cpp);

/// @brief Converts a protobuf {{.Name}} enum to C++.
std::string {{.Name}}FromPB(api::v1::{{.Name}} pb);
{{- end}}
{{- range .Translators}}

/// @brief Converts a C++ {{.CppName}} to protobuf.
api::v1::{{.PBName}} to_pb(const {{.CppName}}& cpp);

/// @brief Converts a protobuf {{.PBName}} to C++.
{{.CppName}} from_pb(const api::v1::{{.PBName}}& pb);

/// @brief Converts a vector of C++ {{.CppName}} to protobuf.
std::vector<api::v1::{{.PBName}}> to_pb(const std::vector<{{.CppName}}>& cpp);

/// @brief Converts a vector of protobuf {{.PBName}} to C++.
std::vector<{{.CppName}}> from_pb(const std::vector<api::v1::{{.PBName}}>& pb);
{{- end}}

}
`))

// sourceTemplate generates the translator.gen.cpp file
var sourceTemplate = template.Must(template.New("cpp-pb-source").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.
{{if .HasIncludes}}
{{range .SystemIncludes -}}
#include <{{.}}>
{{end -}}
{{range .InternalIncludes -}}
#include "{{.}}"
{{end}}
{{- end}}
namespace {{.PBNamespace}} {
{{- range .EnumTranslators}}

api::v1::{{.Name}} {{.Name}}ToPB(const std::string& cpp) {
{{- range .Values}}
    if (cpp == {{.CppValue}}) return api::v1::{{.PBValue}};
{{- end}}
    return api::v1::{{.PBDefault}};
}

std::string {{.Name}}FromPB(api::v1::{{.Name}} pb) {
    switch (pb) {
{{- range .Values}}
    case api::v1::{{.PBValue}}: return {{.CppValue}};
{{- end}}
    default: return {{.CppDefault}};
    }
}
{{- end}}
{{- range .Translators}}

api::v1::{{.PBName}} to_pb(const {{.CppName}}& cpp) {
    api::v1::{{.PBName}} pb;
{{- range .Fields}}
{{- if .IsOptional}}
    {{.ForwardExpr}};
{{- else if .IsArray}}
    {{.ForwardExpr}};
{{- else}}
    {{.ForwardExpr}};
{{- end}}
{{- end}}
    return pb;
}

{{.CppName}} from_pb(const api::v1::{{.PBName}}& pb) {
    {{.CppName}} cpp;
{{- range .Fields}}
{{- if .IsOptional}}
    {{.BackwardExpr}};
{{- else if .IsArray}}
    {{.BackwardExpr}};
{{- else}}
    {{.BackwardExpr}};
{{- end}}
{{- end}}
    return cpp;
}

std::vector<api::v1::{{.PBName}}> to_pb(const std::vector<{{.CppName}}>& cpp) {
    std::vector<api::v1::{{.PBName}}> pb;
    pb.reserve(cpp.size());
    for (const auto& item : cpp) pb.push_back(to_pb(item));
    return pb;
}

std::vector<{{.CppName}}> from_pb(const std::vector<api::v1::{{.PBName}}>& pb) {
    std::vector<{{.CppName}}> cpp;
    cpp.reserve(pb.size());
    for (const auto& item : pb) cpp.push_back(from_pb(item));
    return cpp;
}
{{- end}}

}
`))
