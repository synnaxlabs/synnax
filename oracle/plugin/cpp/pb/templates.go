// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package pb

import (
	"strings"
	"text/template"
)

var templateFuncs = template.FuncMap{
	"join": strings.Join,
	"needsSemicolon": func(s string) bool {
		trimmed := strings.TrimSpace(s)
		if len(trimmed) == 0 {
			return true
		}
		lastChar := trimmed[len(trimmed)-1]
		return lastChar != '}' && lastChar != ';'
	},
	"lbrace": func() string { return "{" },
}

var protoTemplate = template.Must(template.New("cpp-pb-proto").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.

#pragma once
{{- if .HasIncludes}}

{{range .SystemIncludes -}}
#include <{{.}}>
{{end -}}
{{if .SystemIncludes}}
{{end -}}
{{range .InternalIncludes -}}
#include "{{.}}"
{{end}}
{{- end}}
namespace {{.Namespace}} {
{{- range .EnumTranslators}}
{{$enum := .}}

inline {{.PBNamespace}}::{{.Name}} {{.Name}}ToPB(const std::string& cpp) {
    static const std::unordered_map<std::string, {{.PBNamespace}}::{{.Name}}> kMap = {
{{- range .Values}}
        {{lbrace}}{{.CppValue}}, {{$enum.PBNamespace}}::{{.PBValue}}},
{{- end}}
    };
    auto it = kMap.find(cpp);
    return it != kMap.end() ? it->second : {{.PBNamespace}}::{{.PBDefault}};
}

inline std::string {{.Name}}FromPB({{.PBNamespace}}::{{.Name}} pb) {
    switch (pb) {
{{- range .Values}}
    case {{$enum.PBNamespace}}::{{.PBValue}}: return {{.CppValue}};
{{- end}}
    default: return {{.CppDefault}};
    }
}
{{- end}}
{{- range .Translators}}
{{- if .IsGeneric}}

template <typename {{.TypeParamNames}}>
inline {{.PBNamespace}}::{{.PBName}} {{.CppName}}<{{.TypeParamNames}}>::to_proto() const {
    {{.PBNamespace}}::{{.PBName}} pb;
{{- range .Fields}}
{{- if .IsGenericField}}
    if constexpr (std::is_same_v<{{.TypeParamName}}, x::json::json>) {
        {{.ForwardJSONExpr}}{{if needsSemicolon .ForwardJSONExpr}};{{end}}
    } else {
        {{.ForwardExpr}}{{if needsSemicolon .ForwardExpr}};{{end}}
    }
{{- else}}
    {{.ForwardExpr}}{{if needsSemicolon .ForwardExpr}};{{end}}
{{- end}}
{{- end}}
    return pb;
}

template <typename {{.TypeParamNames}}>
inline std::pair<{{.CppName}}<{{.TypeParamNames}}>, x::errors::Error> {{.CppName}}<{{.TypeParamNames}}>::from_proto(
    const {{.PBNamespace}}::{{.PBName}}& pb
) {
    {{.CppName}}<{{.TypeParamNames}}> cpp;
{{- range .Fields}}
{{- if .IsGenericField}}
    if constexpr (std::is_same_v<{{.TypeParamName}}, x::json::json>) {
        {{.BackwardJSONExpr}}{{if needsSemicolon .BackwardJSONExpr}};{{end}}
    } else {
        {{.BackwardExpr}}{{if needsSemicolon .BackwardExpr}};{{end}}
    }
{{- else}}
    {{.BackwardExpr}}{{if needsSemicolon .BackwardExpr}};{{end}}
{{- end}}
{{- end}}
    return {cpp, x::errors::NIL};
}
{{- else if .HasExtends}}

inline {{.PBNamespace}}::{{.PBName}} {{.CppName}}::to_proto() const {
    {{.PBNamespace}}::{{.PBName}} pb;
{{- range .AllFields}}
    {{.ForwardExpr}}{{if needsSemicolon .ForwardExpr}};{{end}}
{{- end}}
    return pb;
}

inline std::pair<{{.CppName}}, x::errors::Error> {{.CppName}}::from_proto(
    const {{.PBNamespace}}::{{.PBName}}& pb
) {
    {{.CppName}} cpp;
{{- range .AllFields}}
    {{.BackwardExpr}}{{if needsSemicolon .BackwardExpr}};{{end}}
{{- end}}
    return {cpp, x::errors::NIL};
}
{{- else}}

inline {{.PBNamespace}}::{{.PBName}} {{.CppName}}::to_proto() const {
    {{.PBNamespace}}::{{.PBName}} pb;
{{- range .Fields}}
    {{.ForwardExpr}}{{if needsSemicolon .ForwardExpr}};{{end}}
{{- end}}
    return pb;
}

inline std::pair<{{.CppName}}, x::errors::Error> {{.CppName}}::from_proto(
    const {{.PBNamespace}}::{{.PBName}}& pb
) {
    {{.CppName}} cpp;
{{- range .Fields}}
    {{.BackwardExpr}}{{if needsSemicolon .BackwardExpr}};{{end}}
{{- end}}
    return {cpp, x::errors::NIL};
}
{{- end}}
{{- end}}
{{- range .ArrayWrappers}}

inline {{.PBNamespace}}::{{.PBName}} {{.CppName}}::to_proto() const {
    {{.PBNamespace}}::{{.PBName}} pb;
{{- if .ElementNeedsConvert}}
    for (const auto& item : *this) *pb.add_values() = item.to_proto();
{{- else}}
    for (const auto& item : *this) pb.add_values(item);
{{- end}}
    return pb;
}

inline std::pair<{{.CppName}}, x::errors::Error> {{.CppName}}::from_proto(
    const {{.PBNamespace}}::{{.PBName}}& pb
) {
    {{.CppName}} cpp;
{{- if .ElementNeedsConvert}}
    if (auto err = x::pb::from_proto_repeated<{{.ElementType}}>(cpp, pb.values())) return {{lbrace}}{{lbrace}}}, err};
{{- else}}
    for (const auto& item : pb.values()) cpp.push_back(item);
{{- end}}
    return {cpp, x::errors::NIL};
}
{{- end}}

}
`))
