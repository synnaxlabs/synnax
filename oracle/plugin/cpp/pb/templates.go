// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package pb

import (
	"strings"
	"text/template"
)

var templateFuncs = template.FuncMap{
	"join": strings.Join,
}

var protoTemplate = template.Must(template.New("cpp-pb-proto").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.

#pragma once
{{- if .HasIncludes}}

{{range .SystemIncludes -}}
#include <{{.}}>
{{end -}}
{{if .SystemIncludes}}
{{end -}}
{{range .InternalIncludes -}}
#include "{{.}}"
{{end}}
{{- end}}
namespace {{.Namespace}} {
{{- range .EnumTranslators}}
{{$enum := .}}

inline {{.PBNamespace}}::{{.Name}} {{.Name}}ToPB(const std::string& cpp) {
{{- range .Values}}
    if (cpp == {{.CppValue}}) return {{$enum.PBNamespace}}::{{.PBValue}};
{{- end}}
    return {{.PBNamespace}}::{{.PBDefault}};
}

inline std::string {{.Name}}FromPB({{.PBNamespace}}::{{.Name}} pb) {
    switch (pb) {
{{- range .Values}}
    case {{$enum.PBNamespace}}::{{.PBValue}}: return {{.CppValue}};
{{- end}}
    default: return {{.CppDefault}};
    }
}
{{- end}}
{{- range .Translators}}
{{- if .IsGeneric}}

template <typename {{.TypeParamNames}}>
inline {{.PBNamespace}}::{{.PBName}} {{.CppName}}<{{.TypeParamNames}}>::to_proto() const {
    {{.PBNamespace}}::{{.PBName}} pb;
{{- range .Fields}}
{{- if .IsGenericField}}
    if constexpr (std::is_same_v<{{.TypeParamName}}, nlohmann::json>) {
        {{.ForwardJsonExpr}};
    } else {
        {{.ForwardExpr}};
    }
{{- else}}
    {{.ForwardExpr}};
{{- end}}
{{- end}}
    return pb;
}

template <typename {{.TypeParamNames}}>
inline std::pair<{{.CppName}}<{{.TypeParamNames}}>, x::errors::Error> {{.CppName}}<{{.TypeParamNames}}>::from_proto(
    const {{.PBNamespace}}::{{.PBName}}& pb
) {
    {{.CppName}}<{{.TypeParamNames}}> cpp;
{{- range .Fields}}
{{- if .IsGenericField}}
    if constexpr (std::is_same_v<{{.TypeParamName}}, nlohmann::json>) {
        {{.BackwardJsonExpr}}
    } else {
        {{.BackwardExpr}}
    }
{{- else}}
    {{.BackwardExpr}}
{{- end}}
{{- end}}
    return {cpp, x::errors::NIL};
}
{{- else}}

inline {{.PBNamespace}}::{{.PBName}} {{.CppName}}::to_proto() const {
    {{.PBNamespace}}::{{.PBName}} pb;
{{- range .Fields}}
    {{.ForwardExpr}};
{{- end}}
    return pb;
}

inline std::pair<{{.CppName}}, x::errors::Error> {{.CppName}}::from_proto(
    const {{.PBNamespace}}::{{.PBName}}& pb
) {
    {{.CppName}} cpp;
{{- range .Fields}}
    {{.BackwardExpr}}
{{- end}}
    return {cpp, x::errors::NIL};
}
{{- end}}
{{- end}}

}
`))
