// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package types_test

import (
	"context"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/synnaxlabs/oracle/analyzer"
	"github.com/synnaxlabs/oracle/plugin"
	"github.com/synnaxlabs/oracle/plugin/cpp/types"
	"github.com/synnaxlabs/oracle/testutil"
)

func TestCppTypes(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "C++ Types Plugin Suite")
}

var _ = Describe("C++ Types Plugin", func() {
	var (
		ctx       context.Context
		loader    *testutil.MockFileLoader
		cppPlugin *types.Plugin
	)

	BeforeEach(func() {
		ctx = context.Background()
		loader = testutil.NewMockFileLoader()
		cppPlugin = types.New(types.DefaultOptions())
	})

	Describe("Plugin Interface", func() {
		It("Should have correct name", func() {
			Expect(cppPlugin.Name()).To(Equal("cpp/types"))
		})

		It("Should filter on cpp domain", func() {
			Expect(cppPlugin.Domains()).To(Equal([]string{"cpp"}))
		})

		It("Should have no dependencies", func() {
			Expect(cppPlugin.Requires()).To(BeNil())
		})
	})

	Describe("Generate", func() {
		It("Should generate struct for simple types", func() {
			source := `
				@cpp output "client/cpp/user"

				User struct {
					key uint32
					name string
					age int32
					active bool
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(HaveLen(1))

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`// Code generated by oracle. DO NOT EDIT.`))
			Expect(content).To(ContainSubstring(`#pragma once`))
			Expect(content).To(ContainSubstring(`#include <cstdint>`))
			Expect(content).To(ContainSubstring(`#include <string>`))
			Expect(content).To(ContainSubstring(`namespace synnax::user {`))
			Expect(content).To(ContainSubstring(`struct User {`))
			Expect(content).To(ContainSubstring(`std::uint32_t key;`))
			Expect(content).To(ContainSubstring(`std::string name;`))
			Expect(content).To(ContainSubstring(`std::int32_t age;`))
			Expect(content).To(ContainSubstring(`bool active;`))
		})

		It("Should treat soft optional as bare type", func() {
			source := `
				@cpp output "client/cpp/rack"

				Rack struct {
					key uint32
					name string
					task_counter uint32?
					embedded bool?
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			// Soft optionals (?) are just the bare type in C++
			Expect(content).To(ContainSubstring(`std::uint32_t task_counter;`))
			Expect(content).To(ContainSubstring(`bool embedded;`))
			Expect(content).NotTo(ContainSubstring(`std::optional`))
		})

		It("Should use std::optional for hard optional types", func() {
			source := `
				@cpp output "client/cpp/rack"

				Rack struct {
					key uint32
					parent uint32??
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			// Only hard optionals (??) use std::optional in C++
			Expect(content).To(ContainSubstring(`#include <optional>`))
			Expect(content).To(ContainSubstring(`std::optional<std::uint32_t> parent;`))
		})

		It("Should handle array types with std::vector", func() {
			source := `
				@cpp output "client/cpp/rack"

				Rack struct {
					key uint32
					tags string[]
					values int32[]
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`#include <vector>`))
			Expect(content).To(ContainSubstring(`std::vector<std::string> tags;`))
			Expect(content).To(ContainSubstring(`std::vector<std::int32_t> values;`))
		})

		It("Should treat soft optional arrays as bare vector", func() {
			source := `
				@cpp output "client/cpp/rack"

				Rack struct {
					key uint32
					tags string[]?
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			// Soft optional array is just the vector without std::optional
			Expect(content).To(ContainSubstring(`std::vector<std::string> tags;`))
		})

		It("Should wrap hard optional arrays with std::optional", func() {
			source := `
				@cpp output "client/cpp/rack"

				Rack struct {
					key uint32
					tags string[]??
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			// Hard optional array wraps the vector with std::optional
			Expect(content).To(ContainSubstring(`std::optional<std::vector<std::string>> tags;`))
		})

		It("Should handle timestamp and telem types", func() {
			source := `
				@cpp output "client/cpp/rack"

				Rack struct {
					key uint32
					created_at timestamp
					duration timespan
					range time_range
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`#include "x/cpp/telem/telem.h"`))
			Expect(content).To(ContainSubstring(`telem::TimeStamp created_at;`))
			Expect(content).To(ContainSubstring(`telem::TimeSpan duration;`))
			Expect(content).To(ContainSubstring(`telem::TimeRange range;`))
		})

		It("Should handle json type", func() {
			source := `
				@cpp output "client/cpp/task"

				Task struct {
					key uint64
					config json
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "task", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`#include "nlohmann/json.hpp"`))
			Expect(content).To(ContainSubstring(`nlohmann::json config;`))
		})

		It("Should handle map types", func() {
			source := `
				@cpp output "client/cpp/task"

				Task struct {
					key uint64
					metadata map<string, string>
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "task", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`#include <unordered_map>`))
			Expect(content).To(ContainSubstring(`std::unordered_map<std::string, std::string> metadata;`))
		})

		It("Should handle struct extension with field flattening", func() {
			source := `
				@cpp output "client/cpp/rack"

				Rack struct {
					key uint32
					name string
					task_counter uint32?
				}

				New struct extends Rack {
					key uint32??
					-task_counter
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			// New struct should have flattened fields with key hard optional and task_counter omitted
			Expect(content).To(ContainSubstring(`struct New {`))
			Expect(content).To(ContainSubstring(`std::optional<std::uint32_t> key;`))
			Expect(content).To(ContainSubstring(`std::string name;`))
			// task_counter should be omitted from New
			Expect(content).NotTo(MatchRegexp(`struct New \{[^}]*task_counter`))
		})

		It("Should handle @cpp name override", func() {
			source := `
				@cpp output "client/cpp/rack"
				@cpp name "RackPayload"

				Rack struct {
					key uint32
					name string
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`struct RackPayload {`))
			Expect(content).NotTo(ContainSubstring(`struct Rack {`))
		})

		It("Should handle @cpp omit", func() {
			source := `
				@cpp output "client/cpp/rack"

				Rack struct {
					key uint32
					name string
				}

				Internal struct {
					data string

					@cpp omit
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`struct Rack {`))
			Expect(content).NotTo(ContainSubstring(`struct Internal {`))
		})

		It("Should generate generic structs with templates", func() {
			source := `
				@cpp output "client/cpp/status"

				Status struct<D> {
					key uint32
					details D
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "status", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`template <typename D>`))
			Expect(content).To(ContainSubstring(`struct Status {`))
			Expect(content).To(ContainSubstring(`D details;`))
		})

		It("Should handle type aliases", func() {
			source := `
				@cpp output "client/cpp/rack"

				StatusDetails struct {
					rack uint32
				}

				Status = StatusDetails
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`using Status = StatusDetails;`))
		})

		It("Should handle bytes type", func() {
			source := `
				@cpp output "client/cpp/module"

				Module struct {
					key uint32
					wasm bytes
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "module", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`std::vector<std::uint8_t> wasm;`))
		})

		It("Should handle int enums", func() {
			source := `
				@cpp output "client/cpp/status"

				Variant enum {
					success = 0
					error = 1
					warning = 2
				}

				Status struct {
					variant Variant
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "status", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())

			content := string(resp.Files[0].Content)
			Expect(content).To(ContainSubstring(`enum class Variant {`))
			Expect(content).To(ContainSubstring(`Success = 0,`))
			Expect(content).To(ContainSubstring(`Error = 1,`))
			Expect(content).To(ContainSubstring(`Warning = 2,`))
		})

		It("Should handle cross-namespace references to handwritten types", func() {
			// First, set up the "status" namespace with an omitted type
			statusSource := `
				@cpp omit
				@cpp include "x/cpp/status/status.h"

				Status struct<D?> {
					key string
					details D?
				}
			`
			loader.Add("schemas/status", statusSource)

			// Then, the "rack" namespace that references it
			rackSource := `
				import "schemas/status"

				@cpp output "client/cpp/rack"

				StatusDetails struct {
					rack uint32
				}

				RackStatus = status.Status<StatusDetails>

				Rack struct {
					key uint32
					status RackStatus??
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, rackSource, "rack", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(HaveLen(1))

			content := string(resp.Files[0].Content)
			// Should include the handwritten status header
			Expect(content).To(ContainSubstring(`#include "x/cpp/status/status.h"`))
			// Should use full namespace path for the omitted type
			Expect(content).To(ContainSubstring(`using RackStatus = status::Status<StatusDetails>;`))
			// Should reference the alias in the struct with hard optional
			Expect(content).To(ContainSubstring(`std::optional<RackStatus> status;`))
		})

		It("Should not generate files for structs without @cpp output", func() {
			source := `
				@go output "core/pkg/service/user"

				User struct {
					key uint32
					name string
				}
			`
			table, diag := analyzer.AnalyzeSource(ctx, source, "user", loader)
			Expect(diag.HasErrors()).To(BeFalse())

			req := &plugin.Request{
				Resolutions: table,
				OutputDir:   "out",
			}

			resp, err := cppPlugin.Generate(req)
			Expect(err).To(BeNil())
			Expect(resp.Files).To(HaveLen(0))
		})
	})
})
