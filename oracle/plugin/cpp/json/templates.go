// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package json

import (
	"strings"
	"text/template"
)

var templateFuncs = template.FuncMap{
	"join": strings.Join,
}

var jsonTemplate = template.Must(template.New("cpp-json").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.

#pragma once
{{- if .HasIncludes}}

{{range .SystemIncludes -}}
#include <{{.}}>
{{end -}}
{{if .SystemIncludes}}
{{end -}}
{{range .InternalIncludes -}}
#include "{{.}}"
{{end}}
{{- end}}
namespace {{.Namespace}} {
{{- range .Serializers}}
{{- if .IsGeneric}}

template <typename {{.TypeParamNames}}>
{{.Name}}<{{.TypeParamNames}}> {{.Name}}<{{.TypeParamNames}}>::parse(x::json::Parser parser) {
    return {{.Name}}<{{.TypeParamNames}}>{
{{- range $j, $f := .Fields}}
        .{{$f.Name}} = {{$f.ParseExpr}},
{{- end}}
    };
}

template <typename {{.TypeParamNames}}>
x::json::json {{.Name}}<{{.TypeParamNames}}>::to_json() const {
    x::json::json j;
{{- range .Fields}}
    {{.ToJSONExpr}}
{{- end}}
    return j;
}
{{- else if .HasExtends}}

inline {{.Name}} {{.Name}}::parse(x::json::Parser parser) {
    {{.Name}} result;
{{- range .ParentTypes}}
    static_cast<{{.QualifiedName}}&>(result) = {{.QualifiedName}}::parse(parser);
{{- end}}
{{- range .Fields}}
    result.{{.Name}} = {{.ParseExpr}};
{{- end}}
    return result;
}

inline x::json::json {{.Name}}::to_json() const {
    x::json::json j;
{{- range .ParentTypes}}
    for (auto& [k, v] : {{.QualifiedName}}::to_json().items()) j[k] = v;
{{- end}}
{{- range .Fields}}
    {{.ToJSONExpr}}
{{- end}}
    return j;
}
{{- else}}

inline {{.Name}} {{.Name}}::parse(x::json::Parser parser) {
    return {{.Name}}{
{{- range .Fields}}
        .{{.Name}} = {{.ParseExpr}},
{{- end}}
    };
}

inline x::json::json {{.Name}}::to_json() const {
    x::json::json j;
{{- range .Fields}}
    {{.ToJSONExpr}}
{{- end}}
    return j;
}
{{- end}}
{{- end}}
{{- range .ArrayWrappers}}

inline {{.Name}} {{.Name}}::parse(x::json::Parser parser) {
    {{.Name}} result;
    for (auto& item : parser.field<std::vector<{{.ElementType}}>>())
        result.push_back(std::move(item));
    return result;
}

inline x::json::json {{.Name}}::to_json() const {
    x::json::json j = x::json::json::array();
    for (const auto& item : *this) {
{{- if .ElementNeedsConvert}}
        j.push_back(item.to_json());
{{- else}}
        j.push_back(item);
{{- end}}
    }
    return j;
}
{{- end}}

}
`))
