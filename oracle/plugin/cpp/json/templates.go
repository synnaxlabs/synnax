// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

package json

import (
	"strings"
	"text/template"
)

var templateFuncs = template.FuncMap{
	"join": strings.Join,
}

var jsonTemplate = template.Must(template.New("cpp-json").Funcs(templateFuncs).Parse(`// Code generated by oracle. DO NOT EDIT.

#pragma once
{{- if .HasIncludes}}

{{range .SystemIncludes -}}
#include <{{.}}>
{{end -}}
{{if .SystemIncludes}}
{{end -}}
{{range .InternalIncludes -}}
#include "{{.}}"
{{end}}
{{- end}}
namespace {{.Namespace}} {
{{- range .Serializers}}
{{- if .IsGeneric}}

template <typename {{.TypeParamNames}}>
{{.Name}}<{{.TypeParamNames}}> {{.Name}}<{{.TypeParamNames}}>::parse(x::json::Parser parser) {
    return {{.Name}}<{{.TypeParamNames}}>{
{{- range $j, $f := .Fields}}
        .{{$f.Name}} = {{$f.ParseExpr}},
{{- end}}
    };
}

template <typename {{.TypeParamNames}}>
x::json::json {{.Name}}<{{.TypeParamNames}}>::to_json() const {
    x::json::json j;
{{- range .Fields}}
    {{.ToJsonExpr}}
{{- end}}
    return j;
}
{{- else}}

inline {{.Name}} {{.Name}}::parse(x::json::Parser parser) {
    return {{.Name}}{
{{- range .Fields}}
        .{{.Name}} = {{.ParseExpr}},
{{- end}}
    };
}

inline x::json::json {{.Name}}::to_json() const {
    x::json::json j;
{{- range .Fields}}
    {{.ToJsonExpr}}
{{- end}}
    return j;
}
{{- end}}
{{- end}}

}
`))
