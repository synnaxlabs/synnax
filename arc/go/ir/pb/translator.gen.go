// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package pb

import (
	"context"
	"github.com/samber/lo"
	"github.com/synnaxlabs/arc/ir"
	typespb "github.com/synnaxlabs/arc/types/pb"
)

// HandleToPB converts Handle to Handle.
func HandleToPB(_ context.Context, r ir.Handle) (*Handle, error) {
	pb := &Handle{
		Node:  r.Node,
		Param: r.Param,
	}
	return pb, nil
}

// HandleFromPB converts Handle to Handle.
func HandleFromPB(_ context.Context, pb *Handle) (ir.Handle, error) {
	var r ir.Handle
	if pb == nil {
		return r, nil
	}
	r.Node = pb.Node
	r.Param = pb.Param
	return r, nil
}

// HandlesToPB converts a slice of Handle to Handle.
func HandlesToPB(ctx context.Context, rs []ir.Handle) ([]*Handle, error) {
	result := make([]*Handle, len(rs))
	for i := range rs {
		var err error
		result[i], err = HandleToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// HandlesFromPB converts a slice of Handle to Handle.
func HandlesFromPB(ctx context.Context, pbs []*Handle) ([]ir.Handle, error) {
	result := make([]ir.Handle, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = HandleFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// EdgeToPB converts Edge to Edge.
func EdgeToPB(ctx context.Context, r ir.Edge) (*Edge, error) {
	sourceVal, err := HandleToPB(ctx, r.Source)
	if err != nil {
		return nil, err
	}
	targetVal, err := HandleToPB(ctx, r.Target)
	if err != nil {
		return nil, err
	}
	pb := &Edge{
		Kind:   EdgeKindToPB(r.Kind),
		Source: sourceVal,
		Target: targetVal,
	}
	return pb, nil
}

// EdgeFromPB converts Edge to Edge.
func EdgeFromPB(ctx context.Context, pb *Edge) (ir.Edge, error) {
	var r ir.Edge
	if pb == nil {
		return r, nil
	}
	var err error
	r.Source, err = HandleFromPB(ctx, pb.Source)
	if err != nil {
		return r, err
	}
	r.Target, err = HandleFromPB(ctx, pb.Target)
	if err != nil {
		return r, err
	}
	r.Kind = EdgeKindFromPB(pb.Kind)
	return r, nil
}

// EdgesToPB converts a slice of Edge to Edge.
func EdgesToPB(ctx context.Context, rs []ir.Edge) ([]*Edge, error) {
	result := make([]*Edge, len(rs))
	for i := range rs {
		var err error
		result[i], err = EdgeToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// EdgesFromPB converts a slice of Edge to Edge.
func EdgesFromPB(ctx context.Context, pbs []*Edge) ([]ir.Edge, error) {
	result := make([]ir.Edge, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = EdgeFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// StageToPB converts Stage to Stage.
func StageToPB(_ context.Context, r ir.Stage) (*Stage, error) {
	pb := &Stage{
		Key:    r.Key,
		Nodes:  r.Nodes,
		Strata: lo.Map(r.Strata, func(inner []string, _ int) *StratumWrapper { return &StratumWrapper{Values: inner} }),
	}
	return pb, nil
}

// StageFromPB converts Stage to Stage.
func StageFromPB(_ context.Context, pb *Stage) (ir.Stage, error) {
	var r ir.Stage
	if pb == nil {
		return r, nil
	}
	r.Key = pb.Key
	r.Nodes = pb.Nodes
	r.Strata = lo.Map(pb.Strata, func(w *StratumWrapper, _ int) []string { return w.Values })
	return r, nil
}

// StagesToPB converts a slice of Stage to Stage.
func StagesToPB(ctx context.Context, rs []ir.Stage) ([]*Stage, error) {
	result := make([]*Stage, len(rs))
	for i := range rs {
		var err error
		result[i], err = StageToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// StagesFromPB converts a slice of Stage to Stage.
func StagesFromPB(ctx context.Context, pbs []*Stage) ([]ir.Stage, error) {
	result := make([]ir.Stage, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = StageFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// SequenceToPB converts Sequence to Sequence.
func SequenceToPB(ctx context.Context, r ir.Sequence) (*Sequence, error) {
	stagesVal, err := StagesToPB(ctx, r.Stages)
	if err != nil {
		return nil, err
	}
	pb := &Sequence{
		Key:    r.Key,
		Stages: stagesVal,
	}
	return pb, nil
}

// SequenceFromPB converts Sequence to Sequence.
func SequenceFromPB(ctx context.Context, pb *Sequence) (ir.Sequence, error) {
	var r ir.Sequence
	if pb == nil {
		return r, nil
	}
	var err error
	r.Stages, err = StagesFromPB(ctx, pb.Stages)
	if err != nil {
		return r, err
	}
	r.Key = pb.Key
	return r, nil
}

// SequencesToPB converts a slice of Sequence to Sequence.
func SequencesToPB(ctx context.Context, rs []ir.Sequence) ([]*Sequence, error) {
	result := make([]*Sequence, len(rs))
	for i := range rs {
		var err error
		result[i], err = SequenceToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// SequencesFromPB converts a slice of Sequence to Sequence.
func SequencesFromPB(ctx context.Context, pbs []*Sequence) ([]ir.Sequence, error) {
	result := make([]ir.Sequence, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = SequenceFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// BodyToPB converts Body to Body.
func BodyToPB(_ context.Context, r ir.Body) (*Body, error) {
	pb := &Body{
		Raw: r.Raw,
	}
	return pb, nil
}

// BodyFromPB converts Body to Body.
func BodyFromPB(_ context.Context, pb *Body) (ir.Body, error) {
	var r ir.Body
	if pb == nil {
		return r, nil
	}
	r.Raw = pb.Raw
	return r, nil
}

// BodysToPB converts a slice of Body to Body.
func BodysToPB(ctx context.Context, rs []ir.Body) ([]*Body, error) {
	result := make([]*Body, len(rs))
	for i := range rs {
		var err error
		result[i], err = BodyToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// BodysFromPB converts a slice of Body to Body.
func BodysFromPB(ctx context.Context, pbs []*Body) ([]ir.Body, error) {
	result := make([]ir.Body, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = BodyFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// FunctionToPB converts Function to Function.
func FunctionToPB(ctx context.Context, r ir.Function) (*Function, error) {
	bodyVal, err := BodyToPB(ctx, r.Body)
	if err != nil {
		return nil, err
	}
	configVal, err := typespb.ParamsToPB(ctx, r.Config)
	if err != nil {
		return nil, err
	}
	inputsVal, err := typespb.ParamsToPB(ctx, r.Inputs)
	if err != nil {
		return nil, err
	}
	outputsVal, err := typespb.ParamsToPB(ctx, r.Outputs)
	if err != nil {
		return nil, err
	}
	channelsVal, err := typespb.ChannelsToPB(ctx, r.Channels)
	if err != nil {
		return nil, err
	}
	pb := &Function{
		Key:      r.Key,
		Body:     bodyVal,
		Config:   configVal,
		Inputs:   inputsVal,
		Outputs:  outputsVal,
		Channels: channelsVal,
	}
	return pb, nil
}

// FunctionFromPB converts Function to Function.
func FunctionFromPB(ctx context.Context, pb *Function) (ir.Function, error) {
	var r ir.Function
	if pb == nil {
		return r, nil
	}
	var err error
	r.Body, err = BodyFromPB(ctx, pb.Body)
	if err != nil {
		return r, err
	}
	r.Config, err = typespb.ParamsFromPB(ctx, pb.Config)
	if err != nil {
		return r, err
	}
	r.Inputs, err = typespb.ParamsFromPB(ctx, pb.Inputs)
	if err != nil {
		return r, err
	}
	r.Outputs, err = typespb.ParamsFromPB(ctx, pb.Outputs)
	if err != nil {
		return r, err
	}
	r.Channels, err = typespb.ChannelsFromPB(ctx, pb.Channels)
	if err != nil {
		return r, err
	}
	r.Key = pb.Key
	return r, nil
}

// FunctionsToPB converts a slice of Function to Function.
func FunctionsToPB(ctx context.Context, rs []ir.Function) ([]*Function, error) {
	result := make([]*Function, len(rs))
	for i := range rs {
		var err error
		result[i], err = FunctionToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// FunctionsFromPB converts a slice of Function to Function.
func FunctionsFromPB(ctx context.Context, pbs []*Function) ([]ir.Function, error) {
	result := make([]ir.Function, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = FunctionFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// NodeToPB converts Node to Node.
func NodeToPB(ctx context.Context, r ir.Node) (*Node, error) {
	configVal, err := typespb.ParamsToPB(ctx, r.Config)
	if err != nil {
		return nil, err
	}
	inputsVal, err := typespb.ParamsToPB(ctx, r.Inputs)
	if err != nil {
		return nil, err
	}
	outputsVal, err := typespb.ParamsToPB(ctx, r.Outputs)
	if err != nil {
		return nil, err
	}
	channelsVal, err := typespb.ChannelsToPB(ctx, r.Channels)
	if err != nil {
		return nil, err
	}
	pb := &Node{
		Key:      r.Key,
		Type:     r.Type,
		Config:   configVal,
		Inputs:   inputsVal,
		Outputs:  outputsVal,
		Channels: channelsVal,
	}
	return pb, nil
}

// NodeFromPB converts Node to Node.
func NodeFromPB(ctx context.Context, pb *Node) (ir.Node, error) {
	var r ir.Node
	if pb == nil {
		return r, nil
	}
	var err error
	r.Config, err = typespb.ParamsFromPB(ctx, pb.Config)
	if err != nil {
		return r, err
	}
	r.Inputs, err = typespb.ParamsFromPB(ctx, pb.Inputs)
	if err != nil {
		return r, err
	}
	r.Outputs, err = typespb.ParamsFromPB(ctx, pb.Outputs)
	if err != nil {
		return r, err
	}
	r.Channels, err = typespb.ChannelsFromPB(ctx, pb.Channels)
	if err != nil {
		return r, err
	}
	r.Key = pb.Key
	r.Type = pb.Type
	return r, nil
}

// NodesToPB converts a slice of Node to Node.
func NodesToPB(ctx context.Context, rs []ir.Node) ([]*Node, error) {
	result := make([]*Node, len(rs))
	for i := range rs {
		var err error
		result[i], err = NodeToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// NodesFromPB converts a slice of Node to Node.
func NodesFromPB(ctx context.Context, pbs []*Node) ([]ir.Node, error) {
	result := make([]ir.Node, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = NodeFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// IRToPB converts IR to IR.
func IRToPB(ctx context.Context, r ir.IR) (*IR, error) {
	functionsVal, err := FunctionsToPB(ctx, r.Functions)
	if err != nil {
		return nil, err
	}
	nodesVal, err := NodesToPB(ctx, r.Nodes)
	if err != nil {
		return nil, err
	}
	edgesVal, err := EdgesToPB(ctx, r.Edges)
	if err != nil {
		return nil, err
	}
	sequencesVal, err := SequencesToPB(ctx, r.Sequences)
	if err != nil {
		return nil, err
	}
	pb := &IR{
		Strata:    lo.Map(r.Strata, func(inner []string, _ int) *StratumWrapper { return &StratumWrapper{Values: inner} }),
		Functions: functionsVal,
		Nodes:     nodesVal,
		Edges:     edgesVal,
		Sequences: sequencesVal,
	}
	return pb, nil
}

// IRFromPB converts IR to IR.
func IRFromPB(ctx context.Context, pb *IR) (ir.IR, error) {
	var r ir.IR
	if pb == nil {
		return r, nil
	}
	var err error
	r.Functions, err = FunctionsFromPB(ctx, pb.Functions)
	if err != nil {
		return r, err
	}
	r.Nodes, err = NodesFromPB(ctx, pb.Nodes)
	if err != nil {
		return r, err
	}
	r.Edges, err = EdgesFromPB(ctx, pb.Edges)
	if err != nil {
		return r, err
	}
	r.Sequences, err = SequencesFromPB(ctx, pb.Sequences)
	if err != nil {
		return r, err
	}
	r.Strata = lo.Map(pb.Strata, func(w *StratumWrapper, _ int) []string { return w.Values })
	return r, nil
}

// IRsToPB converts a slice of IR to IR.
func IRsToPB(ctx context.Context, rs []ir.IR) ([]*IR, error) {
	result := make([]*IR, len(rs))
	for i := range rs {
		var err error
		result[i], err = IRToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// IRsFromPB converts a slice of IR to IR.
func IRsFromPB(ctx context.Context, pbs []*IR) ([]ir.IR, error) {
	result := make([]ir.IR, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = IRFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// EdgeKindToPB converts ir.EdgeKind to EdgeKind.
func EdgeKindToPB(v ir.EdgeKind) EdgeKind {
	switch v {
	case ir.EdgeKindUnspecified:
		return EdgeKind_EDGE_KIND_UNSPECIFIED
	case ir.EdgeKindContinuous:
		return EdgeKind_EDGE_KIND_CONTINUOUS
	case ir.EdgeKindOneShot:
		return EdgeKind_EDGE_KIND_ONE_SHOT
	default:
		return EdgeKind_EDGE_KIND_UNSPECIFIED
	}
}

// EdgeKindFromPB converts EdgeKind to ir.EdgeKind.
func EdgeKindFromPB(v EdgeKind) ir.EdgeKind {
	switch v {
	case EdgeKind_EDGE_KIND_UNSPECIFIED:
		return ir.EdgeKindUnspecified
	case EdgeKind_EDGE_KIND_CONTINUOUS:
		return ir.EdgeKindContinuous
	case EdgeKind_EDGE_KIND_ONE_SHOT:
		return ir.EdgeKindOneShot
	default:
		return ir.EdgeKindUnspecified
	}
}
