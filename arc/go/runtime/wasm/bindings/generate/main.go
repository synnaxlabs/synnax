// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

//go:build ignore

package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

// TypeInfo represents a type and its Go/WASM representations
type TypeInfo struct {
	IRType   string // e.g., "u8", "i32", "f64"
	GoType   string // e.g., "uint8", "int32", "float64"
	WasmType string // e.g., "uint32", "uint32", "float64"
	Is64Bit  bool   // whether this type uses 64-bit WASM representation
	DataType string // telem data type constant, e.g., "Uint8T", "Int32T", "Float64T"
}

var types = []TypeInfo{
	{"u8", "uint8", "uint32", false, "Uint8T"},
	{"u16", "uint16", "uint32", false, "Uint16T"},
	{"u32", "uint32", "uint32", false, "Uint32T"},
	{"u64", "uint64", "uint64", true, "Uint64T"},
	{"i8", "int8", "uint32", false, "Int8T"},
	{"i16", "int16", "uint32", false, "Int16T"},
	{"i32", "int32", "uint32", false, "Int32T"},
	{"i64", "int64", "uint64", true, "Int64T"},
	{"f32", "float32", "float32", false, "Float32T"},
	{"f64", "float64", "float64", true, "Float64T"},
	{"str", "uint32", "uint32", false, ""}, // string handles are uint32
}

const runtimeTemplate = `// Code generated by go generate; DO NOT EDIT.

package bindings

import (
	"context"
	"math"

	"github.com/synnaxlabs/arc/runtime/state"
	"github.com/synnaxlabs/x/telem"
	"github.com/synnaxlabs/x/telem/op"
	xmath "github.com/synnaxlabs/x/math"
	"github.com/tetratelabs/wazero/api"
)

// Runtime provides the actual implementation of Arc runtime functions.
// This is the "business logic" layer that the bindings call.
type Runtime struct {
	state *state.State
	memory api.Memory  // WASM memory for reading string literals

	// String storage - handle to string mapping
	strings map[uint32]string
	stringHandleCounter uint32

	// Series storage - handle to series mapping
	series map[uint32]telem.Series
	seriesHandleCounter uint32

	// State storage for stateful variables
	// Key: (funcID << 32) | varID
{{range .NumericTypes}}	state{{.IRType | title}} map[uint64]{{.GoType}}
{{end}}	stateString map[uint64]string
	stateSeries map[uint64]telem.Series
}

func NewRuntime(state *state.State, memory api.Memory) *Runtime {
	return &Runtime{
		state: state,
		memory: memory,
		strings: make(map[uint32]string),
		stringHandleCounter: 1, // Start at 1, 0 is reserved for empty/null
		series: make(map[uint32]telem.Series),
		seriesHandleCounter: 1, // Start at 1, 0 is reserved for empty/null
{{range .NumericTypes}}		state{{.IRType | title}}: make(map[uint64]{{.GoType}}),
{{end}}		stateString: make(map[uint64]string),
		stateSeries: make(map[uint64]telem.Series),
	}
}

// SetMemory updates the WASM memory reference (used after module instantiation).
func (r *Runtime) SetMemory(memory api.Memory) {
	r.memory = memory
}

// ClearTemporarySeries resets series storage for a new execution cycle.
// Called at the start of each reactive execution. stateSeries is NOT cleared.
func (r *Runtime) ClearTemporarySeries() {
	r.series = make(map[uint32]telem.Series)
	r.seriesHandleCounter = 1
}

// stateKey combines funcID and varID into a single key for state storage.
func stateKey(funcID uint32, varID uint32) uint64 {
	return (uint64(funcID) << 32) | uint64(varID)
}

// ===== Channel Operations =====

{{range .Types}}{{if ne .IRType "str"}}
// ChannelRead{{.IRType | title}} reads the latest value from a channel.
func (r *Runtime) ChannelRead{{.IRType | title}}(ctx context.Context, channelID uint32) {{.GoType}} {
	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return {{.GoType}}(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[{{.GoType}}](series, -1)
}

// ChannelWrite{{.IRType | title}} writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWrite{{.IRType | title}}(ctx context.Context, channelID uint32, value {{.GoType}}) {
	// Create a single-value series
	series := telem.NewSeriesV[{{.GoType}}](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}
{{end}}{{end}}

// ===== State Operations =====

{{range .Types}}{{if ne .IRType "str"}}
// StateLoad{{.IRType | title}} loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoad{{.IRType | title}}(ctx context.Context, funcID uint32, varID uint32, initValue {{.GoType}}) {{.GoType}} {
	key := stateKey(funcID, varID)
	if value, ok := r.state{{.IRType | title}}[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.state{{.IRType | title}}[key] = initValue
	return initValue
}

// StateStore{{.IRType | title}} stores a stateful variable's value.
func (r *Runtime) StateStore{{.IRType | title}}(ctx context.Context, funcID uint32, varID uint32, value {{.GoType}}) {
	key := stateKey(funcID, varID)
	r.state{{.IRType | title}}[key] = value
}
{{end}}{{end}}

// ===== Generic Operations =====

// Now returns the current timestamp.
func (r *Runtime) Now(ctx context.Context) uint64 {
	return uint64(telem.Now())
}

// Panic is called when Arc code panics.
func (r *Runtime) Panic(ctx context.Context, ptr uint32, length uint32) {
	// Read panic message from WASM memory
	msg, ok := r.memory.Read(ptr, length)
	if !ok {
		panic("arc panic (message unreadable)")
	}
	panic("arc panic: " + string(msg))
}

// ===== Math Operations =====

// MathPowF32 computes base^exponent for f32.
func (r *Runtime) MathPowF32(ctx context.Context, base float32, exponent float32) float32 {
	return float32(math.Pow(float64(base), float64(exponent)))
}

// MathPowF64 computes base^exponent for f64.
func (r *Runtime) MathPowF64(ctx context.Context, base float64, exponent float64) float64 {
	return math.Pow(base, exponent)
}

{{range .IntegerTypes}}
// MathPow{{.IRType | title}} computes base^exponent for {{.IRType}} using integer exponentiation.
func (r *Runtime) MathPow{{.IRType | title}}(ctx context.Context, base {{.GoType}}, exponent {{.GoType}}) {{.GoType}} {
	return xmath.IntPow(base, int(exponent))
}
{{end}}

// ===== String Operations =====

// StringFromLiteral creates a string from WASM memory and returns a handle.
func (r *Runtime) StringFromLiteral(ctx context.Context, ptr uint32, length uint32) uint32 {
	// Read string data from WASM memory
	data, ok := r.memory.Read(ptr, length)
	if !ok {
		return 0 // Return null handle on failure
	}

	// generate new handle
	handle := r.stringHandleCounter
	r.stringHandleCounter++

	// Store string
	r.strings[handle] = string(data)

	return handle
}

// StringLen returns the length of a string.
func (r *Runtime) StringLen(ctx context.Context, handle uint32) uint32 {
	if str, ok := r.strings[handle]; ok {
		return uint32(len(str))
	}
	return 0
}

// StringEqual compares two strings for equality.
func (r *Runtime) StringEqual(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
	str1, ok1 := r.strings[handle1]
	str2, ok2 := r.strings[handle2]

	if ok1 && ok2 && str1 == str2 {
		return 1
	}
	return 0
}

// ChannelReadStr reads the latest string from a channel and returns a handle.
func (r *Runtime) ChannelReadStr(ctx context.Context, channelID uint32) uint32 {
	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return 0 // Return null handle
	}

	// Unmarshal strings from series
	strings := telem.UnmarshalStrings(series.Data)
	if len(strings) == 0 {
		return 0
	}

	// Get the last (most recent) string
	str := strings[len(strings)-1]

	// generate handle and store
	handle := r.stringHandleCounter
	r.stringHandleCounter++
	r.strings[handle] = str

	return handle
}

// ChannelWriteStr writes a string to a channel (queued for flush).
func (r *Runtime) ChannelWriteStr(ctx context.Context, channelID uint32, handle uint32) {
	// Look up string by handle
	str, ok := r.strings[handle]
	if !ok {
		return // Invalid handle, do nothing
	}

	// Create series from string
	data := telem.MarshalStrings([]string{str}, telem.StringT)
	series := telem.Series{
		DataType: telem.StringT,
		Data:     data,
	}

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// StateLoadStr loads a stateful string variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadStr(ctx context.Context, funcID uint32, varID uint32, initHandle uint32) uint32 {
	key := stateKey(funcID, varID)
	str, ok := r.stateString[key]
	if ok {
		// Exists - create a new handle for the stored string
		handle := r.stringHandleCounter
		r.stringHandleCounter++
		r.strings[handle] = str
		return handle
	}

	// Not found - store the init string and return the same handle
	if initStr, ok := r.strings[initHandle]; ok {
		r.stateString[key] = initStr
	}
	return initHandle
}

// StateStoreStr stores a stateful string variable's value.
func (r *Runtime) StateStoreStr(ctx context.Context, funcID uint32, varID uint32, handle uint32) {
	// Look up string by handle
	str, ok := r.strings[handle]
	if !ok {
		return // Invalid handle, do nothing
	}

	key := stateKey(funcID, varID)
	r.stateString[key] = str
}

// ===== Series Operations =====

{{range .NumericTypes}}
// SeriesCreateEmpty{{.IRType | title}} creates an empty series of the given length.
func (r *Runtime) SeriesCreateEmpty{{.IRType | title}}(ctx context.Context, length uint32) uint32 {
	s := telem.MakeSeries(telem.{{.DataType}}, int(length))
	handle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[handle] = s
	return handle
}

// SeriesSetElement{{.IRType | title}} sets an element in a series at the given index and returns the handle.
func (r *Runtime) SeriesSetElement{{.IRType | title}}(ctx context.Context, handle uint32, index uint32, value {{.GoType}}) uint32 {
	if s, ok := r.series[handle]; ok {
		if int64(index) < s.Len() {
			telem.SetValueAt[{{.GoType}}](s, int(index), value)
		}
	}
	return handle
}

// SeriesIndex{{.IRType | title}} gets an element from a series at the given index.
func (r *Runtime) SeriesIndex{{.IRType | title}}(ctx context.Context, handle uint32, index uint32) {{.GoType}} {
	if s, ok := r.series[handle]; ok {
		if int64(index) < s.Len() {
			return telem.ValueAt[{{.GoType}}](s, int(index))
		}
	}
	return {{.GoType}}(0)
}

// SeriesElementAdd{{.IRType | title}} adds a scalar to all elements of a series.
func (r *Runtime) SeriesElementAdd{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: s.DataType}
	op.AddScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesElementSub{{.IRType | title}} subtracts a scalar from all elements of a series.
func (r *Runtime) SeriesElementSub{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: s.DataType}
	op.SubtractScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesElementMul{{.IRType | title}} multiplies all elements of a series by a scalar.
func (r *Runtime) SeriesElementMul{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: s.DataType}
	op.MultiplyScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesElementDiv{{.IRType | title}} divides all elements of a series by a scalar.
func (r *Runtime) SeriesElementDiv{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: s.DataType}
	op.DivideScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesElementMod{{.IRType | title}} computes modulo of all elements of a series by a scalar.
func (r *Runtime) SeriesElementMod{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: s.DataType}
	op.ModuloScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesElementRSub{{.IRType | title}} computes scalar - series (reverse subtract).
// Note: signature is (scalar, handle) to match WASM stack order for 'scalar - series'.
func (r *Runtime) SeriesElementRSub{{.IRType | title}}(ctx context.Context, scalar {{.GoType}}, handle uint32) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: s.DataType}
	op.ReverseSubtractScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesElementRDiv{{.IRType | title}} computes scalar / series (reverse divide).
// Note: signature is (scalar, handle) to match WASM stack order for 'scalar / series'.
func (r *Runtime) SeriesElementRDiv{{.IRType | title}}(ctx context.Context, scalar {{.GoType}}, handle uint32) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: s.DataType}
	op.ReverseDivideScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesSeriesAdd{{.IRType | title}} adds two series element-wise.
func (r *Runtime) SeriesSeriesAdd{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in addition")
	}
	result := telem.Series{DataType: s1.DataType}
	op.Add{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesSeriesSub{{.IRType | title}} subtracts two series element-wise.
func (r *Runtime) SeriesSeriesSub{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in subtraction")
	}
	result := telem.Series{DataType: s1.DataType}
	op.Subtract{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesSeriesMul{{.IRType | title}} multiplies two series element-wise.
func (r *Runtime) SeriesSeriesMul{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in multiplication")
	}
	result := telem.Series{DataType: s1.DataType}
	op.Multiply{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesSeriesDiv{{.IRType | title}} divides two series element-wise.
func (r *Runtime) SeriesSeriesDiv{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in division")
	}
	result := telem.Series{DataType: s1.DataType}
	op.Divide{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesSeriesMod{{.IRType | title}} computes modulo of two series element-wise.
func (r *Runtime) SeriesSeriesMod{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in modulo")
	}
	result := telem.Series{DataType: s1.DataType}
	op.Modulo{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareGT{{.IRType | title}} compares two series element-wise (greater than).
func (r *Runtime) SeriesCompareGT{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in comparison")
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.GreaterThan{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareLT{{.IRType | title}} compares two series element-wise (less than).
func (r *Runtime) SeriesCompareLT{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in comparison")
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.LessThan{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareGE{{.IRType | title}} compares two series element-wise (greater or equal).
func (r *Runtime) SeriesCompareGE{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in comparison")
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.GreaterThanOrEqual{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareLE{{.IRType | title}} compares two series element-wise (less or equal).
func (r *Runtime) SeriesCompareLE{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in comparison")
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.LessThanOrEqual{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareEQ{{.IRType | title}} compares two series element-wise (equal).
func (r *Runtime) SeriesCompareEQ{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in comparison")
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.Equal{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareNE{{.IRType | title}} compares two series element-wise (not equal).
func (r *Runtime) SeriesCompareNE{{.IRType | title}}(ctx context.Context, h1 uint32, h2 uint32) uint32 {
	s1, ok1 := r.series[h1]
	s2, ok2 := r.series[h2]
	if !ok1 || !ok2 {
		return 0
	}
	if s1.Len() != s2.Len() {
		panic("arc panic: series length mismatch in comparison")
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.NotEqual{{.IRType | title}}(s1, s2, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareGTScalar{{.IRType | title}} compares series > scalar.
func (r *Runtime) SeriesCompareGTScalar{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.GreaterThanScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareLTScalar{{.IRType | title}} compares series < scalar.
func (r *Runtime) SeriesCompareLTScalar{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.LessThanScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareGEScalar{{.IRType | title}} compares series >= scalar.
func (r *Runtime) SeriesCompareGEScalar{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.GreaterThanOrEqualScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareLEScalar{{.IRType | title}} compares series <= scalar.
func (r *Runtime) SeriesCompareLEScalar{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.LessThanOrEqualScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareEQScalar{{.IRType | title}} compares series == scalar.
func (r *Runtime) SeriesCompareEQScalar{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.EqualScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesCompareNEScalar{{.IRType | title}} compares series != scalar.
func (r *Runtime) SeriesCompareNEScalar{{.IRType | title}}(ctx context.Context, handle uint32, scalar {{.GoType}}) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.NotEqualScalar{{.IRType | title}}(s, scalar, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// StateLoadSeries{{.IRType | title}} loads a persisted series, returns new handle.
func (r *Runtime) StateLoadSeries{{.IRType | title}}(ctx context.Context, funcID uint32, varID uint32, initHandle uint32) uint32 {
	key := stateKey(funcID, varID)
	if s, ok := r.stateSeries[key]; ok {
		handle := r.seriesHandleCounter
		r.seriesHandleCounter++
		r.series[handle] = s
		return handle
	}
	// Initialize from provided handle
	if initS, ok := r.series[initHandle]; ok {
		r.stateSeries[key] = initS
	}
	return initHandle
}

// StateStoreSeries{{.IRType | title}} persists a series to state.
func (r *Runtime) StateStoreSeries{{.IRType | title}}(ctx context.Context, funcID uint32, varID uint32, handle uint32) {
	if s, ok := r.series[handle]; ok {
		r.stateSeries[stateKey(funcID, varID)] = s
	}
}
{{end}}

{{range .SignedTypes}}
// SeriesNegate{{.IRType | title}} negates all elements of a series.
func (r *Runtime) SeriesNegate{{.IRType | title}}(ctx context.Context, handle uint32) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: s.DataType}
	op.Negate{{.IRType | title}}(s, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}
{{end}}

// SeriesNotU8 performs logical NOT on a boolean series.
func (r *Runtime) SeriesNotU8(ctx context.Context, handle uint32) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	result := telem.Series{DataType: telem.Uint8T}
	op.NotU8(s, &result)
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = result
	return newHandle
}

// SeriesLen returns the length of a series.
func (r *Runtime) SeriesLen(ctx context.Context, handle uint32) uint64 {
	if s, ok := r.series[handle]; ok {
		return uint64(s.Len())
	}
	return 0
}

// SeriesSlice returns a slice of a series.
func (r *Runtime) SeriesSlice(ctx context.Context, handle uint32, start uint32, end uint32) uint32 {
	s, ok := r.series[handle]
	if !ok {
		return 0
	}
	length := int(s.Len())
	startIdx := int(start)
	endIdx := int(end)
	if endIdx < 0 || endIdx > length {
		endIdx = length
	}
	if startIdx < 0 {
		startIdx = 0
	}
	if startIdx >= endIdx {
		return 0
	}
	density := int(s.DataType.Density())
	sliced := telem.Series{
		DataType: s.DataType,
		Data:     s.Data[startIdx*density : endIdx*density],
	}
	newHandle := r.seriesHandleCounter
	r.seriesHandleCounter++
	r.series[newHandle] = sliced
	return newHandle
}
`

func main() {
	// Filter numeric types (exclude str for now)
	var numericTypes []TypeInfo
	var integerTypes []TypeInfo
	var signedTypes []TypeInfo
	for _, t := range types {
		if t.IRType != "str" {
			numericTypes = append(numericTypes, t)
			// Filter integer types (exclude floats and str)
			if t.IRType != "f32" && t.IRType != "f64" {
				integerTypes = append(integerTypes, t)
			}
			// Filter signed types (for negation - floats and signed integers)
			if t.IRType == "f32" || t.IRType == "f64" ||
				t.IRType == "i8" || t.IRType == "i16" || t.IRType == "i32" || t.IRType == "i64" {
				signedTypes = append(signedTypes, t)
			}
		}
	}

	data := struct {
		Types        []TypeInfo
		NumericTypes []TypeInfo
		IntegerTypes []TypeInfo
		SignedTypes  []TypeInfo
	}{
		Types:        types,
		NumericTypes: numericTypes,
		IntegerTypes: integerTypes,
		SignedTypes:  signedTypes,
	}

	// Custom template functions
	funcMap := template.FuncMap{
		"title": strings.Title,
	}

	tmpl := template.Must(template.New("runtime").Funcs(funcMap).Parse(runtimeTemplate))

	file, err := os.Create("runtime_generated.go")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		panic(err)
	}

	fmt.Println("Generated runtime_generated.go")
}
