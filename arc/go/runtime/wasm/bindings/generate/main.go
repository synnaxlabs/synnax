// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

//go:build ignore

package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

// TypeInfo represents a type and its Go/WASM representations
type TypeInfo struct {
	IRType   string // e.g., "u8", "i32", "f64"
	GoType   string // e.g., "uint8", "int32", "float64"
	WasmType string // e.g., "uint32", "uint32", "float64"
	Is64Bit  bool   // whether this type uses 64-bit WASM representation
}

var types = []TypeInfo{
	{"u8", "uint8", "uint32", false},
	{"u16", "uint16", "uint32", false},
	{"u32", "uint32", "uint32", false},
	{"u64", "uint64", "uint64", true},
	{"i8", "int8", "uint32", false},
	{"i16", "int16", "uint32", false},
	{"i32", "int32", "uint32", false},
	{"i64", "int64", "uint64", true},
	{"f32", "float32", "float32", false},
	{"f64", "float64", "float64", true},
	{"str", "uint32", "uint32", false}, // string handles are uint32
}

const runtimeTemplate = `// Code generated by go generate; DO NOT EDIT.

package bindings

import (
	"context"
	"math"

	"github.com/synnaxlabs/arc/runtime/state"
	"github.com/synnaxlabs/x/telem"
	xmath "github.com/synnaxlabs/x/math"
	"github.com/tetratelabs/wazero/api"
)

// Runtime provides the actual implementation of Arc runtime functions.
// This is the "business logic" layer that the bindings call.
type Runtime struct {
	state *state.State
	memory api.Memory  // WASM memory for reading string literals

	// String storage - handle to string mapping
	strings map[uint32]string
	stringHandleCounter uint32

	// State storage for stateful variables
	// Key: (funcID << 32) | varID
{{range .NumericTypes}}	state{{.IRType | title}} map[uint64]{{.GoType}}
{{end}}	stateString map[uint64]string
}

func NewRuntime(state *state.State, memory api.Memory) *Runtime {
	return &Runtime{
		state: state,
		memory: memory,
		strings: make(map[uint32]string),
		stringHandleCounter: 1, // Start at 1, 0 is reserved for empty/null
{{range .NumericTypes}}		state{{.IRType | title}}: make(map[uint64]{{.GoType}}),
{{end}}		stateString: make(map[uint64]string),
	}
}

// SetMemory updates the WASM memory reference (used after module instantiation).
func (r *Runtime) SetMemory(memory api.Memory) {
	r.memory = memory
}

// stateKey combines funcID and varID into a single key for state storage.
func stateKey(funcID uint32, varID uint32) uint64 {
	return (uint64(funcID) << 32) | uint64(varID)
}

// ===== Channel Operations =====

{{range .Types}}{{if ne .IRType "str"}}
// ChannelRead{{.IRType | title}} reads the latest value from a channel.
func (r *Runtime) ChannelRead{{.IRType | title}}(ctx context.Context, channelID uint32) {{.GoType}} {
	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return {{.GoType}}(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[{{.GoType}}](series, -1)
}

// ChannelWrite{{.IRType | title}} writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWrite{{.IRType | title}}(ctx context.Context, channelID uint32, value {{.GoType}}) {
	// Create a single-value series
	series := telem.NewSeriesV[{{.GoType}}](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}
{{end}}{{end}}

// ===== State Operations =====

{{range .Types}}{{if ne .IRType "str"}}
// StateLoad{{.IRType | title}} loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoad{{.IRType | title}}(ctx context.Context, funcID uint32, varID uint32, initValue {{.GoType}}) {{.GoType}} {
	key := stateKey(funcID, varID)
	if value, ok := r.state{{.IRType | title}}[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.state{{.IRType | title}}[key] = initValue
	return initValue
}

// StateStore{{.IRType | title}} stores a stateful variable's value.
func (r *Runtime) StateStore{{.IRType | title}}(ctx context.Context, funcID uint32, varID uint32, value {{.GoType}}) {
	key := stateKey(funcID, varID)
	r.state{{.IRType | title}}[key] = value
}
{{end}}{{end}}

// ===== Generic Operations =====

// Now returns the current timestamp.
func (r *Runtime) Now(ctx context.Context) uint64 {
	return uint64(telem.Now())
}

// Panic is called when Arc code panics.
func (r *Runtime) Panic(ctx context.Context, ptr uint32, length uint32) {
	// Read panic message from WASM memory
	msg, ok := r.memory.Read(ptr, length)
	if !ok {
		panic("arc panic (message unreadable)")
	}
	panic("arc panic: " + string(msg))
}

// ===== Math Operations =====

// MathPowF32 computes base^exponent for f32.
func (r *Runtime) MathPowF32(ctx context.Context, base float32, exponent float32) float32 {
	return float32(math.Pow(float64(base), float64(exponent)))
}

// MathPowF64 computes base^exponent for f64.
func (r *Runtime) MathPowF64(ctx context.Context, base float64, exponent float64) float64 {
	return math.Pow(base, exponent)
}

{{range .IntegerTypes}}
// MathPow{{.IRType | title}} computes base^exponent for {{.IRType}} using integer exponentiation.
func (r *Runtime) MathPow{{.IRType | title}}(ctx context.Context, base {{.GoType}}, exponent {{.GoType}}) {{.GoType}} {
	return xmath.IntPow(base, int(exponent))
}
{{end}}

// ===== String Operations =====

// StringFromLiteral creates a string from WASM memory and returns a handle.
func (r *Runtime) StringFromLiteral(ctx context.Context, ptr uint32, length uint32) uint32 {
	// Read string data from WASM memory
	data, ok := r.memory.Read(ptr, length)
	if !ok {
		return 0 // Return null handle on failure
	}

	// Generate new handle
	handle := r.stringHandleCounter
	r.stringHandleCounter++

	// Store string
	r.strings[handle] = string(data)

	return handle
}

// StringLen returns the length of a string.
func (r *Runtime) StringLen(ctx context.Context, handle uint32) uint32 {
	if str, ok := r.strings[handle]; ok {
		return uint32(len(str))
	}
	return 0
}

// StringEqual compares two strings for equality.
func (r *Runtime) StringEqual(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
	str1, ok1 := r.strings[handle1]
	str2, ok2 := r.strings[handle2]

	if ok1 && ok2 && str1 == str2 {
		return 1
	}
	return 0
}

// ChannelReadStr reads the latest string from a channel and returns a handle.
func (r *Runtime) ChannelReadStr(ctx context.Context, channelID uint32) uint32 {
	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return 0 // Return null handle
	}

	// Unmarshal strings from series
	strings := telem.UnmarshalStrings(series.Data)
	if len(strings) == 0 {
		return 0
	}

	// Get the last (most recent) string
	str := strings[len(strings)-1]

	// Generate handle and store
	handle := r.stringHandleCounter
	r.stringHandleCounter++
	r.strings[handle] = str

	return handle
}

// ChannelWriteStr writes a string to a channel (queued for flush).
func (r *Runtime) ChannelWriteStr(ctx context.Context, channelID uint32, handle uint32) {
	// Look up string by handle
	str, ok := r.strings[handle]
	if !ok {
		return // Invalid handle, do nothing
	}

	// Create series from string
	data := telem.MarshalStrings([]string{str}, telem.StringT)
	series := telem.Series{
		DataType: telem.StringT,
		Data:     data,
	}

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// StateLoadStr loads a stateful string variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadStr(ctx context.Context, funcID uint32, varID uint32, initHandle uint32) uint32 {
	key := stateKey(funcID, varID)
	str, ok := r.stateString[key]
	if ok {
		// Exists - create a new handle for the stored string
		handle := r.stringHandleCounter
		r.stringHandleCounter++
		r.strings[handle] = str
		return handle
	}

	// Not found - store the init string and return the same handle
	if initStr, ok := r.strings[initHandle]; ok {
		r.stateString[key] = initStr
	}
	return initHandle
}

// StateStoreStr stores a stateful string variable's value.
func (r *Runtime) StateStoreStr(ctx context.Context, funcID uint32, varID uint32, handle uint32) {
	// Look up string by handle
	str, ok := r.strings[handle]
	if !ok {
		return // Invalid handle, do nothing
	}

	key := stateKey(funcID, varID)
	r.stateString[key] = str
}
`

func main() {
	// Filter numeric types (exclude str for now)
	var numericTypes []TypeInfo
	var integerTypes []TypeInfo
	for _, t := range types {
		if t.IRType != "str" {
			numericTypes = append(numericTypes, t)
			// Filter integer types (exclude floats and str)
			if t.IRType != "f32" && t.IRType != "f64" {
				integerTypes = append(integerTypes, t)
			}
		}
	}

	data := struct {
		Types        []TypeInfo
		NumericTypes []TypeInfo
		IntegerTypes []TypeInfo
	}{
		Types:        types,
		NumericTypes: numericTypes,
		IntegerTypes: integerTypes,
	}

	// Custom template functions
	funcMap := template.FuncMap{
		"title": strings.Title,
	}

	tmpl := template.Must(template.New("runtime").Funcs(funcMap).Parse(runtimeTemplate))

	file, err := os.Create("runtime_generated.go")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		panic(err)
	}

	fmt.Println("Generated runtime_generated.go")
}
