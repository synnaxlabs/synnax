// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package pb

import (
	"context"
	"github.com/synnaxlabs/arc/graph"
	irpb "github.com/synnaxlabs/arc/ir/pb"
	spatialpb "github.com/synnaxlabs/x/spatial/pb"
	"google.golang.org/protobuf/types/known/structpb"
)

// NodeToPB converts Node to Node.
func NodeToPB(ctx context.Context, r graph.Node) (*Node, error) {
	configVal, err := structpb.NewStruct(r.Config)
	if err != nil {
		return nil, err
	}
	positionVal, err := spatialpb.XYToPB(ctx, r.Position)
	if err != nil {
		return nil, err
	}
	pb := &Node{
		Key:      r.Key,
		Type:     r.Type,
		Config:   configVal,
		Position: positionVal,
	}
	return pb, nil
}

// NodeFromPB converts Node to Node.
func NodeFromPB(ctx context.Context, pb *Node) (graph.Node, error) {
	var r graph.Node
	if pb == nil {
		return r, nil
	}
	var err error
	r.Config = pb.Config.AsMap()
	r.Position, err = spatialpb.XYFromPB(ctx, pb.Position)
	if err != nil {
		return r, err
	}
	r.Key = pb.Key
	r.Type = pb.Type
	return r, nil
}

// NodesToPB converts a slice of Node to Node.
func NodesToPB(ctx context.Context, rs []graph.Node) ([]*Node, error) {
	result := make([]*Node, len(rs))
	for i := range rs {
		var err error
		result[i], err = NodeToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// NodesFromPB converts a slice of Node to Node.
func NodesFromPB(ctx context.Context, pbs []*Node) ([]graph.Node, error) {
	result := make([]graph.Node, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = NodeFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ViewportToPB converts Viewport to Viewport.
func ViewportToPB(ctx context.Context, r graph.Viewport) (*Viewport, error) {
	positionVal, err := spatialpb.XYToPB(ctx, r.Position)
	if err != nil {
		return nil, err
	}
	pb := &Viewport{
		Zoom:     r.Zoom,
		Position: positionVal,
	}
	return pb, nil
}

// ViewportFromPB converts Viewport to Viewport.
func ViewportFromPB(ctx context.Context, pb *Viewport) (graph.Viewport, error) {
	var r graph.Viewport
	if pb == nil {
		return r, nil
	}
	var err error
	r.Position, err = spatialpb.XYFromPB(ctx, pb.Position)
	if err != nil {
		return r, err
	}
	r.Zoom = pb.Zoom
	return r, nil
}

// ViewportsToPB converts a slice of Viewport to Viewport.
func ViewportsToPB(ctx context.Context, rs []graph.Viewport) ([]*Viewport, error) {
	result := make([]*Viewport, len(rs))
	for i := range rs {
		var err error
		result[i], err = ViewportToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ViewportsFromPB converts a slice of Viewport to Viewport.
func ViewportsFromPB(ctx context.Context, pbs []*Viewport) ([]graph.Viewport, error) {
	result := make([]graph.Viewport, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = ViewportFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// GraphToPB converts Graph to Graph.
func GraphToPB(ctx context.Context, r graph.Graph) (*Graph, error) {
	viewportVal, err := ViewportToPB(ctx, r.Viewport)
	if err != nil {
		return nil, err
	}
	functionsVal, err := irpb.FunctionsToPB(ctx, r.Functions)
	if err != nil {
		return nil, err
	}
	edgesVal, err := irpb.EdgesToPB(ctx, r.Edges)
	if err != nil {
		return nil, err
	}
	nodesVal, err := NodesToPB(ctx, r.Nodes)
	if err != nil {
		return nil, err
	}
	pb := &Graph{
		Viewport:  viewportVal,
		Functions: functionsVal,
		Edges:     edgesVal,
		Nodes:     nodesVal,
	}
	return pb, nil
}

// GraphFromPB converts Graph to Graph.
func GraphFromPB(ctx context.Context, pb *Graph) (graph.Graph, error) {
	var r graph.Graph
	if pb == nil {
		return r, nil
	}
	var err error
	r.Viewport, err = ViewportFromPB(ctx, pb.Viewport)
	if err != nil {
		return r, err
	}
	r.Functions, err = irpb.FunctionsFromPB(ctx, pb.Functions)
	if err != nil {
		return r, err
	}
	r.Edges, err = irpb.EdgesFromPB(ctx, pb.Edges)
	if err != nil {
		return r, err
	}
	r.Nodes, err = NodesFromPB(ctx, pb.Nodes)
	if err != nil {
		return r, err
	}
	return r, nil
}

// GraphsToPB converts a slice of Graph to Graph.
func GraphsToPB(ctx context.Context, rs []graph.Graph) ([]*Graph, error) {
	result := make([]*Graph, len(rs))
	for i := range rs {
		var err error
		result[i], err = GraphToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// GraphsFromPB converts a slice of Graph to Graph.
func GraphsFromPB(ctx context.Context, pbs []*Graph) ([]graph.Graph, error) {
	result := make([]graph.Graph, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = GraphFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}
