// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package pb

import (
	"context"
	"github.com/samber/lo"
	irpb "github.com/synnaxlabs/arc/ir/pb"
	"github.com/synnaxlabs/arc/module"
)

// ModuleToPB converts Module to Module.
func ModuleToPB(ctx context.Context, r module.Module) (*Module, error) {
	functionsVal, err := irpb.FunctionsToPB(ctx, r.Functions)
	if err != nil {
		return nil, err
	}
	nodesVal, err := irpb.NodesToPB(ctx, r.Nodes)
	if err != nil {
		return nil, err
	}
	edgesVal, err := irpb.EdgesToPB(ctx, r.Edges)
	if err != nil {
		return nil, err
	}
	sequencesVal, err := irpb.SequencesToPB(ctx, r.Sequences)
	if err != nil {
		return nil, err
	}
	pb := &Module{
		Strata:            lo.Map(r.Strata, func(inner []string, _ int) *StratumWrapper { return &StratumWrapper{Values: inner} }),
		Wasm:              r.WASM,
		OutputMemoryBases: r.OutputMemoryBases,
		Functions:         functionsVal,
		Nodes:             nodesVal,
		Edges:             edgesVal,
		Sequences:         sequencesVal,
	}
	return pb, nil
}

// ModuleFromPB converts Module to Module.
func ModuleFromPB(ctx context.Context, pb *Module) (module.Module, error) {
	var r module.Module
	if pb == nil {
		return r, nil
	}
	var err error
	r.Functions, err = irpb.FunctionsFromPB(ctx, pb.Functions)
	if err != nil {
		return r, err
	}
	r.Nodes, err = irpb.NodesFromPB(ctx, pb.Nodes)
	if err != nil {
		return r, err
	}
	r.Edges, err = irpb.EdgesFromPB(ctx, pb.Edges)
	if err != nil {
		return r, err
	}
	r.Sequences, err = irpb.SequencesFromPB(ctx, pb.Sequences)
	if err != nil {
		return r, err
	}
	r.Strata = lo.Map(pb.Strata, func(w *StratumWrapper, _ int) []string { return w.Values })
	r.WASM = pb.Wasm
	r.OutputMemoryBases = pb.OutputMemoryBases
	return r, nil
}

// ModulesToPB converts a slice of Module to Module.
func ModulesToPB(ctx context.Context, rs []module.Module) ([]*Module, error) {
	result := make([]*Module, len(rs))
	for i := range rs {
		var err error
		result[i], err = ModuleToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ModulesFromPB converts a slice of Module to Module.
func ModulesFromPB(ctx context.Context, pbs []*Module) ([]module.Module, error) {
	result := make([]module.Module, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = ModuleFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}
