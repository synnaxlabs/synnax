// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package pb

import (
	"context"
	"github.com/synnaxlabs/arc/types"
	"google.golang.org/protobuf/types/known/structpb"
)

// FunctionPropertiesToPB converts FunctionProperties to FunctionProperties.
func FunctionPropertiesToPB(ctx context.Context, r types.FunctionProperties) (*FunctionProperties, error) {
	inputsVal, err := ParamsToPB(ctx, r.Inputs)
	if err != nil {
		return nil, err
	}
	outputsVal, err := ParamsToPB(ctx, r.Outputs)
	if err != nil {
		return nil, err
	}
	configVal, err := ParamsToPB(ctx, r.Config)
	if err != nil {
		return nil, err
	}
	pb := &FunctionProperties{
		Inputs:  inputsVal,
		Outputs: outputsVal,
		Config:  configVal,
	}
	return pb, nil
}

// FunctionPropertiesFromPB converts FunctionProperties to FunctionProperties.
func FunctionPropertiesFromPB(ctx context.Context, pb *FunctionProperties) (types.FunctionProperties, error) {
	var r types.FunctionProperties
	if pb == nil {
		return r, nil
	}
	var err error
	r.Inputs, err = ParamsFromPB(ctx, pb.Inputs)
	if err != nil {
		return r, err
	}
	r.Outputs, err = ParamsFromPB(ctx, pb.Outputs)
	if err != nil {
		return r, err
	}
	r.Config, err = ParamsFromPB(ctx, pb.Config)
	if err != nil {
		return r, err
	}
	return r, nil
}

// FunctionPropertiessToPB converts a slice of FunctionProperties to FunctionProperties.
func FunctionPropertiessToPB(ctx context.Context, rs []types.FunctionProperties) ([]*FunctionProperties, error) {
	result := make([]*FunctionProperties, len(rs))
	for i := range rs {
		var err error
		result[i], err = FunctionPropertiesToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// FunctionPropertiessFromPB converts a slice of FunctionProperties to FunctionProperties.
func FunctionPropertiessFromPB(ctx context.Context, pbs []*FunctionProperties) ([]types.FunctionProperties, error) {
	result := make([]types.FunctionProperties, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = FunctionPropertiesFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// TypeToPB converts Type to Type.
func TypeToPB(ctx context.Context, r types.Type) (*Type, error) {
	inputsVal, err := ParamsToPB(ctx, r.Inputs)
	if err != nil {
		return nil, err
	}
	outputsVal, err := ParamsToPB(ctx, r.Outputs)
	if err != nil {
		return nil, err
	}
	configVal, err := ParamsToPB(ctx, r.Config)
	if err != nil {
		return nil, err
	}
	pb := &Type{
		Kind:    KindToPB(r.Kind),
		Name:    r.Name,
		Inputs:  inputsVal,
		Outputs: outputsVal,
		Config:  configVal,
	}
	if r.Elem != nil {
		var err error
		pb.Elem, err = TypeToPB(ctx, *r.Elem)
		if err != nil {
			return nil, err
		}
	}
	if r.Unit != nil {
		var err error
		pb.Unit, err = UnitToPB(ctx, *r.Unit)
		if err != nil {
			return nil, err
		}
	}
	if r.Constraint != nil {
		var err error
		pb.Constraint, err = TypeToPB(ctx, *r.Constraint)
		if err != nil {
			return nil, err
		}
	}
	return pb, nil
}

// TypeFromPB converts Type to Type.
func TypeFromPB(ctx context.Context, pb *Type) (types.Type, error) {
	var r types.Type
	if pb == nil {
		return r, nil
	}
	var err error
	r.Inputs, err = ParamsFromPB(ctx, pb.Inputs)
	if err != nil {
		return r, err
	}
	r.Outputs, err = ParamsFromPB(ctx, pb.Outputs)
	if err != nil {
		return r, err
	}
	r.Config, err = ParamsFromPB(ctx, pb.Config)
	if err != nil {
		return r, err
	}
	r.Kind = KindFromPB(pb.Kind)
	r.Name = pb.Name
	if pb.Elem != nil {
		val, err := TypeFromPB(ctx, pb.Elem)
		if err != nil {
			return r, err
		}
		r.Elem = &val
	}
	if pb.Unit != nil {
		val, err := UnitFromPB(ctx, pb.Unit)
		if err != nil {
			return r, err
		}
		r.Unit = &val
	}
	if pb.Constraint != nil {
		val, err := TypeFromPB(ctx, pb.Constraint)
		if err != nil {
			return r, err
		}
		r.Constraint = &val
	}
	return r, nil
}

// TypesToPB converts a slice of Type to Type.
func TypesToPB(ctx context.Context, rs []types.Type) ([]*Type, error) {
	result := make([]*Type, len(rs))
	for i := range rs {
		var err error
		result[i], err = TypeToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// TypesFromPB converts a slice of Type to Type.
func TypesFromPB(ctx context.Context, pbs []*Type) ([]types.Type, error) {
	result := make([]types.Type, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = TypeFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ParamToPB converts Param to Param.
func ParamToPB(ctx context.Context, r types.Param) (*Param, error) {
	typeVal, err := TypeToPB(ctx, r.Type)
	if err != nil {
		return nil, err
	}
	valueVal, err := structpb.NewValue(r.Value)
	if err != nil {
		return nil, err
	}
	pb := &Param{
		Name:  r.Name,
		Type:  typeVal,
		Value: valueVal,
	}
	return pb, nil
}

// ParamFromPB converts Param to Param.
func ParamFromPB(ctx context.Context, pb *Param) (types.Param, error) {
	var r types.Param
	if pb == nil {
		return r, nil
	}
	var err error
	r.Type, err = TypeFromPB(ctx, pb.Type)
	if err != nil {
		return r, err
	}
	r.Value = pb.Value.AsInterface()
	r.Name = pb.Name
	return r, nil
}

// ParamsToPB converts a slice of Param to Param.
func ParamsToPB(ctx context.Context, rs []types.Param) ([]*Param, error) {
	result := make([]*Param, len(rs))
	for i := range rs {
		var err error
		result[i], err = ParamToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ParamsFromPB converts a slice of Param to Param.
func ParamsFromPB(ctx context.Context, pbs []*Param) ([]types.Param, error) {
	result := make([]types.Param, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = ParamFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ChannelsToPB converts Channels to Channels.
func ChannelsToPB(_ context.Context, r types.Channels) (*Channels, error) {
	pb := &Channels{
		Read:  r.Read,
		Write: r.Write,
	}
	return pb, nil
}

// ChannelsFromPB converts Channels to Channels.
func ChannelsFromPB(_ context.Context, pb *Channels) (types.Channels, error) {
	var r types.Channels
	if pb == nil {
		return r, nil
	}
	r.Read = pb.Read
	r.Write = pb.Write
	return r, nil
}

// ChannelssToPB converts a slice of Channels to Channels.
func ChannelssToPB(ctx context.Context, rs []types.Channels) ([]*Channels, error) {
	result := make([]*Channels, len(rs))
	for i := range rs {
		var err error
		result[i], err = ChannelsToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ChannelssFromPB converts a slice of Channels to Channels.
func ChannelssFromPB(ctx context.Context, pbs []*Channels) ([]types.Channels, error) {
	result := make([]types.Channels, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = ChannelsFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// DimensionsToPB converts Dimensions to Dimensions.
func DimensionsToPB(_ context.Context, r types.Dimensions) (*Dimensions, error) {
	pb := &Dimensions{
		Length:      int32(r.Length),
		Mass:        int32(r.Mass),
		Time:        int32(r.Time),
		Current:     int32(r.Current),
		Temperature: int32(r.Temperature),
		Angle:       int32(r.Angle),
		Count:       int32(r.Count),
		Data:        int32(r.Data),
	}
	return pb, nil
}

// DimensionsFromPB converts Dimensions to Dimensions.
func DimensionsFromPB(_ context.Context, pb *Dimensions) (types.Dimensions, error) {
	var r types.Dimensions
	if pb == nil {
		return r, nil
	}
	r.Length = int8(pb.Length)
	r.Mass = int8(pb.Mass)
	r.Time = int8(pb.Time)
	r.Current = int8(pb.Current)
	r.Temperature = int8(pb.Temperature)
	r.Angle = int8(pb.Angle)
	r.Count = int8(pb.Count)
	r.Data = int8(pb.Data)
	return r, nil
}

// DimensionssToPB converts a slice of Dimensions to Dimensions.
func DimensionssToPB(ctx context.Context, rs []types.Dimensions) ([]*Dimensions, error) {
	result := make([]*Dimensions, len(rs))
	for i := range rs {
		var err error
		result[i], err = DimensionsToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// DimensionssFromPB converts a slice of Dimensions to Dimensions.
func DimensionssFromPB(ctx context.Context, pbs []*Dimensions) ([]types.Dimensions, error) {
	result := make([]types.Dimensions, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = DimensionsFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// UnitToPB converts Unit to Unit.
func UnitToPB(ctx context.Context, r types.Unit) (*Unit, error) {
	dimensionsVal, err := DimensionsToPB(ctx, r.Dimensions)
	if err != nil {
		return nil, err
	}
	pb := &Unit{
		Scale:      r.Scale,
		Name:       r.Name,
		Dimensions: dimensionsVal,
	}
	return pb, nil
}

// UnitFromPB converts Unit to Unit.
func UnitFromPB(ctx context.Context, pb *Unit) (types.Unit, error) {
	var r types.Unit
	if pb == nil {
		return r, nil
	}
	var err error
	r.Dimensions, err = DimensionsFromPB(ctx, pb.Dimensions)
	if err != nil {
		return r, err
	}
	r.Scale = pb.Scale
	r.Name = pb.Name
	return r, nil
}

// UnitsToPB converts a slice of Unit to Unit.
func UnitsToPB(ctx context.Context, rs []types.Unit) ([]*Unit, error) {
	result := make([]*Unit, len(rs))
	for i := range rs {
		var err error
		result[i], err = UnitToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// UnitsFromPB converts a slice of Unit to Unit.
func UnitsFromPB(ctx context.Context, pbs []*Unit) ([]types.Unit, error) {
	result := make([]types.Unit, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = UnitFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// KindToPB converts types.Kind to Kind.
func KindToPB(v types.Kind) Kind {
	switch v {
	case types.KindInvalid:
		return Kind_KIND_INVALID
	case types.KindU8:
		return Kind_KIND_U_8
	case types.KindU16:
		return Kind_KIND_U_16
	case types.KindU32:
		return Kind_KIND_U_32
	case types.KindU64:
		return Kind_KIND_U_64
	case types.KindI8:
		return Kind_KIND_I_8
	case types.KindI16:
		return Kind_KIND_I_16
	case types.KindI32:
		return Kind_KIND_I_32
	case types.KindI64:
		return Kind_KIND_I_64
	case types.KindF32:
		return Kind_KIND_F_32
	case types.KindF64:
		return Kind_KIND_F_64
	case types.KindString:
		return Kind_KIND_STRING
	case types.KindChan:
		return Kind_KIND_CHAN
	case types.KindSeries:
		return Kind_KIND_SERIES
	case types.KindVariable:
		return Kind_KIND_VARIABLE
	case types.KindNumericConstant:
		return Kind_KIND_NUMERIC_CONSTANT
	case types.KindIntegerConstant:
		return Kind_KIND_INTEGER_CONSTANT
	case types.KindFloatConstant:
		return Kind_KIND_FLOAT_CONSTANT
	case types.KindFunction:
		return Kind_KIND_FUNCTION
	case types.KindSequence:
		return Kind_KIND_SEQUENCE
	case types.KindStage:
		return Kind_KIND_STAGE
	default:
		return Kind_KIND_UNSPECIFIED
	}
}

// KindFromPB converts Kind to types.Kind.
func KindFromPB(v Kind) types.Kind {
	switch v {
	case Kind_KIND_INVALID:
		return types.KindInvalid
	case Kind_KIND_U_8:
		return types.KindU8
	case Kind_KIND_U_16:
		return types.KindU16
	case Kind_KIND_U_32:
		return types.KindU32
	case Kind_KIND_U_64:
		return types.KindU64
	case Kind_KIND_I_8:
		return types.KindI8
	case Kind_KIND_I_16:
		return types.KindI16
	case Kind_KIND_I_32:
		return types.KindI32
	case Kind_KIND_I_64:
		return types.KindI64
	case Kind_KIND_F_32:
		return types.KindF32
	case Kind_KIND_F_64:
		return types.KindF64
	case Kind_KIND_STRING:
		return types.KindString
	case Kind_KIND_CHAN:
		return types.KindChan
	case Kind_KIND_SERIES:
		return types.KindSeries
	case Kind_KIND_VARIABLE:
		return types.KindVariable
	case Kind_KIND_NUMERIC_CONSTANT:
		return types.KindNumericConstant
	case Kind_KIND_INTEGER_CONSTANT:
		return types.KindIntegerConstant
	case Kind_KIND_FLOAT_CONSTANT:
		return types.KindFloatConstant
	case Kind_KIND_FUNCTION:
		return types.KindFunction
	case Kind_KIND_SEQUENCE:
		return types.KindSequence
	case Kind_KIND_STAGE:
		return types.KindStage
	default:
		return types.KindInvalid
	}
}
