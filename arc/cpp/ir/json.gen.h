// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <string>
#include <vector>

#include "x/cpp/json/json.h"

#include "arc/cpp/ir/types.gen.h"
#include "arc/cpp/types/json.gen.h"

namespace arc::ir {

inline Handle Handle::parse(x::json::Parser parser) {
    return Handle{
        .node = parser.field<std::string>("node"),
        .param = parser.field<std::string>("param"),
    };
}

inline x::json::json Handle::to_json() const {
    x::json::json j;
    j["node"] = this->node;
    j["param"] = this->param;
    return j;
}

inline Edge Edge::parse(x::json::Parser parser) {
    return Edge{
        .source = parser.field<Handle>("source"),
        .target = parser.field<Handle>("target"),
        .kind = parser.field<EdgeKind>("kind"),
    };
}

inline x::json::json Edge::to_json() const {
    x::json::json j;
    j["source"] = this->source.to_json();
    j["target"] = this->target.to_json();
    j["kind"] = this->kind;
    return j;
}

inline Stage Stage::parse(x::json::Parser parser) {
    return Stage{
        .key = parser.field<std::string>("key"),
        .nodes = parser.field<std::vector<std::string>>("nodes"),
        .strata = parser.field<std::vector<Stratum>>("strata"),
    };
}

inline x::json::json Stage::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["nodes"] = this->nodes;
    j["strata"] = this->strata;
    return j;
}

inline Sequence Sequence::parse(x::json::Parser parser) {
    return Sequence{
        .key = parser.field<std::string>("key"),
        .stages = parser.field<std::vector<Stage>>("stages"),
    };
}

inline x::json::json Sequence::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->stages)
            arr.push_back(item.to_json());
        j["stages"] = arr;
    }
    return j;
}

inline Body Body::parse(x::json::Parser parser) {
    return Body{
        .raw = parser.field<std::string>("raw"),
    };
}

inline x::json::json Body::to_json() const {
    x::json::json j;
    j["raw"] = this->raw;
    return j;
}

inline Function Function::parse(x::json::Parser parser) {
    return Function{
        .key = parser.field<std::string>("key"),
        .body = parser.field<Body>("body"),
        .config = parser.field<std::vector<arc::types::Param>>("config"),
        .inputs = parser.field<std::vector<arc::types::Param>>("inputs"),
        .outputs = parser.field<std::vector<arc::types::Param>>("outputs"),
        .channels = parser.field<arc::types::Channels>("channels"),
    };
}

inline x::json::json Function::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["body"] = this->body.to_json();
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->config)
            arr.push_back(item.to_json());
        j["config"] = arr;
    }
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->inputs)
            arr.push_back(item.to_json());
        j["inputs"] = arr;
    }
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->outputs)
            arr.push_back(item.to_json());
        j["outputs"] = arr;
    }
    j["channels"] = this->channels.to_json();
    return j;
}

inline Node Node::parse(x::json::Parser parser) {
    return Node{
        .key = parser.field<std::string>("key"),
        .type = parser.field<std::string>("type"),
        .config = parser.field<std::vector<arc::types::Param>>("config"),
        .inputs = parser.field<std::vector<arc::types::Param>>("inputs"),
        .outputs = parser.field<std::vector<arc::types::Param>>("outputs"),
        .channels = parser.field<arc::types::Channels>("channels"),
    };
}

inline x::json::json Node::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["type"] = this->type;
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->config)
            arr.push_back(item.to_json());
        j["config"] = arr;
    }
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->inputs)
            arr.push_back(item.to_json());
        j["inputs"] = arr;
    }
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->outputs)
            arr.push_back(item.to_json());
        j["outputs"] = arr;
    }
    j["channels"] = this->channels.to_json();
    return j;
}

inline IR IR::parse(x::json::Parser parser) {
    return IR{
        .functions = parser.field<std::vector<Function>>("functions"),
        .nodes = parser.field<std::vector<Node>>("nodes"),
        .edges = parser.field<std::vector<Edge>>("edges"),
        .strata = parser.field<std::vector<Stratum>>("strata"),
        .sequences = parser.field<std::vector<Sequence>>("sequences"),
    };
}

inline x::json::json IR::to_json() const {
    x::json::json j;
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->functions)
            arr.push_back(item.to_json());
        j["functions"] = arr;
    }
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->nodes)
            arr.push_back(item.to_json());
        j["nodes"] = arr;
    }
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->edges)
            arr.push_back(item.to_json());
        j["edges"] = arr;
    }
    j["strata"] = this->strata;
    {
        auto arr = x::json::json::array();
        for (const auto &item: this->sequences)
            arr.push_back(item.to_json());
        j["sequences"] = arr;
    }
    return j;
}

}
