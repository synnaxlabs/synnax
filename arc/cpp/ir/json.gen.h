// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <string>
#include <vector>

#include "arc/cpp/ir/types.gen.h"
#include "x/cpp/json/json.h"

namespace synnax::ir {

inline Handle Handle::parse(x::json::Parser parser) {
    return Handle{
        .node = parser.field<std::string>("node"),
        .param = parser.field<std::string>("param"),
    };
}

inline x::json::json Handle::to_json() const {
    x::json::json j;
    j["node"] = this->node;
    j["param"] = this->param;
    return j;
}

inline Edge Edge::parse(x::json::Parser parser) {
    return Edge{
        .source = Handle::parse(parser.child("source")),
        .target = Handle::parse(parser.child("target")),
        .kind = EdgeKind::parse(parser.child("kind")),
    };
}

inline x::json::json Edge::to_json() const {
    x::json::json j;
    j["source"] = this->source.to_json();
    j["target"] = this->target.to_json();
    j["kind"] = this->kind;
    return j;
}

inline Stage Stage::parse(x::json::Parser parser) {
    return Stage{
        .key = parser.field<std::string>("key"),
        .nodes = parser.field<std::vector<std::string>>("nodes"),
        .strata = Strata::parse(parser.child("strata")),
    };
}

inline x::json::json Stage::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["nodes"] = this->nodes;
    j["strata"] = this->strata;
    return j;
}

inline Sequence Sequence::parse(x::json::Parser parser) {
    return Sequence{
        .key = parser.field<std::string>("key"),
        .stages = parser.field<std::vector<Stage>>("stages"),
    };
}

inline x::json::json Sequence::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    {
        auto arr = x::json::json::array();
        for (const auto& item : this->stages) arr.push_back(item.to_json());
        j["stages"] = arr;
    }
    return j;
}

inline Body Body::parse(x::json::Parser parser) {
    return Body{
        .raw = parser.field<std::string>("raw"),
    };
}

inline x::json::json Body::to_json() const {
    x::json::json j;
    j["raw"] = this->raw;
    return j;
}

inline Function Function::parse(x::json::Parser parser) {
    return Function{
        .key = parser.field<std::string>("key"),
        .body = Body::parse(parser.child("body")),
        .config = Params::parse(parser.child("config")),
        .inputs = Params::parse(parser.child("inputs")),
        .outputs = Params::parse(parser.child("outputs")),
        .channels = Channels::parse(parser.child("channels")),
    };
}

inline x::json::json Function::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["body"] = this->body.to_json();
    j["config"] = this->config;
    j["inputs"] = this->inputs;
    j["outputs"] = this->outputs;
    j["channels"] = this->channels.to_json();
    return j;
}

inline Node Node::parse(x::json::Parser parser) {
    return Node{
        .key = parser.field<std::string>("key"),
        .type = parser.field<std::string>("type"),
        .config = Params::parse(parser.child("config")),
        .inputs = Params::parse(parser.child("inputs")),
        .outputs = Params::parse(parser.child("outputs")),
        .channels = Channels::parse(parser.child("channels")),
    };
}

inline x::json::json Node::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["type"] = this->type;
    j["config"] = this->config;
    j["inputs"] = this->inputs;
    j["outputs"] = this->outputs;
    j["channels"] = this->channels.to_json();
    return j;
}

inline IR IR::parse(x::json::Parser parser) {
    return IR{
        .functions = Functions::parse(parser.child("functions")),
        .nodes = Nodes::parse(parser.child("nodes")),
        .edges = Edges::parse(parser.child("edges")),
        .strata = Strata::parse(parser.child("strata")),
        .sequences = Sequences::parse(parser.child("sequences")),
    };
}

inline x::json::json IR::to_json() const {
    x::json::json j;
    j["functions"] = this->functions;
    j["nodes"] = this->nodes;
    j["edges"] = this->edges;
    j["strata"] = this->strata;
    j["sequences"] = this->sequences;
    return j;
}

}
