// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <string>
#include <vector>

#include "x/cpp/json/json.h"

#include "arc/cpp/ir/types.gen.h"
#include "arc/cpp/types/json.gen.h"

namespace arc::ir {

inline Handle Handle::parse(x::json::Parser parser) {
    return Handle{
        .node = parser.field<std::string>("node"),
        .param = parser.field<std::string>("param"),
    };
}

inline x::json::json Handle::to_json() const {
    x::json::json j;
    j["node"] = this->node;
    j["param"] = this->param;
    return j;
}

inline Edge Edge::parse(x::json::Parser parser) {
    return Edge{
        .source = parser.field<Handle>("source"),
        .target = parser.field<Handle>("target"),
        .kind = parser.field<EdgeKind>("kind"),
    };
}

inline x::json::json Edge::to_json() const {
    x::json::json j;
    j["source"] = this->source.to_json();
    j["target"] = this->target.to_json();
    j["kind"] = this->kind;
    return j;
}

inline Stage Stage::parse(x::json::Parser parser) {
    return Stage{
        .key = parser.field<std::string>("key"),
        .nodes = parser.field<std::vector<std::string>>("nodes"),
        .strata = parser.field<Strata>("strata"),
    };
}

inline x::json::json Stage::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["nodes"] = this->nodes;
    j["strata"] = this->strata.to_json();
    return j;
}

inline Sequence Sequence::parse(x::json::Parser parser) {
    return Sequence{
        .key = parser.field<std::string>("key"),
        .stages = parser.field<std::vector<Stage>>("stages"),
    };
}

inline x::json::json Sequence::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["stages"] = x::json::to_array(this->stages);
    return j;
}

inline Body Body::parse(x::json::Parser parser) {
    return Body{
        .raw = parser.field<std::string>("raw"),
    };
}

inline x::json::json Body::to_json() const {
    x::json::json j;
    j["raw"] = this->raw;
    return j;
}

inline Function Function::parse(x::json::Parser parser) {
    return Function{
        .key = parser.field<std::string>("key"),
        .body = parser.field<Body>("body"),
        .config = parser.field<::arc::types::Params>("config"),
        .inputs = parser.field<::arc::types::Params>("inputs"),
        .outputs = parser.field<::arc::types::Params>("outputs"),
        .channels = parser.field<::arc::types::Channels>("channels"),
    };
}

inline x::json::json Function::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["body"] = this->body.to_json();
    j["config"] = this->config.to_json();
    j["inputs"] = this->inputs.to_json();
    j["outputs"] = this->outputs.to_json();
    j["channels"] = this->channels.to_json();
    return j;
}

inline Node Node::parse(x::json::Parser parser) {
    return Node{
        .key = parser.field<std::string>("key"),
        .type = parser.field<std::string>("type"),
        .config = parser.field<::arc::types::Params>("config"),
        .inputs = parser.field<::arc::types::Params>("inputs"),
        .outputs = parser.field<::arc::types::Params>("outputs"),
        .channels = parser.field<::arc::types::Channels>("channels"),
    };
}

inline x::json::json Node::to_json() const {
    x::json::json j;
    j["key"] = this->key;
    j["type"] = this->type;
    j["config"] = this->config.to_json();
    j["inputs"] = this->inputs.to_json();
    j["outputs"] = this->outputs.to_json();
    j["channels"] = this->channels.to_json();
    return j;
}

inline IR IR::parse(x::json::Parser parser) {
    return IR{
        .functions = parser.field<Functions>("functions"),
        .nodes = parser.field<Nodes>("nodes"),
        .edges = parser.field<Edges>("edges"),
        .strata = parser.field<Strata>("strata"),
        .sequences = parser.field<Sequences>("sequences"),
    };
}

inline x::json::json IR::to_json() const {
    x::json::json j;
    j["functions"] = this->functions.to_json();
    j["nodes"] = this->nodes.to_json();
    j["edges"] = this->edges.to_json();
    j["strata"] = this->strata.to_json();
    j["sequences"] = this->sequences.to_json();
    return j;
}

inline Edges Edges::parse(x::json::Parser parser) {
    Edges result;
    for (auto &item: parser.field<std::vector<Edge>>())
        result.push_back(std::move(item));
    return result;
}

inline x::json::json Edges::to_json() const {
    x::json::json j = x::json::json::array();
    for (const auto &item: *this) {
        j.push_back(item.to_json());
    }
    return j;
}

inline Stages Stages::parse(x::json::Parser parser) {
    Stages result;
    for (auto &item: parser.field<std::vector<Stage>>())
        result.push_back(std::move(item));
    return result;
}

inline x::json::json Stages::to_json() const {
    x::json::json j = x::json::json::array();
    for (const auto &item: *this) {
        j.push_back(item.to_json());
    }
    return j;
}

inline Sequences Sequences::parse(x::json::Parser parser) {
    Sequences result;
    for (auto &item: parser.field<std::vector<Sequence>>())
        result.push_back(std::move(item));
    return result;
}

inline x::json::json Sequences::to_json() const {
    x::json::json j = x::json::json::array();
    for (const auto &item: *this) {
        j.push_back(item.to_json());
    }
    return j;
}

inline Functions Functions::parse(x::json::Parser parser) {
    Functions result;
    for (auto &item: parser.field<std::vector<Function>>())
        result.push_back(std::move(item));
    return result;
}

inline x::json::json Functions::to_json() const {
    x::json::json j = x::json::json::array();
    for (const auto &item: *this) {
        j.push_back(item.to_json());
    }
    return j;
}

inline Strata Strata::parse(x::json::Parser parser) {
    Strata result;
    for (auto &item: parser.field<std::vector<Stratum>>())
        result.push_back(std::move(item));
    return result;
}

inline x::json::json Strata::to_json() const {
    x::json::json j = x::json::json::array();
    for (const auto &item: *this) {
        j.push_back(item);
    }
    return j;
}

inline Nodes Nodes::parse(x::json::Parser parser) {
    Nodes result;
    for (auto &item: parser.field<std::vector<Node>>())
        result.push_back(std::move(item));
    return result;
}

inline x::json::json Nodes::to_json() const {
    x::json::json j = x::json::json::array();
    for (const auto &item: *this) {
        j.push_back(item.to_json());
    }
    return j;
}

}
