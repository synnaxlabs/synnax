// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <type_traits>
#include <utility>

#include "x/cpp/errors/errors.h"

#include "arc/cpp/ir/types.gen.h"
#include "arc/cpp/types/proto.gen.h"
#include "arc/go/ir/pb/ir.pb.h"

namespace arc::ir {

inline ::arc::ir::pb::Handle Handle::to_proto() const {
    ::arc::ir::pb::Handle pb;
    pb.set_node(this->node);
    pb.set_param(this->param);
    return pb;
}

inline std::pair<Handle, x::errors::Error>
Handle::from_proto(const ::arc::ir::pb::Handle &pb) {
    Handle cpp;
    cpp.node = pb.node();
    cpp.param = pb.param();
    return {cpp, x::errors::NIL};
}

inline ::arc::ir::pb::Edge Edge::to_proto() const {
    ::arc::ir::pb::Edge pb;
    *pb.mutable_source() = this->source.to_proto();
    *pb.mutable_target() = this->target.to_proto();
    pb.set_kind(static_cast<::arc::ir::pb::EdgeKind>(this->kind));
    return pb;
}

inline std::pair<Edge, x::errors::Error>
Edge::from_proto(const ::arc::ir::pb::Edge &pb) {
    Edge cpp;
    {
        auto [val, err] = Handle::from_proto(pb.source());
        if (err) return {{}, err};
        cpp.source = val;
    }
    {
        auto [val, err] = Handle::from_proto(pb.target());
        if (err) return {{}, err};
        cpp.target = val;
    }
    cpp.kind = static_cast<EdgeKind>(pb.kind());
    return {cpp, x::errors::NIL};
}

inline ::arc::ir::pb::Stage Stage::to_proto() const {
    ::arc::ir::pb::Stage pb;
    pb.set_key(this->key);
    for (const auto &item: this->nodes)
        pb.add_nodes(item);
    for (const auto &item: this->strata) {
        auto *wrapper = pb.add_strata();
        for (const auto &v: item)
            wrapper->add_values(v);
    };
    return pb;
}

inline std::pair<Stage, x::errors::Error>
Stage::from_proto(const ::arc::ir::pb::Stage &pb) {
    Stage cpp;
    cpp.key = pb.key();
    for (const auto &item: pb.nodes())
        cpp.nodes.push_back(item);
    for (const auto &wrapper: pb.strata())
        cpp.strata.push_back({wrapper.values().begin(), wrapper.values().end()});
    return {cpp, x::errors::NIL};
}

inline ::arc::ir::pb::Sequence Sequence::to_proto() const {
    ::arc::ir::pb::Sequence pb;
    pb.set_key(this->key);
    for (const auto &item: this->stages)
        *pb.add_stages() = item.to_proto();
    return pb;
}

inline std::pair<Sequence, x::errors::Error>
Sequence::from_proto(const ::arc::ir::pb::Sequence &pb) {
    Sequence cpp;
    cpp.key = pb.key();
    for (const auto &item: pb.stages()) {
        auto [v, err] = Stage::from_proto(item);
        if (err) return {{}, err};
        cpp.stages.push_back(v);
    }
    return {cpp, x::errors::NIL};
}

inline ::arc::ir::pb::Body Body::to_proto() const {
    ::arc::ir::pb::Body pb;
    pb.set_raw(this->raw);
    return pb;
}

inline std::pair<Body, x::errors::Error>
Body::from_proto(const ::arc::ir::pb::Body &pb) {
    Body cpp;
    cpp.raw = pb.raw();
    return {cpp, x::errors::NIL};
}

inline ::arc::ir::pb::Function Function::to_proto() const {
    ::arc::ir::pb::Function pb;
    pb.set_key(this->key);
    *pb.mutable_body() = this->body.to_proto();
    for (const auto &item: this->config)
        *pb.add_config() = item.to_proto();
    for (const auto &item: this->inputs)
        *pb.add_inputs() = item.to_proto();
    for (const auto &item: this->outputs)
        *pb.add_outputs() = item.to_proto();
    *pb.mutable_channels() = this->channels.to_proto();
    return pb;
}

inline std::pair<Function, x::errors::Error>
Function::from_proto(const ::arc::ir::pb::Function &pb) {
    Function cpp;
    cpp.key = pb.key();
    {
        auto [val, err] = Body::from_proto(pb.body());
        if (err) return {{}, err};
        cpp.body = val;
    }
    for (const auto &item: pb.config()) {
        auto [v, err] = ::arc::types::Param::from_proto(item);
        if (err) return {{}, err};
        cpp.config.push_back(v);
    }
    for (const auto &item: pb.inputs()) {
        auto [v, err] = ::arc::types::Param::from_proto(item);
        if (err) return {{}, err};
        cpp.inputs.push_back(v);
    }
    for (const auto &item: pb.outputs()) {
        auto [v, err] = ::arc::types::Param::from_proto(item);
        if (err) return {{}, err};
        cpp.outputs.push_back(v);
    }
    {
        auto [val, err] = ::arc::types::Channels::from_proto(pb.channels());
        if (err) return {{}, err};
        cpp.channels = val;
    }
    return {cpp, x::errors::NIL};
}

inline ::arc::ir::pb::Node Node::to_proto() const {
    ::arc::ir::pb::Node pb;
    pb.set_key(this->key);
    pb.set_type(this->type);
    for (const auto &item: this->config)
        *pb.add_config() = item.to_proto();
    for (const auto &item: this->inputs)
        *pb.add_inputs() = item.to_proto();
    for (const auto &item: this->outputs)
        *pb.add_outputs() = item.to_proto();
    *pb.mutable_channels() = this->channels.to_proto();
    return pb;
}

inline std::pair<Node, x::errors::Error>
Node::from_proto(const ::arc::ir::pb::Node &pb) {
    Node cpp;
    cpp.key = pb.key();
    cpp.type = pb.type();
    for (const auto &item: pb.config()) {
        auto [v, err] = ::arc::types::Param::from_proto(item);
        if (err) return {{}, err};
        cpp.config.push_back(v);
    }
    for (const auto &item: pb.inputs()) {
        auto [v, err] = ::arc::types::Param::from_proto(item);
        if (err) return {{}, err};
        cpp.inputs.push_back(v);
    }
    for (const auto &item: pb.outputs()) {
        auto [v, err] = ::arc::types::Param::from_proto(item);
        if (err) return {{}, err};
        cpp.outputs.push_back(v);
    }
    {
        auto [val, err] = ::arc::types::Channels::from_proto(pb.channels());
        if (err) return {{}, err};
        cpp.channels = val;
    }
    return {cpp, x::errors::NIL};
}

inline ::arc::ir::pb::IR IR::to_proto() const {
    ::arc::ir::pb::IR pb;
    for (const auto &item: this->functions)
        *pb.add_functions() = item.to_proto();
    for (const auto &item: this->nodes)
        *pb.add_nodes() = item.to_proto();
    for (const auto &item: this->edges)
        *pb.add_edges() = item.to_proto();
    for (const auto &item: this->strata) {
        auto *wrapper = pb.add_strata();
        for (const auto &v: item)
            wrapper->add_values(v);
    };
    for (const auto &item: this->sequences)
        *pb.add_sequences() = item.to_proto();
    return pb;
}

inline std::pair<IR, x::errors::Error> IR::from_proto(const ::arc::ir::pb::IR &pb) {
    IR cpp;
    for (const auto &item: pb.functions()) {
        auto [v, err] = Function::from_proto(item);
        if (err) return {{}, err};
        cpp.functions.push_back(v);
    }
    for (const auto &item: pb.nodes()) {
        auto [v, err] = Node::from_proto(item);
        if (err) return {{}, err};
        cpp.nodes.push_back(v);
    }
    for (const auto &item: pb.edges()) {
        auto [v, err] = Edge::from_proto(item);
        if (err) return {{}, err};
        cpp.edges.push_back(v);
    }
    for (const auto &wrapper: pb.strata())
        cpp.strata.push_back({wrapper.values().begin(), wrapper.values().end()});
    for (const auto &item: pb.sequences()) {
        auto [v, err] = Sequence::from_proto(item);
        if (err) return {{}, err};
        cpp.sequences.push_back(v);
    }
    return {cpp, x::errors::NIL};
}

}
