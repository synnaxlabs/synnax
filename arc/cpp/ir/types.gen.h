// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <string>
#include <utility>
#include <vector>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/json.h"

#include "arc/cpp/types/types.gen.h"
#include "arc/go/ir/pb/ir.pb.h"

namespace arc::ir {

struct Handle;
struct Body;
struct Node;
struct Edge;
struct Function;
struct Stage;
struct Sequence;
struct IR;

enum class EdgeKind : std::uint8_t {
    Continuous = 1,
    OneShot = 2,
};

using Stratum = std::vector<std::string>;

struct Handle {
    std::string node;
    std::string param;

    static Handle parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Handle;
    [[nodiscard]] ::arc::ir::pb::Handle to_proto() const;
    static std::pair<Handle, x::errors::Error>
    from_proto(const ::arc::ir::pb::Handle &pb);
};

struct Body {
    std::string raw;

    static Body parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Body;
    [[nodiscard]] ::arc::ir::pb::Body to_proto() const;
    static std::pair<Body, x::errors::Error> from_proto(const ::arc::ir::pb::Body &pb);
};

struct Node {
    std::string key;
    std::string type;
    arc::types::Params config;
    arc::types::Params inputs;
    arc::types::Params outputs;
    arc::types::Channels channels;

    static Node parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Node;
    [[nodiscard]] ::arc::ir::pb::Node to_proto() const;
    static std::pair<Node, x::errors::Error> from_proto(const ::arc::ir::pb::Node &pb);
};

struct Strata : private std::vector<Stratum> {
    using Base = std::vector<Stratum>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Strata() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Strata parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct Edge {
    Handle source;
    Handle target;
    EdgeKind kind;

    static Edge parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Edge;
    [[nodiscard]] ::arc::ir::pb::Edge to_proto() const;
    static std::pair<Edge, x::errors::Error> from_proto(const ::arc::ir::pb::Edge &pb);
};

struct Function {
    std::string key;
    Body body;
    arc::types::Params config;
    arc::types::Params inputs;
    arc::types::Params outputs;
    arc::types::Channels channels;

    static Function parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Function;
    [[nodiscard]] ::arc::ir::pb::Function to_proto() const;
    static std::pair<Function, x::errors::Error>
    from_proto(const ::arc::ir::pb::Function &pb);
};

struct Nodes : private std::vector<Node> {
    using Base = std::vector<Node>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Nodes() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Nodes parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct Stage {
    std::string key;
    std::vector<std::string> nodes;
    Strata strata;

    static Stage parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Stage;
    [[nodiscard]] ::arc::ir::pb::Stage to_proto() const;
    static std::pair<Stage, x::errors::Error>
    from_proto(const ::arc::ir::pb::Stage &pb);
};

struct Edges : private std::vector<Edge> {
    using Base = std::vector<Edge>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Edges() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Edges parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct Functions : private std::vector<Function> {
    using Base = std::vector<Function>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Functions() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Functions parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct Stages : private std::vector<Stage> {
    using Base = std::vector<Stage>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Stages() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Stages parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct Sequence {
    std::string key;
    std::vector<Stage> stages;

    static Sequence parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Sequence;
    [[nodiscard]] ::arc::ir::pb::Sequence to_proto() const;
    static std::pair<Sequence, x::errors::Error>
    from_proto(const ::arc::ir::pb::Sequence &pb);
};

struct Sequences : private std::vector<Sequence> {
    using Base = std::vector<Sequence>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Sequences() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Sequences parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct IR {
    Functions functions;
    Nodes nodes;
    Edges edges;
    Strata strata;
    Sequences sequences;

    static IR parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::IR;
    [[nodiscard]] ::arc::ir::pb::IR to_proto() const;
    static std::pair<IR, x::errors::Error> from_proto(const ::arc::ir::pb::IR &pb);
};
}
