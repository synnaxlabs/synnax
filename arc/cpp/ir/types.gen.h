// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <optional>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/json.h"

#include "arc/cpp/types/types.gen.h"
#include "arc/go/ir/pb/ir.pb.h"

namespace arc::ir {

struct Handle;
struct Body;
struct Node;
struct Function;
struct Edge;
struct Stage;
struct Sequence;
struct IR;

enum class EdgeKind : std::uint8_t {
    Unspecified = 0,
    Continuous = 1,
    OneShot = 2,
};

using Stratum = std::vector<std::string>;

/// @brief Handle is a reference to a specific parameter on a specific node in the
/// dataflow graph.
struct Handle {
    /// @brief node is the node identifier.
    std::string node;
    /// @brief param is the parameter name (input or output).
    std::string param;

    static Handle parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Handle;
    [[nodiscard]] ::arc::ir::pb::Handle to_proto() const;
    static std::pair<Handle, x::errors::Error>
    from_proto(const ::arc::ir::pb::Handle &pb);
};

/// @brief Body is raw function body source code with optional parsed AST.
struct Body {
    /// @brief raw is the raw source code text.
    std::string raw;

    static Body parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Body;
    [[nodiscard]] ::arc::ir::pb::Body to_proto() const;
    static std::pair<Body, x::errors::Error> from_proto(const ::arc::ir::pb::Body &pb);
};

/// @brief Node is a concrete instantiation of a function with typed parameters and
/// configuration values.
struct Node {
    /// @brief key is the unique identifier for this node instance.
    std::string key;
    /// @brief type is the function type being instantiated.
    std::string type;
    /// @brief config contains configuration parameter values.
    ::arc::types::Params config;
    /// @brief inputs contains input parameter type signatures.
    ::arc::types::Params inputs;
    /// @brief outputs contains output parameter type signatures.
    ::arc::types::Params outputs;
    /// @brief channels contains channel read/write mappings.
    ::arc::types::Channels channels;

    static Node parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Node;
    [[nodiscard]] ::arc::ir::pb::Node to_proto() const;
    static std::pair<Node, x::errors::Error> from_proto(const ::arc::ir::pb::Node &pb);
};

struct Strata : private std::vector<Stratum> {
    using Base = std::vector<Stratum>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Strata() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Strata parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

/// @brief Function is a function template definition with typed parameters, serving as
/// a blueprint for node instantiation.
struct Function {
    /// @brief key is the function identifier (template name).
    std::string key;
    /// @brief body is raw source code for user-defined functions.
    Body body;
    /// @brief config contains configuration parameter definitions.
    ::arc::types::Params config;
    /// @brief inputs contains input parameter definitions.
    ::arc::types::Params inputs;
    /// @brief outputs contains output parameter definitions.
    ::arc::types::Params outputs;
    /// @brief channels contains channel read/write declarations.
    ::arc::types::Channels channels;

    static Function parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Function;
    [[nodiscard]] ::arc::ir::pb::Function to_proto() const;
    static std::pair<Function, x::errors::Error>
    from_proto(const ::arc::ir::pb::Function &pb);
};

struct Nodes : private std::vector<Node> {
    using Base = std::vector<Node>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Nodes() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Nodes parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

/// @brief Edge is a dataflow connection between node parameters in the Arc graph.
struct Edge {
    /// @brief source is the source node parameter producing data.
    Handle source;
    /// @brief target is the target node parameter consuming data.
    Handle target;
    /// @brief kind defines execution semantics for this connection.
    EdgeKind kind;

    static Edge parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Edge;
    [[nodiscard]] ::arc::ir::pb::Edge to_proto() const;
    static std::pair<Edge, x::errors::Error> from_proto(const ::arc::ir::pb::Edge &pb);
};

/// @brief Stage is a stage in a sequence state machine, containing active nodes and
/// their execution stratification.
struct Stage {
    /// @brief key is the stage identifier.
    std::string key;
    /// @brief nodes contains node keys active in this stage.
    std::vector<std::string> nodes;
    /// @brief strata contains execution stratification for nodes in this stage.
    Strata strata;

    static Stage parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Stage;
    [[nodiscard]] ::arc::ir::pb::Stage to_proto() const;
    static std::pair<Stage, x::errors::Error>
    from_proto(const ::arc::ir::pb::Stage &pb);
};

struct Functions : private std::vector<Function> {
    using Base = std::vector<Function>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Functions() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Functions parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct Edges : private std::vector<Edge> {
    using Base = std::vector<Edge>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Edges() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Edges parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct Stages : private std::vector<Stage> {
    using Base = std::vector<Stage>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Stages() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Stages parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

/// @brief Sequence is a state machine defining ordered stages of execution, where entry
/// point is always the first stage.
struct Sequence {
    /// @brief key is the sequence identifier.
    std::string key;
    /// @brief stages contains ordered stages in this sequence.
    std::vector<Stage> stages;

    static Sequence parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Sequence;
    [[nodiscard]] ::arc::ir::pb::Sequence to_proto() const;
    static std::pair<Sequence, x::errors::Error>
    from_proto(const ::arc::ir::pb::Sequence &pb);
};

struct Sequences : private std::vector<Sequence> {
    using Base = std::vector<Sequence>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Sequences() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Sequences parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

/// @brief IR is the intermediate representation of an Arc program as a dataflow graph
/// with stratified execution, bridging semantic analysis and WebAssembly compilation.
struct IR {
    /// @brief functions contains function template definitions.
    Functions functions;
    /// @brief nodes contains node instantiations.
    Nodes nodes;
    /// @brief edges contains dataflow connections.
    Edges edges;
    /// @brief strata contains execution stratification layers.
    Strata strata;
    /// @brief sequences contains state machine definitions.
    Sequences sequences;

    static IR parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::IR;
    [[nodiscard]] ::arc::ir::pb::IR to_proto() const;
    static std::pair<IR, x::errors::Error> from_proto(const ::arc::ir::pb::IR &pb);

    // Custom methods
    [[nodiscard]] const Node &node(const std::string &key) const;
    [[nodiscard]] const Function &function(const std::string &key) const;
    [[nodiscard]] std::optional<Edge> edge_to(const Handle &target) const;
    [[nodiscard]] std::unordered_map<std::string, std::vector<Edge>>
    edges_from(const std::string &node_key) const;
};
}
