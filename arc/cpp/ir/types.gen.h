// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <string>
#include <utility>
#include <vector>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/json.h"

#include "arc/cpp/types/types.gen.h"
#include "arc/go/ir/pb/ir.pb.h"

namespace arc::ir {

struct Handle;
struct Body;
struct Node;
struct Edge;
struct Function;
struct Stage;
struct Sequence;
struct IR;

enum class EdgeKind : std::uint8_t {
    Continuous = 1,
    OneShot = 2,
};

using Stratum = std::vector<std::string>;

struct Handle {
    std::string node;
    std::string param;

    static Handle parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Handle;
    [[nodiscard]] ::arc::ir::pb::Handle to_proto() const;
    static std::pair<Handle, x::errors::Error>
    from_proto(const ::arc::ir::pb::Handle &pb);
};

struct Body {
    std::string raw;

    static Body parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Body;
    [[nodiscard]] ::arc::ir::pb::Body to_proto() const;
    static std::pair<Body, x::errors::Error> from_proto(const ::arc::ir::pb::Body &pb);
};

struct Node {
    std::string key;
    std::string type;
    arc::types::Params config;
    arc::types::Params inputs;
    arc::types::Params outputs;
    arc::types::Channels channels;

    static Node parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Node;
    [[nodiscard]] ::arc::ir::pb::Node to_proto() const;
    static std::pair<Node, x::errors::Error> from_proto(const ::arc::ir::pb::Node &pb);
};

using Strata = std::vector<Stratum>;

struct Edge {
    Handle source;
    Handle target;
    EdgeKind kind;

    static Edge parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Edge;
    [[nodiscard]] ::arc::ir::pb::Edge to_proto() const;
    static std::pair<Edge, x::errors::Error> from_proto(const ::arc::ir::pb::Edge &pb);
};

struct Function {
    std::string key;
    Body body;
    arc::types::Params config;
    arc::types::Params inputs;
    arc::types::Params outputs;
    arc::types::Channels channels;

    static Function parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Function;
    [[nodiscard]] ::arc::ir::pb::Function to_proto() const;
    static std::pair<Function, x::errors::Error>
    from_proto(const ::arc::ir::pb::Function &pb);
};

using Nodes = std::vector<Node>;

struct Stage {
    std::string key;
    std::vector<std::string> nodes;
    Strata strata;

    static Stage parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Stage;
    [[nodiscard]] ::arc::ir::pb::Stage to_proto() const;
    static std::pair<Stage, x::errors::Error>
    from_proto(const ::arc::ir::pb::Stage &pb);
};

using Edges = std::vector<Edge>;

using Functions = std::vector<Function>;

using Stages = std::vector<Stage>;

struct Sequence {
    std::string key;
    std::vector<Stage> stages;

    static Sequence parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::Sequence;
    [[nodiscard]] ::arc::ir::pb::Sequence to_proto() const;
    static std::pair<Sequence, x::errors::Error>
    from_proto(const ::arc::ir::pb::Sequence &pb);
};

using Sequences = std::vector<Sequence>;

struct IR {
    Functions functions;
    Nodes nodes;
    Edges edges;
    Strata strata;
    Sequences sequences;

    static IR parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::ir::pb::IR;
    [[nodiscard]] ::arc::ir::pb::IR to_proto() const;
    static std::pair<IR, x::errors::Error> from_proto(const ::arc::ir::pb::IR &pb);
};
}
