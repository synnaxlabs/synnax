// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <utility>

#include "x/cpp/errors/errors.h"
#include "x/cpp/pb/pb.h"

#include "arc/cpp/compiler/proto.gen.h"
#include "arc/cpp/ir/json.gen.h"
#include "arc/cpp/ir/proto.gen.h"
#include "arc/cpp/module/json.gen.h"
#include "arc/cpp/module/types.gen.h"
#include "arc/go/module/pb/module.pb.h"

namespace arc::module {

inline ::arc::module::pb::Module Module::to_proto() const {
    ::arc::module::pb::Module pb;
    for (const auto &item: this->functions)
        *pb.add_functions() = item.to_proto();
    for (const auto &item: this->nodes)
        *pb.add_nodes() = item.to_proto();
    for (const auto &item: this->edges)
        *pb.add_edges() = item.to_proto();
    for (const auto &item: this->strata) {
        auto *wrapper = pb.add_strata();
        for (const auto &v: item)
            wrapper->add_values(v);
    }
    for (const auto &item: this->sequences)
        *pb.add_sequences() = item.to_proto();
    pb.set_wasm(this->wasm.data(), this->wasm.size());
    for (const auto &[k, v]: this->output_memory_bases)
        (*pb.mutable_output_memory_bases())[k] = v;
    return pb;
}

inline std::pair<Module, x::errors::Error>
Module::from_proto(const ::arc::module::pb::Module &pb) {
    Module cpp;
    if (auto err = x::pb::from_proto_repeated<::arc::ir::Function>(
            cpp.functions,
            pb.functions()
        ))
        return {{}, err};
    if (auto err = x::pb::from_proto_repeated<::arc::ir::Node>(cpp.nodes, pb.nodes()))
        return {{}, err};
    if (auto err = x::pb::from_proto_repeated<::arc::ir::Edge>(cpp.edges, pb.edges()))
        return {{}, err};
    for (const auto &wrapper: pb.strata())
        cpp.strata.push_back({wrapper.values().begin(), wrapper.values().end()});
    if (auto err = x::pb::from_proto_repeated<::arc::ir::Sequence>(
            cpp.sequences,
            pb.sequences()
        ))
        return {{}, err};
    cpp.wasm.assign(pb.wasm().begin(), pb.wasm().end());
    for (const auto &[k, v]: pb.output_memory_bases())
        cpp.output_memory_bases[k] = v;
    return {cpp, x::errors::NIL};
}

}
