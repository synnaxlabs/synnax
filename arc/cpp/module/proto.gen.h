// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <type_traits>
#include <utility>

#include "x/cpp/errors/errors.h"

#include "arc/cpp/ir/proto.gen.h"
#include "arc/cpp/module/types.gen.h"
#include "arc/go/module/pb/module.pb.h"

namespace arc::module {

inline ::arc::module::pb::Module Module::to_proto() const {
    ::arc::module::pb::Module pb;
    for (const auto &item: this->functions)
        *pb.add_functions() = item.to_proto();
    for (const auto &item: this->nodes)
        *pb.add_nodes() = item.to_proto();
    for (const auto &item: this->edges)
        *pb.add_edges() = item.to_proto();
    for (const auto &item: this->strata)
        pb.add_strata(item);
    for (const auto &item: this->sequences)
        *pb.add_sequences() = item.to_proto();
    pb.set_WASM(this->WASM);
    for (const auto &[k, v]: this->OutputMemoryBases)
        (*pb.mutable_OutputMemoryBases())[k] = v;
    return pb;
}

inline std::pair<Module, x::errors::Error>
Module::from_proto(const ::arc::module::pb::Module &pb) {
    Module cpp;
    for (const auto &item: pb.functions()) {
        auto [v, err] = arc::ir::Function::from_proto(item);
        if (err) return {{}, err};
        cpp.functions.push_back(v);
    }
    for (const auto &item: pb.nodes()) {
        auto [v, err] = arc::ir::Node::from_proto(item);
        if (err) return {{}, err};
        cpp.nodes.push_back(v);
    }
    for (const auto &item: pb.edges()) {
        auto [v, err] = arc::ir::Edge::from_proto(item);
        if (err) return {{}, err};
        cpp.edges.push_back(v);
    }
    for (const auto &item: pb.strata())
        cpp.strata.push_back(item);
    for (const auto &item: pb.sequences()) {
        auto [v, err] = arc::ir::Sequence::from_proto(item);
        if (err) return {{}, err};
        cpp.sequences.push_back(v);
    }
    cpp.WASM = pb.WASM();
    for (const auto &[k, v]: pb.OutputMemoryBases())
        cpp.OutputMemoryBases[k] = v;
    return {cpp, x::errors::NIL};
}

}
