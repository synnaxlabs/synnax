// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <cstdint>
#include <optional>
#include <ostream>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/json.h"
#include "x/cpp/mem/indirect.h"
#include "x/cpp/telem/telem.h"

#include "arc/go/types/pb/types.pb.h"

namespace arc::types {

struct Channels;
struct Dimensions;
struct Unit;
struct FunctionProperties;
struct Type;
struct Param;

enum class Kind : std::uint8_t {
    Invalid = 0,
    U8 = 1,
    U16 = 2,
    U32 = 3,
    U64 = 4,
    I8 = 5,
    I16 = 6,
    I32 = 7,
    I64 = 8,
    F32 = 9,
    F64 = 10,
    String = 11,
    Chan = 14,
    Series = 15,
    Variable = 16,
    NumericConstant = 17,
    IntegerConstant = 18,
    FloatConstant = 19,
    Function = 20,
    Sequence = 21,
    Stage = 22,
};

/// @brief Channels contains channel declarations for reading from and writing to Synnax
/// channels.
struct Channels {
    /// @brief read contains readable channel indices mapped to parameter names.
    std::unordered_map<std::uint32_t, std::string> read;
    /// @brief write contains writable channel indices mapped to parameter names.
    std::unordered_map<std::uint32_t, std::string> write;

    static Channels parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Channels;
    [[nodiscard]] ::arc::types::pb::Channels to_proto() const;
    static std::pair<Channels, x::errors::Error>
    from_proto(const ::arc::types::pb::Channels &pb);
};

/// @brief Dimensions contains physical dimension exponents for dimensional analysis (SI
/// base quantities).
struct Dimensions {
    /// @brief length is the length dimension exponent (meters).
    std::int8_t length = 0;
    /// @brief mass is the mass dimension exponent (kilograms).
    std::int8_t mass = 0;
    /// @brief time is the time dimension exponent (seconds).
    std::int8_t time = 0;
    /// @brief current is the electric current dimension exponent (amperes).
    std::int8_t current = 0;
    /// @brief temperature is the temperature dimension exponent (kelvin).
    std::int8_t temperature = 0;
    /// @brief angle is the angle dimension exponent (radians).
    std::int8_t angle = 0;
    /// @brief count is the count dimension exponent (dimensionless quantity).
    std::int8_t count = 0;
    /// @brief data is the data size dimension exponent (bytes).
    std::int8_t data = 0;

    static Dimensions parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Dimensions;
    [[nodiscard]] ::arc::types::pb::Dimensions to_proto() const;
    static std::pair<Dimensions, x::errors::Error>
    from_proto(const ::arc::types::pb::Dimensions &pb);

    // Custom methods
    bool operator==(const Dimensions &other) const;
    [[nodiscard]] bool is_zero() const;
};

/// @brief Unit is a physical unit with dimensions and scale factor for unit-aware
/// computation.
struct Unit {
    /// @brief dimensions contains physical dimension exponents.
    Dimensions dimensions;
    /// @brief scale is the scale factor relative to SI base units.
    double scale = 0;
    /// @brief name is the unit name (e.g., 'psi', 'ns', 'm/s').
    std::string name;

    static Unit parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Unit;
    [[nodiscard]] ::arc::types::pb::Unit to_proto() const;
    static std::pair<Unit, x::errors::Error>
    from_proto(const ::arc::types::pb::Unit &pb);

    // Custom methods
    bool operator==(const Unit &other) const;
    [[nodiscard]] bool is_timestamp() const;
};

struct Params : private std::vector<Param> {
    using Base = std::vector<Param>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Params() = default;

    // Container interface
    using Base::begin;
    using Base::capacity;
    using Base::cbegin;
    using Base::cend;
    using Base::const_iterator;
    using Base::const_reference;
    using Base::const_reverse_iterator;
    using Base::crbegin;
    using Base::crend;
    using Base::difference_type;
    using Base::empty;
    using Base::end;
    using Base::iterator;
    using Base::max_size;
    using Base::rbegin;
    using Base::reference;
    using Base::rend;
    using Base::reserve;
    using Base::reverse_iterator;
    using Base::shrink_to_fit;
    using Base::size;
    using Base::size_type;
    using Base::value_type;
    using Base::operator[];
    using Base::assign;
    using Base::at;
    using Base::back;
    using Base::clear;
    using Base::data;
    using Base::emplace;
    using Base::emplace_back;
    using Base::erase;
    using Base::front;
    using Base::insert;
    using Base::pop_back;
    using Base::push_back;
    using Base::resize;
    using Base::swap;

    static Params parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

/// @brief FunctionProperties contains common parameter definitions for function-like
/// types.
struct FunctionProperties {
    /// @brief inputs contains input parameter definitions.
    Params inputs;
    /// @brief outputs contains output parameter definitions.
    Params outputs;
    /// @brief config contains configuration parameter definitions.
    Params config;

    static FunctionProperties parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::FunctionProperties;
    [[nodiscard]] ::arc::types::pb::FunctionProperties to_proto() const;
    static std::pair<FunctionProperties, x::errors::Error>
    from_proto(const ::arc::types::pb::FunctionProperties &pb);
};

/// @brief Type is a type in Arc's type system with optional element type for compounds,
/// physical units, and constraints.
struct Type : public FunctionProperties {
    /// @brief kind is the type category (primitive, compound, or meta-type).
    Kind kind;
    /// @brief name is the type name for variables and user-defined types.
    std::string name;
    /// @brief elem is the element type for compound types (chan, series).
    x::mem::indirect<Type> elem;
    /// @brief unit is the physical unit metadata for dimensional analysis.
    std::optional<Unit> unit;
    /// @brief constraint is the type constraint for type variables.
    x::mem::indirect<Type> constraint;

    static Type parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Type;
    [[nodiscard]] ::arc::types::pb::Type to_proto() const;
    static std::pair<Type, x::errors::Error>
    from_proto(const ::arc::types::pb::Type &pb);

    // Custom methods
    [[nodiscard]] size_t density() const;
    [[nodiscard]] bool is_valid() const;
    [[nodiscard]] bool is_timestamp() const;
    [[nodiscard]] std::string to_string() const;
    [[nodiscard]] x::telem::DataType telem() const;
    friend std::ostream &operator<<(std::ostream &os, const Type &t);
};

/// @brief Param is a named, typed parameter with optional default value.
struct Param {
    /// @brief name is the parameter name.
    std::string name;
    /// @brief type is the parameter type.
    Type type;
    /// @brief value is an optional default value.
    x::json::json value;

    static Param parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Param;
    [[nodiscard]] ::arc::types::pb::Param to_proto() const;
    static std::pair<Param, x::errors::Error>
    from_proto(const ::arc::types::pb::Param &pb);
};
}
