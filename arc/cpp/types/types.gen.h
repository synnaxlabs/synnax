// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <cstdint>
#include <optional>
#include <ostream>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/json.h"
#include "x/cpp/mem/indirect.h"
#include "x/cpp/telem/telem.h"

#include "arc/go/types/pb/types.pb.h"

namespace arc::types {

struct Channels;
struct Dimensions;
struct Unit;
struct FunctionProperties;
struct Type;
struct Param;

enum class Kind : std::uint8_t {
    Invalid = 0,
    U8 = 1,
    U16 = 2,
    U32 = 3,
    U64 = 4,
    I8 = 5,
    I16 = 6,
    I32 = 7,
    I64 = 8,
    F32 = 9,
    F64 = 10,
    String = 11,
    Chan = 14,
    Series = 15,
    Variable = 16,
    NumericConstant = 17,
    IntegerConstant = 18,
    FloatConstant = 19,
    Function = 20,
    Sequence = 21,
    Stage = 22,
};

struct Channels {
    std::unordered_map<std::uint32_t, std::string> read;
    std::unordered_map<std::uint32_t, std::string> write;

    static Channels parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Channels;
    [[nodiscard]] ::arc::types::pb::Channels to_proto() const;
    static std::pair<Channels, x::errors::Error>
    from_proto(const ::arc::types::pb::Channels &pb);
};

struct Dimensions {
    std::int8_t length;
    std::int8_t mass;
    std::int8_t time;
    std::int8_t current;
    std::int8_t temperature;
    std::int8_t angle;
    std::int8_t count;
    std::int8_t data;

    static Dimensions parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Dimensions;
    [[nodiscard]] ::arc::types::pb::Dimensions to_proto() const;
    static std::pair<Dimensions, x::errors::Error>
    from_proto(const ::arc::types::pb::Dimensions &pb);

    // Custom methods
    bool operator==(const Dimensions &other) const;
    [[nodiscard]] bool is_zero() const;
};

struct Unit {
    Dimensions dimensions;
    double scale;
    std::string name;

    static Unit parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Unit;
    [[nodiscard]] ::arc::types::pb::Unit to_proto() const;
    static std::pair<Unit, x::errors::Error>
    from_proto(const ::arc::types::pb::Unit &pb);

    // Custom methods
    bool operator==(const Unit &other) const;
    [[nodiscard]] bool is_timestamp() const;
};

using Params = std::vector<Param>;

struct FunctionProperties {
    Params inputs;
    Params outputs;
    Params config;

    static FunctionProperties parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::FunctionProperties;
    [[nodiscard]] ::arc::types::pb::FunctionProperties to_proto() const;
    static std::pair<FunctionProperties, x::errors::Error>
    from_proto(const ::arc::types::pb::FunctionProperties &pb);
};

struct Type {
    Params inputs;
    Params outputs;
    Params config;
    Kind kind;
    std::string name;
    x::mem::indirect<Type> elem;
    std::optional<Unit> unit;
    x::mem::indirect<Type> constraint;

    static Type parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Type;
    [[nodiscard]] ::arc::types::pb::Type to_proto() const;
    static std::pair<Type, x::errors::Error>
    from_proto(const ::arc::types::pb::Type &pb);

    // Custom methods
    [[nodiscard]] size_t density() const;
    [[nodiscard]] bool is_valid() const;
    [[nodiscard]] bool is_timestamp() const;
    [[nodiscard]] std::string to_string() const;
    [[nodiscard]] x::telem::DataType telem() const;
    friend std::ostream &operator<<(std::ostream &os, const Type &t);
};

struct Param {
    std::string name;
    Type type;
    x::json::json value;

    static Param parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Param;
    [[nodiscard]] ::arc::types::pb::Param to_proto() const;
    static std::pair<Param, x::errors::Error>
    from_proto(const ::arc::types::pb::Param &pb);
};
}
