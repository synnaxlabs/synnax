// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <unordered_map>
#include <cstdint>
#include <string>
#include <utility>
#include <vector>
#include <optional>
#include <ostream>
#include "x/cpp/json/json.h"
#include "x/cpp/errors/errors.h"
#include "arc/go/types/pb/types.pb.h"
#include "x/cpp/mem/indirect.h"
#include "x/cpp/telem/telem.h"


namespace arc::types {

struct Channels;
struct Dimensions;
struct Unit;
struct FunctionProperties;
struct Type;
struct Param;



enum class Kind : std::uint8_t {
    Invalid = 0,
    U8 = 1,
    U16 = 2,
    U32 = 3,
    U64 = 4,
    I8 = 5,
    I16 = 6,
    I32 = 7,
    I64 = 8,
    F32 = 9,
    F64 = 10,
    String = 11,
    Chan = 14,
    Series = 15,
    Variable = 16,
    NumericConstant = 17,
    IntegerConstant = 18,
    FloatConstant = 19,
    Function = 20,
    Sequence = 21,
    Stage = 22,
};

struct Channels {
    std::unordered_map<std::uint32_t, std::string> read;
    std::unordered_map<std::uint32_t, std::string> write;

    static Channels parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Channels;
    [[nodiscard]] ::arc::types::pb::Channels to_proto() const;
    static std::pair<Channels, x::errors::Error> from_proto(const ::arc::types::pb::Channels& pb);
};

struct Dimensions {
    std::int8_t length = 0;
    std::int8_t mass = 0;
    std::int8_t time = 0;
    std::int8_t current = 0;
    std::int8_t temperature = 0;
    std::int8_t angle = 0;
    std::int8_t count = 0;
    std::int8_t data = 0;

    static Dimensions parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Dimensions;
    [[nodiscard]] ::arc::types::pb::Dimensions to_proto() const;
    static std::pair<Dimensions, x::errors::Error> from_proto(const ::arc::types::pb::Dimensions& pb);

    // Custom methods
    bool operator==(const Dimensions& other) const;
    [[nodiscard]] bool is_zero() const;
};

struct Unit {
    Dimensions dimensions;
    double scale = 0;
    std::string name;

    static Unit parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Unit;
    [[nodiscard]] ::arc::types::pb::Unit to_proto() const;
    static std::pair<Unit, x::errors::Error> from_proto(const ::arc::types::pb::Unit& pb);

    // Custom methods
    bool operator==(const Unit& other) const;
    [[nodiscard]] bool is_timestamp() const;
};


struct Params : private std::vector<Param> {
    using Base = std::vector<Param>;

    // Inherit constructors - these are instantiated at point of use, not declaration
    using Base::Base;
    Params() = default;

    // Container interface
    using Base::value_type;
    using Base::iterator;
    using Base::const_iterator;
    using Base::reverse_iterator;
    using Base::const_reverse_iterator;
    using Base::size_type;
    using Base::difference_type;
    using Base::reference;
    using Base::const_reference;
    using Base::begin;
    using Base::end;
    using Base::cbegin;
    using Base::cend;
    using Base::rbegin;
    using Base::rend;
    using Base::crbegin;
    using Base::crend;
    using Base::size;
    using Base::empty;
    using Base::max_size;
    using Base::capacity;
    using Base::reserve;
    using Base::shrink_to_fit;
    using Base::operator[];
    using Base::at;
    using Base::front;
    using Base::back;
    using Base::data;
    using Base::push_back;
    using Base::emplace_back;
    using Base::pop_back;
    using Base::insert;
    using Base::emplace;
    using Base::erase;
    using Base::clear;
    using Base::resize;
    using Base::swap;
    using Base::assign;

    static Params parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;
};

struct FunctionProperties {
    Params inputs;
    Params outputs;
    Params config;

    static FunctionProperties parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::FunctionProperties;
    [[nodiscard]] ::arc::types::pb::FunctionProperties to_proto() const;
    static std::pair<FunctionProperties, x::errors::Error> from_proto(const ::arc::types::pb::FunctionProperties& pb);
};

struct Type : public FunctionProperties {
    Kind kind;
    std::string name;
    x::mem::indirect<Type> elem;
    std::optional<Unit> unit;
    x::mem::indirect<Type> constraint;

    static Type parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Type;
    [[nodiscard]] ::arc::types::pb::Type to_proto() const;
    static std::pair<Type, x::errors::Error> from_proto(const ::arc::types::pb::Type& pb);

    // Custom methods
    [[nodiscard]] size_t density() const;
    [[nodiscard]] bool is_valid() const;
    [[nodiscard]] bool is_timestamp() const;
    [[nodiscard]] std::string to_string() const;
    [[nodiscard]] x::telem::DataType telem() const;
    friend std::ostream& operator<<(std::ostream& os, const Type& t);
};

struct Param {
    std::string name;
    Type type;
    x::json::json value;

    static Param parse(x::json::Parser parser);
    [[nodiscard]] x::json::json to_json() const;

    using proto_type = ::arc::types::pb::Param;
    [[nodiscard]] ::arc::types::pb::Param to_proto() const;
    static std::pair<Param, x::errors::Error> from_proto(const ::arc::types::pb::Param& pb);
};
}
