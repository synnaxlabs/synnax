// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <type_traits>
#include <utility>

#include "x/cpp/errors/errors.h"

#include "arc/cpp/types/types.gen.h"
#include "arc/go/types/pb/types.pb.h"

namespace arc::types {

inline ::arc::types::pb::FunctionProperties FunctionProperties::to_proto() const {
    ::arc::types::pb::FunctionProperties pb;
    pb.set_inputs(this->inputs);
    pb.set_outputs(this->outputs);
    pb.set_config(this->config);
    return pb;
}

inline std::pair<FunctionProperties, x::errors::Error>
FunctionProperties::from_proto(const ::arc::types::pb::FunctionProperties &pb) {
    FunctionProperties cpp;
    cpp.inputs = pb.inputs();
    cpp.outputs = pb.outputs();
    cpp.config = pb.config();
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Type Type::to_proto() const {
    ::arc::types::pb::Type pb;
    pb.set_inputs(this->inputs);
    pb.set_outputs(this->outputs);
    pb.set_config(this->config);
    pb.set_kind(static_cast<::arc::types::pb::Kind>(this->kind));
    pb.set_name(this->name);
    if (this->elem.has_value()) *pb.mutable_elem() = this->elem->to_proto();
    if (this->unit.has_value()) *pb.mutable_unit() = this->unit->to_proto();
    if (this->constraint.has_value())
        *pb.mutable_constraint() = this->constraint->to_proto();
    return pb;
}

inline std::pair<Type, x::errors::Error>
Type::from_proto(const ::arc::types::pb::Type &pb) {
    Type cpp;
    cpp.inputs = pb.inputs();
    cpp.outputs = pb.outputs();
    cpp.config = pb.config();
    cpp.kind = static_cast<Kind>(pb.kind());
    cpp.name = pb.name();
    if (pb.has_elem()) {
        auto [val, err] = Type::from_proto(pb.elem());
        if (err) return {{}, err};
        cpp.elem = val;
    }
    if (pb.has_unit()) {
        auto [val, err] = Unit::from_proto(pb.unit());
        if (err) return {{}, err};
        cpp.unit = val;
    }
    if (pb.has_constraint()) {
        auto [val, err] = Type::from_proto(pb.constraint());
        if (err) return {{}, err};
        cpp.constraint = val;
    }
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Param Param::to_proto() const {
    ::arc::types::pb::Param pb;
    pb.set_name(this->name);
    *pb.mutable_type() = this->type.to_proto();
    pb.set_value(this->value);
    return pb;
}

inline std::pair<Param, x::errors::Error>
Param::from_proto(const ::arc::types::pb::Param &pb) {
    Param cpp;
    cpp.name = pb.name();
    {
        auto [val, err] = Type::from_proto(pb.type());
        if (err) return {{}, err};
        cpp.type = val;
    }
    cpp.value = pb.value();
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Channels Channels::to_proto() const {
    ::arc::types::pb::Channels pb;
    pb.set_read(this->read);
    pb.set_write(this->write);
    return pb;
}

inline std::pair<Channels, x::errors::Error>
Channels::from_proto(const ::arc::types::pb::Channels &pb) {
    Channels cpp;
    cpp.read = pb.read();
    cpp.write = pb.write();
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Dimensions Dimensions::to_proto() const {
    ::arc::types::pb::Dimensions pb;
    pb.set_length(this->length);
    pb.set_mass(this->mass);
    pb.set_time(this->time);
    pb.set_current(this->current);
    pb.set_temperature(this->temperature);
    pb.set_angle(this->angle);
    pb.set_count(this->count);
    pb.set_data(this->data);
    return pb;
}

inline std::pair<Dimensions, x::errors::Error>
Dimensions::from_proto(const ::arc::types::pb::Dimensions &pb) {
    Dimensions cpp;
    cpp.length = pb.length();
    cpp.mass = pb.mass();
    cpp.time = pb.time();
    cpp.current = pb.current();
    cpp.temperature = pb.temperature();
    cpp.angle = pb.angle();
    cpp.count = pb.count();
    cpp.data = pb.data();
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Unit Unit::to_proto() const {
    ::arc::types::pb::Unit pb;
    *pb.mutable_dimensions() = this->dimensions.to_proto();
    pb.set_scale(this->scale);
    pb.set_name(this->name);
    return pb;
}

inline std::pair<Unit, x::errors::Error>
Unit::from_proto(const ::arc::types::pb::Unit &pb) {
    Unit cpp;
    {
        auto [val, err] = Dimensions::from_proto(pb.dimensions());
        if (err) return {{}, err};
        cpp.dimensions = val;
    }
    cpp.scale = pb.scale();
    cpp.name = pb.name();
    return {cpp, x::errors::NIL};
}

}
