// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <utility>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/value.h"
#include "x/cpp/pb/pb.h"

#include "arc/cpp/types/json.gen.h"
#include "arc/cpp/types/types.gen.h"
#include "arc/go/types/pb/types.pb.h"

namespace arc::types {

inline ::arc::types::pb::FunctionProperties FunctionProperties::to_proto() const {
    ::arc::types::pb::FunctionProperties pb;
    for (const auto &item: this->inputs)
        *pb.add_inputs() = item.to_proto();
    for (const auto &item: this->outputs)
        *pb.add_outputs() = item.to_proto();
    for (const auto &item: this->config)
        *pb.add_config() = item.to_proto();
    return pb;
}

inline std::pair<FunctionProperties, x::errors::Error>
FunctionProperties::from_proto(const ::arc::types::pb::FunctionProperties &pb) {
    FunctionProperties cpp;
    if (auto err = x::pb::from_proto_repeated<Param>(cpp.inputs, pb.inputs()))
        return {{}, err};
    if (auto err = x::pb::from_proto_repeated<Param>(cpp.outputs, pb.outputs()))
        return {{}, err};
    if (auto err = x::pb::from_proto_repeated<Param>(cpp.config, pb.config()))
        return {{}, err};
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Type Type::to_proto() const {
    ::arc::types::pb::Type pb;
    for (const auto &item: this->inputs)
        *pb.add_inputs() = item.to_proto();
    for (const auto &item: this->outputs)
        *pb.add_outputs() = item.to_proto();
    for (const auto &item: this->config)
        *pb.add_config() = item.to_proto();
    pb.set_kind(static_cast<::arc::types::pb::Kind>(this->kind));
    pb.set_name(this->name);
    if (this->elem.has_value()) *pb.mutable_elem() = this->elem->to_proto();
    if (this->unit.has_value()) *pb.mutable_unit() = this->unit->to_proto();
    if (this->constraint.has_value())
        *pb.mutable_constraint() = this->constraint->to_proto();
    return pb;
}

inline std::pair<Type, x::errors::Error>
Type::from_proto(const ::arc::types::pb::Type &pb) {
    Type cpp;
    if (auto err = x::pb::from_proto_repeated<Param>(cpp.inputs, pb.inputs()))
        return {{}, err};
    if (auto err = x::pb::from_proto_repeated<Param>(cpp.outputs, pb.outputs()))
        return {{}, err};
    if (auto err = x::pb::from_proto_repeated<Param>(cpp.config, pb.config()))
        return {{}, err};
    cpp.kind = static_cast<Kind>(pb.kind());
    cpp.name = pb.name();
    if (pb.has_elem()) {
        auto [v, err] = Type::from_proto(pb.elem());
        if (err) return {{}, err};
        cpp.elem = v;
    }
    if (pb.has_unit()) {
        auto [v, err] = Unit::from_proto(pb.unit());
        if (err) return {{}, err};
        cpp.unit = v;
    }
    if (pb.has_constraint()) {
        auto [v, err] = Type::from_proto(pb.constraint());
        if (err) return {{}, err};
        cpp.constraint = v;
    }
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Param Param::to_proto() const {
    ::arc::types::pb::Param pb;
    pb.set_name(this->name);
    *pb.mutable_type() = this->type.to_proto();
    *pb.mutable_value() = x::json::to_value(this->value).first;
    return pb;
}

inline std::pair<Param, x::errors::Error>
Param::from_proto(const ::arc::types::pb::Param &pb) {
    Param cpp;
    cpp.name = pb.name();
    {
        auto [v, err] = Type::from_proto(pb.type());
        if (err) return {{}, err};
        cpp.type = v;
    }
    {
        auto [v, err] = x::json::from_value(pb.value());
        if (err) return {{}, err};
        cpp.value = v;
    }
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Channels Channels::to_proto() const {
    ::arc::types::pb::Channels pb;
    for (const auto &[k, v]: this->read)
        (*pb.mutable_read())[k] = v;
    for (const auto &[k, v]: this->write)
        (*pb.mutable_write())[k] = v;
    return pb;
}

inline std::pair<Channels, x::errors::Error>
Channels::from_proto(const ::arc::types::pb::Channels &pb) {
    Channels cpp;
    for (const auto &[k, v]: pb.read())
        cpp.read[k] = v;
    for (const auto &[k, v]: pb.write())
        cpp.write[k] = v;
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Dimensions Dimensions::to_proto() const {
    ::arc::types::pb::Dimensions pb;
    pb.set_length(this->length);
    pb.set_mass(this->mass);
    pb.set_time(this->time);
    pb.set_current(this->current);
    pb.set_temperature(this->temperature);
    pb.set_angle(this->angle);
    pb.set_count(this->count);
    pb.set_data(this->data);
    return pb;
}

inline std::pair<Dimensions, x::errors::Error>
Dimensions::from_proto(const ::arc::types::pb::Dimensions &pb) {
    Dimensions cpp;
    cpp.length = pb.length();
    cpp.mass = pb.mass();
    cpp.time = pb.time();
    cpp.current = pb.current();
    cpp.temperature = pb.temperature();
    cpp.angle = pb.angle();
    cpp.count = pb.count();
    cpp.data = pb.data();
    return {cpp, x::errors::NIL};
}

inline ::arc::types::pb::Unit Unit::to_proto() const {
    ::arc::types::pb::Unit pb;
    *pb.mutable_dimensions() = this->dimensions.to_proto();
    pb.set_scale(this->scale);
    pb.set_name(this->name);
    return pb;
}

inline std::pair<Unit, x::errors::Error>
Unit::from_proto(const ::arc::types::pb::Unit &pb) {
    Unit cpp;
    {
        auto [v, err] = Dimensions::from_proto(pb.dimensions());
        if (err) return {{}, err};
        cpp.dimensions = v;
    }
    cpp.scale = pb.scale();
    cpp.name = pb.name();
    return {cpp, x::errors::NIL};
}

}
