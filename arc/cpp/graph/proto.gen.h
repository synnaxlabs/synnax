// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

#pragma once

#include <type_traits>
#include <utility>

#include "x/cpp/errors/errors.h"
#include "x/cpp/json/struct.h"
#include "x/cpp/spatial/json.gen.h"
#include "x/cpp/spatial/proto.gen.h"

#include "arc/cpp/graph/json.gen.h"
#include "arc/cpp/graph/types.gen.h"
#include "arc/cpp/ir/json.gen.h"
#include "arc/cpp/ir/proto.gen.h"
#include "arc/go/graph/pb/graph.pb.h"

namespace arc::graph {

inline ::arc::graph::pb::Node Node::to_proto() const {
    ::arc::graph::pb::Node pb;
    pb.set_key(this->key);
    pb.set_type(this->type);
    *pb.mutable_config() = x::json::to_struct(this->config).first;
    *pb.mutable_position() = this->position.to_proto();
    return pb;
}

inline std::pair<Node, x::errors::Error>
Node::from_proto(const ::arc::graph::pb::Node &pb) {
    Node cpp;
    cpp.key = pb.key();
    cpp.type = pb.type();
    {
        auto [val, err] = x::json::from_struct(pb.config());
        if (err) return {{}, err};
        cpp.config = val;
    }
    {
        auto [val, err] = ::x::spatial::XY::from_proto(pb.position());
        if (err) return {{}, err};
        cpp.position = val;
    }
    return {cpp, x::errors::NIL};
}

inline ::arc::graph::pb::Viewport Viewport::to_proto() const {
    ::arc::graph::pb::Viewport pb;
    *pb.mutable_position() = this->position.to_proto();
    pb.set_zoom(this->zoom);
    return pb;
}

inline std::pair<Viewport, x::errors::Error>
Viewport::from_proto(const ::arc::graph::pb::Viewport &pb) {
    Viewport cpp;
    {
        auto [val, err] = ::x::spatial::XY::from_proto(pb.position());
        if (err) return {{}, err};
        cpp.position = val;
    }
    cpp.zoom = pb.zoom();
    return {cpp, x::errors::NIL};
}

inline ::arc::graph::pb::Graph Graph::to_proto() const {
    ::arc::graph::pb::Graph pb;
    *pb.mutable_viewport() = this->viewport.to_proto();
    for (const auto &item: this->functions)
        *pb.add_functions() = item.to_proto();
    for (const auto &item: this->edges)
        *pb.add_edges() = item.to_proto();
    for (const auto &item: this->nodes)
        *pb.add_nodes() = item.to_proto();
    return pb;
}

inline std::pair<Graph, x::errors::Error>
Graph::from_proto(const ::arc::graph::pb::Graph &pb) {
    Graph cpp;
    {
        auto [val, err] = Viewport::from_proto(pb.viewport());
        if (err) return {{}, err};
        cpp.viewport = val;
    }
    for (const auto &item: pb.functions()) {
        auto [v, err] = ::arc::ir::Function::from_proto(item);
        if (err) return {{}, err};
        cpp.functions.push_back(v);
    }
    for (const auto &item: pb.edges()) {
        auto [v, err] = ::arc::ir::Edge::from_proto(item);
        if (err) return {{}, err};
        cpp.edges.push_back(v);
    }
    for (const auto &item: pb.nodes()) {
        auto [v, err] = Node::from_proto(item);
        if (err) return {{}, err};
        cpp.nodes.push_back(v);
    }
    return {cpp, x::errors::NIL};
}

}
