// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by go generate; DO NOT EDIT.

package bindings

import (
	"context"
	"math"
	"sync"

	"github.com/synnaxlabs/arc/runtime/state"
	xmath "github.com/synnaxlabs/x/math"
	"github.com/synnaxlabs/x/telem"
	"github.com/tetratelabs/wazero/api"
)

// Runtime provides the actual implementation of Arc runtime functions.
// This is the "business logic" layer that the bindings call.
type Runtime struct {
	state  *state.State
	memory api.Memory // WASM memory for reading string literals

	// String storage - handle to string mapping
	strings             map[uint32]string
	stringHandleCounter uint32

	// State storage for stateful variables
	// Key: (funcID << 32) | varID
	stateU8     map[uint64]uint8
	stateU16    map[uint64]uint16
	stateU32    map[uint64]uint32
	stateU64    map[uint64]uint64
	stateI8     map[uint64]int8
	stateI16    map[uint64]int16
	stateI32    map[uint64]int32
	stateI64    map[uint64]int64
	stateF32    map[uint64]float32
	stateF64    map[uint64]float64
	stateString map[uint64]string

	mu sync.RWMutex
}

func NewRuntime(state *state.State, memory api.Memory) *Runtime {
	return &Runtime{
		state:               state,
		memory:              memory,
		strings:             make(map[uint32]string),
		stringHandleCounter: 1, // Start at 1, 0 is reserved for empty/null
		stateU8:             make(map[uint64]uint8),
		stateU16:            make(map[uint64]uint16),
		stateU32:            make(map[uint64]uint32),
		stateU64:            make(map[uint64]uint64),
		stateI8:             make(map[uint64]int8),
		stateI16:            make(map[uint64]int16),
		stateI32:            make(map[uint64]int32),
		stateI64:            make(map[uint64]int64),
		stateF32:            make(map[uint64]float32),
		stateF64:            make(map[uint64]float64),
		stateString:         make(map[uint64]string),
	}
}

// SetMemory updates the WASM memory reference (used after module instantiation).
func (r *Runtime) SetMemory(memory api.Memory) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.memory = memory
}

// stateKey combines funcID and varID into a single key for state storage.
func stateKey(funcID uint32, varID uint32) uint64 {
	return (uint64(funcID) << 32) | uint64(varID)
}

// ===== Channel Operations =====

// ChannelReadU8 reads the latest value from a channel.
func (r *Runtime) ChannelReadU8(ctx context.Context, channelID uint32) uint8 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return uint8(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[uint8](series, -1)
}

// ChannelWriteU8 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteU8(ctx context.Context, channelID uint32, value uint8) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[uint8](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadU16 reads the latest value from a channel.
func (r *Runtime) ChannelReadU16(ctx context.Context, channelID uint32) uint16 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return uint16(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[uint16](series, -1)
}

// ChannelWriteU16 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteU16(ctx context.Context, channelID uint32, value uint16) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[uint16](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadU32 reads the latest value from a channel.
func (r *Runtime) ChannelReadU32(ctx context.Context, channelID uint32) uint32 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return uint32(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[uint32](series, -1)
}

// ChannelWriteU32 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteU32(ctx context.Context, channelID uint32, value uint32) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[uint32](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadU64 reads the latest value from a channel.
func (r *Runtime) ChannelReadU64(ctx context.Context, channelID uint32) uint64 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return uint64(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[uint64](series, -1)
}

// ChannelWriteU64 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteU64(ctx context.Context, channelID uint32, value uint64) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[uint64](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadI8 reads the latest value from a channel.
func (r *Runtime) ChannelReadI8(ctx context.Context, channelID uint32) int8 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return int8(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[int8](series, -1)
}

// ChannelWriteI8 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteI8(ctx context.Context, channelID uint32, value int8) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[int8](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadI16 reads the latest value from a channel.
func (r *Runtime) ChannelReadI16(ctx context.Context, channelID uint32) int16 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return int16(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[int16](series, -1)
}

// ChannelWriteI16 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteI16(ctx context.Context, channelID uint32, value int16) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[int16](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadI32 reads the latest value from a channel.
func (r *Runtime) ChannelReadI32(ctx context.Context, channelID uint32) int32 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return int32(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[int32](series, -1)
}

// ChannelWriteI32 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteI32(ctx context.Context, channelID uint32, value int32) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[int32](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadI64 reads the latest value from a channel.
func (r *Runtime) ChannelReadI64(ctx context.Context, channelID uint32) int64 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return int64(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[int64](series, -1)
}

// ChannelWriteI64 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteI64(ctx context.Context, channelID uint32, value int64) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[int64](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadF32 reads the latest value from a channel.
func (r *Runtime) ChannelReadF32(ctx context.Context, channelID uint32) float32 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return float32(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[float32](series, -1)
}

// ChannelWriteF32 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteF32(ctx context.Context, channelID uint32, value float32) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[float32](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ChannelReadF64 reads the latest value from a channel.
func (r *Runtime) ChannelReadF64(ctx context.Context, channelID uint32) float64 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return float64(0) // Default value
	}

	// Return the last (most recent) value
	return telem.ValueAt[float64](series, -1)
}

// ChannelWriteF64 writes a value to a channel (queued for flush).
func (r *Runtime) ChannelWriteF64(ctx context.Context, channelID uint32, value float64) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Create a single-value series
	series := telem.NewSeriesV[float64](value)

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// ===== State Operations =====

// StateLoadU8 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadU8(ctx context.Context, funcID uint32, varID uint32, initValue uint8) uint8 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateU8[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateU8[key] = initValue
	return initValue
}

// StateStoreU8 stores a stateful variable's value.
func (r *Runtime) StateStoreU8(ctx context.Context, funcID uint32, varID uint32, value uint8) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateU8[key] = value
}

// StateLoadU16 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadU16(ctx context.Context, funcID uint32, varID uint32, initValue uint16) uint16 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateU16[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateU16[key] = initValue
	return initValue
}

// StateStoreU16 stores a stateful variable's value.
func (r *Runtime) StateStoreU16(ctx context.Context, funcID uint32, varID uint32, value uint16) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateU16[key] = value
}

// StateLoadU32 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadU32(ctx context.Context, funcID uint32, varID uint32, initValue uint32) uint32 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateU32[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateU32[key] = initValue
	return initValue
}

// StateStoreU32 stores a stateful variable's value.
func (r *Runtime) StateStoreU32(ctx context.Context, funcID uint32, varID uint32, value uint32) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateU32[key] = value
}

// StateLoadU64 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadU64(ctx context.Context, funcID uint32, varID uint32, initValue uint64) uint64 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateU64[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateU64[key] = initValue
	return initValue
}

// StateStoreU64 stores a stateful variable's value.
func (r *Runtime) StateStoreU64(ctx context.Context, funcID uint32, varID uint32, value uint64) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateU64[key] = value
}

// StateLoadI8 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadI8(ctx context.Context, funcID uint32, varID uint32, initValue int8) int8 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateI8[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateI8[key] = initValue
	return initValue
}

// StateStoreI8 stores a stateful variable's value.
func (r *Runtime) StateStoreI8(ctx context.Context, funcID uint32, varID uint32, value int8) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateI8[key] = value
}

// StateLoadI16 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadI16(ctx context.Context, funcID uint32, varID uint32, initValue int16) int16 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateI16[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateI16[key] = initValue
	return initValue
}

// StateStoreI16 stores a stateful variable's value.
func (r *Runtime) StateStoreI16(ctx context.Context, funcID uint32, varID uint32, value int16) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateI16[key] = value
}

// StateLoadI32 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadI32(ctx context.Context, funcID uint32, varID uint32, initValue int32) int32 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateI32[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateI32[key] = initValue
	return initValue
}

// StateStoreI32 stores a stateful variable's value.
func (r *Runtime) StateStoreI32(ctx context.Context, funcID uint32, varID uint32, value int32) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateI32[key] = value
}

// StateLoadI64 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadI64(ctx context.Context, funcID uint32, varID uint32, initValue int64) int64 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateI64[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateI64[key] = initValue
	return initValue
}

// StateStoreI64 stores a stateful variable's value.
func (r *Runtime) StateStoreI64(ctx context.Context, funcID uint32, varID uint32, value int64) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateI64[key] = value
}

// StateLoadF32 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadF32(ctx context.Context, funcID uint32, varID uint32, initValue float32) float32 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateF32[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateF32[key] = initValue
	return initValue
}

// StateStoreF32 stores a stateful variable's value.
func (r *Runtime) StateStoreF32(ctx context.Context, funcID uint32, varID uint32, value float32) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateF32[key] = value
}

// StateLoadF64 loads a stateful variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadF64(ctx context.Context, funcID uint32, varID uint32, initValue float64) float64 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	if value, ok := r.stateF64[key]; ok {
		return value
	}
	// Not found - initialize and return
	r.stateF64[key] = initValue
	return initValue
}

// StateStoreF64 stores a stateful variable's value.
func (r *Runtime) StateStoreF64(ctx context.Context, funcID uint32, varID uint32, value float64) {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	r.stateF64[key] = value
}

// ===== Generic Operations =====

// Now returns the current timestamp.
func (r *Runtime) Now(ctx context.Context) uint64 {
	return uint64(telem.Now())
}

// Panic is called when Arc code panics.
func (r *Runtime) Panic(ctx context.Context, ptr uint32, length uint32) {
	// Read panic message from WASM memory
	msg, ok := r.memory.Read(ptr, length)
	if !ok {
		panic("arc panic (message unreadable)")
	}
	panic("arc panic: " + string(msg))
}

// ===== Math Operations =====

// MathPowF32 computes base^exponent for f32.
func (r *Runtime) MathPowF32(ctx context.Context, base float32, exponent float32) float32 {
	return float32(math.Pow(float64(base), float64(exponent)))
}

// MathPowF64 computes base^exponent for f64.
func (r *Runtime) MathPowF64(ctx context.Context, base float64, exponent float64) float64 {
	return math.Pow(base, exponent)
}

// MathIntPowU8 computes base^exponent for u8 using integer exponentiation.
func (r *Runtime) MathIntPowU8(ctx context.Context, base uint8, exponent uint8) uint8 {
	return xmath.IntPow(base, int(exponent))
}

// MathIntPowU16 computes base^exponent for u16 using integer exponentiation.
func (r *Runtime) MathIntPowU16(ctx context.Context, base uint16, exponent uint16) uint16 {
	return xmath.IntPow(base, int(exponent))
}

// MathIntPowU32 computes base^exponent for u32 using integer exponentiation.
func (r *Runtime) MathIntPowU32(ctx context.Context, base uint32, exponent uint32) uint32 {
	return xmath.IntPow(base, int(exponent))
}

// MathIntPowU64 computes base^exponent for u64 using integer exponentiation.
func (r *Runtime) MathIntPowU64(ctx context.Context, base uint64, exponent uint64) uint64 {
	return xmath.IntPow(base, int(exponent))
}

// MathIntPowI8 computes base^exponent for i8 using integer exponentiation.
func (r *Runtime) MathIntPowI8(ctx context.Context, base int8, exponent int8) int8 {
	return xmath.IntPow(base, int(exponent))
}

// MathIntPowI16 computes base^exponent for i16 using integer exponentiation.
func (r *Runtime) MathIntPowI16(ctx context.Context, base int16, exponent int16) int16 {
	return xmath.IntPow(base, int(exponent))
}

// MathIntPowI32 computes base^exponent for i32 using integer exponentiation.
func (r *Runtime) MathIntPowI32(ctx context.Context, base int32, exponent int32) int32 {
	return xmath.IntPow(base, int(exponent))
}

// MathIntPowI64 computes base^exponent for i64 using integer exponentiation.
func (r *Runtime) MathIntPowI64(ctx context.Context, base int64, exponent int64) int64 {
	return xmath.IntPow(base, int(exponent))
}

// ===== String Operations =====

// StringFromLiteral creates a string from WASM memory and returns a handle.
func (r *Runtime) StringFromLiteral(ctx context.Context, ptr uint32, length uint32) uint32 {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Read string data from WASM memory
	data, ok := r.memory.Read(ptr, length)
	if !ok {
		return 0 // Return null handle on failure
	}

	// Generate new handle
	handle := r.stringHandleCounter
	r.stringHandleCounter++

	// Store string
	r.strings[handle] = string(data)

	return handle
}

// StringLen returns the length of a string.
func (r *Runtime) StringLen(ctx context.Context, handle uint32) uint32 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	if str, ok := r.strings[handle]; ok {
		return uint32(len(str))
	}
	return 0
}

// StringEqual compares two strings for equality.
func (r *Runtime) StringEqual(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
	r.mu.RLock()
	defer r.mu.RUnlock()

	str1, ok1 := r.strings[handle1]
	str2, ok2 := r.strings[handle2]

	if ok1 && ok2 && str1 == str2 {
		return 1
	}
	return 0
}

// ChannelReadString reads the latest string from a channel and returns a handle.
func (r *Runtime) ChannelReadString(ctx context.Context, channelID uint32) uint32 {
	r.mu.Lock()
	defer r.mu.Unlock()

	series, ok := r.state.ReadChannelValue(channelID)
	if !ok || series.Len() == 0 {
		return 0 // Return null handle
	}

	// Unmarshal strings from series
	strings := telem.UnmarshalStrings(series.Data)
	if len(strings) == 0 {
		return 0
	}

	// Get the last (most recent) string
	str := strings[len(strings)-1]

	// Generate handle and store
	handle := r.stringHandleCounter
	r.stringHandleCounter++
	r.strings[handle] = str

	return handle
}

// ChannelWriteString writes a string to a channel (queued for flush).
func (r *Runtime) ChannelWriteString(ctx context.Context, channelID uint32, handle uint32) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Look up string by handle
	str, ok := r.strings[handle]
	if !ok {
		return // Invalid handle, do nothing
	}

	// Create series from string
	data := telem.MarshalStrings([]string{str}, telem.StringT)
	series := telem.Series{
		DataType: telem.StringT,
		Data:     data,
	}

	// Queue for output
	r.state.WriteChannelValue(channelID, series)
}

// StateLoadString loads a stateful string variable's value, or initializes it if it doesn't exist.
func (r *Runtime) StateLoadString(ctx context.Context, funcID uint32, varID uint32, initHandle uint32) uint32 {
	r.mu.Lock()
	defer r.mu.Unlock()

	key := stateKey(funcID, varID)
	str, ok := r.stateString[key]
	if ok {
		// Exists - create a new handle for the stored string
		handle := r.stringHandleCounter
		r.stringHandleCounter++
		r.strings[handle] = str
		return handle
	}

	// Not found - store the init string and return the same handle
	if initStr, ok := r.strings[initHandle]; ok {
		r.stateString[key] = initStr
	}
	return initHandle
}

// StateStoreString stores a stateful string variable's value.
func (r *Runtime) StateStoreString(ctx context.Context, funcID uint32, varID uint32, handle uint32) {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Look up string by handle
	str, ok := r.strings[handle]
	if !ok {
		return // Invalid handle, do nothing
	}

	key := stateKey(funcID, varID)
	r.stateString[key] = str
}
