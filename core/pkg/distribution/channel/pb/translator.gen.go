// Copyright 2025 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package pb

import (
	"context"
	"github.com/synnaxlabs/x/telem"
	"github.com/synnaxlabs/aspen/node"
	"github.com/synnaxlabs/synnax/pkg/distribution/channel"
	controlpb "github.com/synnaxlabs/x/control/pb"
)


// OperationToPB converts Operation to Operation.
func OperationToPB(_ context.Context, r channel.Operation) (*Operation, error) {
	pb := &Operation{
		Type: OperationTypeToPB(r.Type),
		ResetChannel: uint32(r.ResetChannel),
		Duration: int64(r.Duration),
	}
	return pb, nil
}

// OperationFromPB converts Operation to Operation.
func OperationFromPB(_ context.Context, pb *Operation) (channel.Operation, error) {
	var r channel.Operation
	if pb == nil {
		return r, nil
	}
	r.Type = OperationTypeFromPB(pb.Type)
	r.ResetChannel = channel.Key(pb.ResetChannel)
	r.Duration = telem.TimeSpan(pb.Duration)
	return r, nil
}

// OperationsToPB converts a slice of Operation to Operation.
func OperationsToPB(ctx context.Context, rs []channel.Operation) ([]*Operation, error) {
	result := make([]*Operation, len(rs))
	for i := range rs {
		var err error
		result[i], err = OperationToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// OperationsFromPB converts a slice of Operation to Operation.
func OperationsFromPB(ctx context.Context, pbs []*Operation) ([]channel.Operation, error) {
	result := make([]channel.Operation, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = OperationFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ChannelToPB converts Channel to Channel.
func ChannelToPB(ctx context.Context, r channel.Channel) (*Channel, error) {
	operationsVal, err := OperationsToPB(ctx, r.Operations)
	if err != nil {
		return nil, err
	}
	pb := &Channel{
		Name: r.Name,
		Leaseholder: uint32(r.Leaseholder),
		DataType: string(r.DataType),
		IsIndex: r.IsIndex,
		LocalKey: uint32(r.LocalKey),
		LocalIndex: uint32(r.LocalIndex),
		Virtual: r.Virtual,
		Concurrency: controlpb.ConcurrencyToPB(r.Concurrency),
		Internal: r.Internal,
		Expression: r.Expression,
		Operations: operationsVal,
	}
	return pb, nil
}

// ChannelFromPB converts Channel to Channel.
func ChannelFromPB(ctx context.Context, pb *Channel) (channel.Channel, error) {
	var r channel.Channel
	if pb == nil {
		return r, nil
	}
	var err error
	r.Operations, err = OperationsFromPB(ctx, pb.Operations)
	if err != nil {
		return r, err
	}
	r.Name = pb.Name
	r.Leaseholder = node.Key(pb.Leaseholder)
	r.DataType = telem.DataType(pb.DataType)
	r.IsIndex = pb.IsIndex
	r.LocalKey = channel.LocalKey(pb.LocalKey)
	r.LocalIndex = channel.LocalKey(pb.LocalIndex)
	r.Virtual = pb.Virtual
	r.Concurrency = controlpb.ConcurrencyFromPB(pb.Concurrency)
	r.Internal = pb.Internal
	r.Expression = pb.Expression
	return r, nil
}

// ChannelsToPB converts a slice of Channel to Channel.
func ChannelsToPB(ctx context.Context, rs []channel.Channel) ([]*Channel, error) {
	result := make([]*Channel, len(rs))
	for i := range rs {
		var err error
		result[i], err = ChannelToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ChannelsFromPB converts a slice of Channel to Channel.
func ChannelsFromPB(ctx context.Context, pbs []*Channel) ([]channel.Channel, error) {
	result := make([]channel.Channel, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = ChannelFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// OperationTypeToPB converts channel.OperationType to OperationType.
func OperationTypeToPB(v channel.OperationType) OperationType {
	switch v {
	case channel.OperationTypeMin:
		return OperationType_MIN
	case channel.OperationTypeMax:
		return OperationType_MAX
	case channel.OperationTypeAvg:
		return OperationType_AVG
	case channel.OperationTypeNone:
		return OperationType_NONE
	default:
		return OperationType_UNSPECIFIED
	}
}

// OperationTypeFromPB converts OperationType to channel.OperationType.
func OperationTypeFromPB(v OperationType) channel.OperationType {
	switch v {
	case OperationType_MIN:
		return channel.OperationTypeMin
	case OperationType_MAX:
		return channel.OperationTypeMax
	case OperationType_AVG:
		return channel.OperationTypeAvg
	case OperationType_NONE:
		return channel.OperationTypeNone
	default:
		return channel.OperationTypeMin
	}
}
