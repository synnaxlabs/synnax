// Code generated by oracle. DO NOT EDIT.

package pb

import (
	"context"
	"github.com/synnaxlabs/x/telem"
	"github.com/synnaxlabs/aspen/node"
	"github.com/synnaxlabs/synnax/pkg/distribution/channel"
	controlpb "github.com/synnaxlabs/x/control/pb"
)


// OperationToPB converts Operation to Operation.
func OperationToPB(_ context.Context, r channel.Operation) (*Operation, error) {
	pb := &Operation{
		Type: r.Type,
		ResetChannel: uint32(r.ResetChannel),
		Duration: int64(r.Duration),
	}
	return pb, nil
}

// OperationFromPB converts Operation to Operation.
func OperationFromPB(_ context.Context, pb *Operation) (channel.Operation, error) {
	var r channel.Operation
	if pb == nil {
		return r, nil
	}
	r.Type = pb.Type
	r.ResetChannel = channel.Key(pb.ResetChannel)
	r.Duration = telem.TimeSpan(pb.Duration)
	return r, nil
}

// OperationsToPB converts a slice of Operation to Operation.
func OperationsToPB(ctx context.Context, rs []channel.Operation) ([]*Operation, error) {
	result := make([]*Operation, len(rs))
	for i := range rs {
		var err error
		result[i], err = OperationToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// OperationsFromPB converts a slice of Operation to Operation.
func OperationsFromPB(ctx context.Context, pbs []*Operation) ([]channel.Operation, error) {
	result := make([]channel.Operation, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = OperationFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ChannelToPB converts Channel to Channel.
func ChannelToPB(ctx context.Context, r channel.Channel) (*Channel, error) {
	operationsVal, err := OperationsToPB(ctx, r.Operations)
	if err != nil {
		return nil, err
	}
	pb := &Channel{
		Name: r.Name,
		Leaseholder: uint32(r.Leaseholder),
		DataType: string(r.DataType),
		IsIndex: r.IsIndex,
		LocalKey: uint32(r.LocalKey),
		LocalIndex: uint32(r.LocalIndex),
		Virtual: r.Virtual,
		Concurrency: controlpb.TranslateConcurrencyForward(r.Concurrency),
		Internal: r.Internal,
		Expression: r.Expression,
		Operations: operationsVal,
	}
	return pb, nil
}

// ChannelFromPB converts Channel to Channel.
func ChannelFromPB(ctx context.Context, pb *Channel) (channel.Channel, error) {
	var r channel.Channel
	if pb == nil {
		return r, nil
	}
	var err error
	r.Operations, err = OperationsFromPB(ctx, pb.Operations)
	if err != nil {
		return r, err
	}
	r.Name = pb.Name
	r.Leaseholder = node.Key(pb.Leaseholder)
	r.DataType = telem.DataType(pb.DataType)
	r.IsIndex = pb.IsIndex
	r.LocalKey = channel.LocalKey(pb.LocalKey)
	r.LocalIndex = channel.LocalKey(pb.LocalIndex)
	r.Virtual = pb.Virtual
	r.Concurrency = controlpb.TranslateConcurrencyBackward(pb.Concurrency)
	r.Internal = pb.Internal
	r.Expression = pb.Expression
	return r, nil
}

// ChannelsToPB converts a slice of Channel to Channel.
func ChannelsToPB(ctx context.Context, rs []channel.Channel) ([]*Channel, error) {
	result := make([]*Channel, len(rs))
	for i := range rs {
		var err error
		result[i], err = ChannelToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ChannelsFromPB converts a slice of Channel to Channel.
func ChannelsFromPB(ctx context.Context, pbs []*Channel) ([]channel.Channel, error) {
	result := make([]channel.Channel, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = ChannelFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}
