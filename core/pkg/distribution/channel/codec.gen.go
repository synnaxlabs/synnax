// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package channel

import (
	"context"
	"encoding/binary"

	"github.com/synnaxlabs/x/gorp"

	cluster "github.com/synnaxlabs/synnax/pkg/distribution/cluster"

	control "github.com/synnaxlabs/x/control"

	telem "github.com/synnaxlabs/x/telem"
)

var _ = binary.BigEndian

const (
	ChannelFieldName                       = 0
	ChannelFieldLeaseholder                = 1
	ChannelFieldDataType                   = 2
	ChannelFieldIsIndex                    = 3
	ChannelFieldLocalKey                   = 4
	ChannelFieldLocalIndex                 = 5
	ChannelFieldVirtual                    = 6
	ChannelFieldConcurrency                = 7
	ChannelFieldInternal                   = 8
	ChannelFieldOperationsElemType         = 9
	ChannelFieldOperationsElemResetChannel = 10
	ChannelFieldOperationsElemDuration     = 11
	ChannelFieldExpression                 = 12
	ChannelFieldCount                      = 13
)

type channelCodec struct{}

func (channelCodec) Marshal(
	_ context.Context,
	s Channel,
) ([]byte, error) {
	buf := make([]byte, 0, 161)
	buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.Name)))
	buf = append(buf, s.Name...)
	buf = binary.BigEndian.AppendUint16(buf, uint16(s.Leaseholder))
	buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.DataType)))
	buf = append(buf, s.DataType...)
	if s.IsIndex {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}
	buf = binary.BigEndian.AppendUint32(buf, uint32(s.LocalKey))
	buf = binary.BigEndian.AppendUint32(buf, uint32(s.LocalIndex))
	if s.Virtual {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}
	buf = binary.BigEndian.AppendUint64(buf, uint64(s.Concurrency))
	if s.Internal {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}
	buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.Operations)))
	for _, _e1 := range s.Operations {
		buf = binary.BigEndian.AppendUint32(buf, uint32(len(_e1.Type)))
		buf = append(buf, _e1.Type...)
		buf = binary.BigEndian.AppendUint32(buf, uint32(_e1.ResetChannel))
		buf = binary.BigEndian.AppendUint64(buf, uint64(_e1.Duration))
	}
	buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.Expression)))
	buf = append(buf, s.Expression...)
	return buf, nil
}

func (channelCodec) Unmarshal(
	_ context.Context,
	data []byte,
) (Channel, error) {
	var r Channel
	{
		_n := binary.BigEndian.Uint32(data[:4])
		data = data[4:]
		r.Name = string(data[:_n])
		data = data[_n:]
	}
	r.Leaseholder = cluster.NodeKey(binary.BigEndian.Uint16(data[:2]))
	data = data[2:]
	{
		_n := binary.BigEndian.Uint32(data[:4])
		data = data[4:]
		r.DataType = telem.DataType(data[:_n])
		data = data[_n:]
	}
	r.IsIndex = data[0] != 0
	data = data[1:]
	r.LocalKey = LocalKey(binary.BigEndian.Uint32(data[:4]))
	data = data[4:]
	r.LocalIndex = LocalKey(binary.BigEndian.Uint32(data[:4]))
	data = data[4:]
	r.Virtual = data[0] != 0
	data = data[1:]
	r.Concurrency = control.Concurrency(binary.BigEndian.Uint64(data[:8]))
	data = data[8:]
	r.Internal = data[0] != 0
	data = data[1:]
	{
		_n := binary.BigEndian.Uint32(data[:4])
		data = data[4:]
		r.Operations = make([]Operation, _n)
		for _i2 := range r.Operations {
			{
				_n := binary.BigEndian.Uint32(data[:4])
				data = data[4:]
				r.Operations[_i2].Type = OperationType(data[:_n])
				data = data[_n:]
			}
			r.Operations[_i2].ResetChannel = Key(binary.BigEndian.Uint32(data[:4]))
			data = data[4:]
			r.Operations[_i2].Duration = telem.TimeSpan(binary.BigEndian.Uint64(data[:8]))
			data = data[8:]
		}
	}
	{
		_n := binary.BigEndian.Uint32(data[:4])
		data = data[4:]
		r.Expression = string(data[:_n])
		data = data[_n:]
	}
	return r, nil
}

var ChannelCodec gorp.Codec[Channel] = channelCodec{}
