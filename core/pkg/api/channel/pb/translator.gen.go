// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package pb

import (
	"context"
	"github.com/synnaxlabs/synnax/pkg/api/channel"
	distributionchannel "github.com/synnaxlabs/synnax/pkg/distribution/channel"
	channelpb "github.com/synnaxlabs/synnax/pkg/distribution/channel/pb"
	controlpb "github.com/synnaxlabs/x/control/pb"
	"github.com/synnaxlabs/x/telem"
	"github.com/synnaxlabs/x/types"
)

// ChannelToPB converts Channel to Channel.
func ChannelToPB(ctx context.Context, r channel.Channel) (*Channel, error) {
	operationsVal, err := channelpb.OperationsToPB(ctx, r.Operations)
	if err != nil {
		return nil, err
	}
	pb := &Channel{
		Key:         uint32(r.Key),
		Name:        string(r.Name),
		Leaseholder: uint32(r.Leaseholder),
		DataType:    string(r.DataType),
		IsIndex:     r.IsIndex,
		Index:       uint32(r.Index),
		Alias:       r.Alias,
		Virtual:     r.Virtual,
		Internal:    r.Internal,
		Expression:  r.Expression,
		Concurrency: controlpb.ConcurrencyToPB(r.Concurrency),
		Operations:  operationsVal,
	}
	return pb, nil
}

// ChannelFromPB converts Channel to Channel.
func ChannelFromPB(ctx context.Context, pb *Channel) (channel.Channel, error) {
	var r channel.Channel
	if pb == nil {
		return r, nil
	}
	var err error
	r.Operations, err = channelpb.OperationsFromPB(ctx, pb.Operations)
	if err != nil {
		return r, err
	}
	r.Key = distributionchannel.Key(pb.Key)
	r.Name = distributionchannel.Name(pb.Name)
	r.Leaseholder = types.Uint12(pb.Leaseholder)
	r.DataType = telem.DataType(pb.DataType)
	r.IsIndex = pb.IsIndex
	r.Index = distributionchannel.Key(pb.Index)
	r.Alias = pb.Alias
	r.Virtual = pb.Virtual
	r.Internal = pb.Internal
	r.Expression = pb.Expression
	r.Concurrency = controlpb.ConcurrencyFromPB(pb.Concurrency)
	return r, nil
}

// ChannelsToPB converts a slice of Channel to Channel.
func ChannelsToPB(ctx context.Context, rs []channel.Channel) ([]*Channel, error) {
	result := make([]*Channel, len(rs))
	for i := range rs {
		var err error
		result[i], err = ChannelToPB(ctx, rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// ChannelsFromPB converts a slice of Channel to Channel.
func ChannelsFromPB(ctx context.Context, pbs []*Channel) ([]channel.Channel, error) {
	result := make([]channel.Channel, len(pbs))
	for i, pb := range pbs {
		var err error
		result[i], err = ChannelFromPB(ctx, pb)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}
