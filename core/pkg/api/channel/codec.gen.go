// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by oracle. DO NOT EDIT.

package channel

import (
	"context"
	"encoding/binary"
	"math"

	"github.com/synnaxlabs/x/gorp"

	distributionchannel "github.com/synnaxlabs/synnax/pkg/distribution/channel"

	cluster "github.com/synnaxlabs/synnax/pkg/distribution/cluster"

	control "github.com/synnaxlabs/x/control"

	label "github.com/synnaxlabs/x/label"

	status "github.com/synnaxlabs/x/status"

	telem "github.com/synnaxlabs/x/telem"
)

var _ = binary.BigEndian

const (
	ChannelFieldKey                        = 0
	ChannelFieldName                       = 1
	ChannelFieldLeaseholder                = 2
	ChannelFieldDataType                   = 3
	ChannelFieldIsIndex                    = 4
	ChannelFieldIndex                      = 5
	ChannelFieldAlias                      = 6
	ChannelFieldVirtual                    = 7
	ChannelFieldInternal                   = 8
	ChannelFieldExpression                 = 9
	ChannelFieldOperationsElemType         = 10
	ChannelFieldOperationsElemResetChannel = 11
	ChannelFieldOperationsElemDuration     = 12
	ChannelFieldConcurrency                = 13
	ChannelFieldStatusKey                  = 14
	ChannelFieldStatusName                 = 15
	ChannelFieldStatusVariant              = 16
	ChannelFieldStatusMessage              = 17
	ChannelFieldStatusDescription          = 18
	ChannelFieldStatusTime                 = 19
	ChannelFieldStatusLabelsElemKey        = 20
	ChannelFieldStatusLabelsElemName       = 21
	ChannelFieldStatusLabelsElemColorR     = 22
	ChannelFieldStatusLabelsElemColorG     = 23
	ChannelFieldStatusLabelsElemColorB     = 24
	ChannelFieldStatusLabelsElemColorA     = 25
	ChannelFieldCount                      = 26
)

type channelCodec struct{}

func (channelCodec) Marshal(
	_ context.Context,
	s Channel,
) ([]byte, error) {
	buf := make([]byte, 0, 420)
	buf = binary.BigEndian.AppendUint32(buf, uint32(s.Key))
	buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.Name)))
	buf = append(buf, s.Name...)
	buf = binary.BigEndian.AppendUint16(buf, uint16(s.Leaseholder))
	buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.DataType)))
	buf = append(buf, s.DataType...)
	if s.IsIndex {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}
	buf = binary.BigEndian.AppendUint32(buf, uint32(s.Index))
	buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.Alias)))
	buf = append(buf, s.Alias...)
	if s.Virtual {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}
	if s.Internal {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}
	buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.Expression)))
	buf = append(buf, s.Expression...)
	if s.Operations != nil {
		buf = append(buf, 1)
		buf = binary.BigEndian.AppendUint32(buf, uint32(len(s.Operations)))
		for _, _e1 := range s.Operations {
			buf = binary.BigEndian.AppendUint32(buf, uint32(len(_e1.Type)))
			buf = append(buf, _e1.Type...)
			buf = binary.BigEndian.AppendUint32(buf, uint32(_e1.ResetChannel))
			buf = binary.BigEndian.AppendUint64(buf, uint64(_e1.Duration))
		}
	} else {
		buf = append(buf, 0)
	}
	buf = binary.BigEndian.AppendUint64(buf, uint64(s.Concurrency))
	if s.Status != nil {
		buf = append(buf, 1)
		buf = binary.BigEndian.AppendUint32(buf, uint32(len((*s.Status).Key)))
		buf = append(buf, (*s.Status).Key...)
		buf = binary.BigEndian.AppendUint32(buf, uint32(len((*s.Status).Name)))
		buf = append(buf, (*s.Status).Name...)
		buf = binary.BigEndian.AppendUint32(buf, uint32(len((*s.Status).Variant)))
		buf = append(buf, (*s.Status).Variant...)
		buf = binary.BigEndian.AppendUint32(buf, uint32(len((*s.Status).Message)))
		buf = append(buf, (*s.Status).Message...)
		buf = binary.BigEndian.AppendUint32(buf, uint32(len((*s.Status).Description)))
		buf = append(buf, (*s.Status).Description...)
		buf = binary.BigEndian.AppendUint64(buf, uint64((*s.Status).Time))
		if (*s.Status).Labels != nil {
			buf = append(buf, 1)
			buf = binary.BigEndian.AppendUint32(buf, uint32(len((*s.Status).Labels)))
			for _, _e4 := range (*s.Status).Labels {
				buf = append(buf, _e4.Key[:]...)
				buf = binary.BigEndian.AppendUint32(buf, uint32(len(_e4.Name)))
				buf = append(buf, _e4.Name...)
				buf = append(buf, byte(_e4.Color.R))
				buf = append(buf, byte(_e4.Color.G))
				buf = append(buf, byte(_e4.Color.B))
				buf = binary.BigEndian.AppendUint64(buf, math.Float64bits(float64(_e4.Color.A)))
			}
		} else {
			buf = append(buf, 0)
		}
	} else {
		buf = append(buf, 0)
	}
	return buf, nil
}

func (channelCodec) Unmarshal(
	_ context.Context,
	data []byte,
) (Channel, error) {
	var r Channel
	r.Key = distributionchannel.Key(binary.BigEndian.Uint32(data[:4]))
	data = data[4:]
	{
		_n := binary.BigEndian.Uint32(data[:4])
		data = data[4:]
		r.Name = string(data[:_n])
		data = data[_n:]
	}
	r.Leaseholder = cluster.NodeKey(binary.BigEndian.Uint16(data[:2]))
	data = data[2:]
	{
		_n := binary.BigEndian.Uint32(data[:4])
		data = data[4:]
		r.DataType = telem.DataType(data[:_n])
		data = data[_n:]
	}
	r.IsIndex = data[0] != 0
	data = data[1:]
	r.Index = distributionchannel.Key(binary.BigEndian.Uint32(data[:4]))
	data = data[4:]
	{
		_n := binary.BigEndian.Uint32(data[:4])
		data = data[4:]
		r.Alias = string(data[:_n])
		data = data[_n:]
	}
	r.Virtual = data[0] != 0
	data = data[1:]
	r.Internal = data[0] != 0
	data = data[1:]
	{
		_n := binary.BigEndian.Uint32(data[:4])
		data = data[4:]
		r.Expression = string(data[:_n])
		data = data[_n:]
	}
	if data[0] == 1 {
		data = data[1:]
		{
			_n := binary.BigEndian.Uint32(data[:4])
			data = data[4:]
			r.Operations = make([]distributionchannel.Operation, _n)
			for _i2 := range r.Operations {
				{
					_n := binary.BigEndian.Uint32(data[:4])
					data = data[4:]
					r.Operations[_i2].Type = distributionchannel.OperationType(data[:_n])
					data = data[_n:]
				}
				r.Operations[_i2].ResetChannel = distributionchannel.Key(binary.BigEndian.Uint32(data[:4]))
				data = data[4:]
				r.Operations[_i2].Duration = telem.TimeSpan(binary.BigEndian.Uint64(data[:8]))
				data = data[8:]
			}
		}
	} else {
		data = data[1:]
	}
	r.Concurrency = control.Concurrency(binary.BigEndian.Uint64(data[:8]))
	data = data[8:]
	if data[0] == 1 {
		data = data[1:]
		var _ov3 Status
		{
			_n := binary.BigEndian.Uint32(data[:4])
			data = data[4:]
			_ov3.Key = string(data[:_n])
			data = data[_n:]
		}
		{
			_n := binary.BigEndian.Uint32(data[:4])
			data = data[4:]
			_ov3.Name = string(data[:_n])
			data = data[_n:]
		}
		{
			_n := binary.BigEndian.Uint32(data[:4])
			data = data[4:]
			_ov3.Variant = status.Variant(data[:_n])
			data = data[_n:]
		}
		{
			_n := binary.BigEndian.Uint32(data[:4])
			data = data[4:]
			_ov3.Message = string(data[:_n])
			data = data[_n:]
		}
		{
			_n := binary.BigEndian.Uint32(data[:4])
			data = data[4:]
			_ov3.Description = string(data[:_n])
			data = data[_n:]
		}
		_ov3.Time = telem.TimeStamp(binary.BigEndian.Uint64(data[:8]))
		data = data[8:]
		if data[0] == 1 {
			data = data[1:]
			{
				_n := binary.BigEndian.Uint32(data[:4])
				data = data[4:]
				_ov3.Labels = make([]label.Label, _n)
				for _i5 := range _ov3.Labels {
					copy(_ov3.Labels[_i5].Key[:], data[:16])
					data = data[16:]
					{
						_n := binary.BigEndian.Uint32(data[:4])
						data = data[4:]
						_ov3.Labels[_i5].Name = string(data[:_n])
						data = data[_n:]
					}
					_ov3.Labels[_i5].Color.R = uint8(data[0])
					data = data[1:]
					_ov3.Labels[_i5].Color.G = uint8(data[0])
					data = data[1:]
					_ov3.Labels[_i5].Color.B = uint8(data[0])
					data = data[1:]
					_ov3.Labels[_i5].Color.A = float64(math.Float64frombits(binary.BigEndian.Uint64(data[:8])))
					data = data[8:]
				}
			}
		} else {
			data = data[1:]
		}
		r.Status = &_ov3
	} else {
		data = data[1:]
	}
	return r, nil
}

var ChannelCodec gorp.Codec[Channel] = channelCodec{}
