// Code generated by oracle. DO NOT EDIT.

package grpc

import (
	"context"
	"github.com/synnaxlabs/synnax/pkg/api"
	rackv1 "github.com/synnaxlabs/synnax/pkg/api/grpc/v1/rack"
	"github.com/synnaxlabs/synnax/pkg/service/rack"
	statusgrpc "github.com/synnaxlabs/x/status/grpc"
)

// Suppress unused import warnings
var _ = context.Background


// TranslateRackForward converts Rack to PBRack.
func TranslateRackForward(ctx context.Context, r *api.Rack) (*rackv1.PBRack, error) {
	_ = ctx // May be unused
	if r == nil {
		return nil, nil
	}
	pb := &rackv1.PBRack{
		Key: uint32(r.Key),
		Name: r.Name,
		TaskCounter: &r.TaskCounter,
		Embedded: &r.Embedded,
		Status: statusgrpc.TranslateStatusForward(ctx, &r.Status),
	}
	return pb, nil
}

// TranslateRackBackward converts PBRack to Rack.
func TranslateRackBackward(ctx context.Context, pb *rackv1.PBRack) (*api.Rack, error) {
	_ = ctx // May be unused
	if pb == nil {
		return nil, nil
	}
	r := &api.Rack{
		Key: rack.Key(pb.Key),
		Name: pb.Name,
		TaskCounter: pb.GetTaskCounter(),
		Embedded: pb.GetEmbedded(),
		Status: statusgrpc.TranslateStatusBackward(ctx, pb.Status),
	}
	return r, nil
}

// TranslateRacksForward converts a slice of Rack to PBRack.
func TranslateRacksForward(ctx context.Context, rs []api.Rack) ([]*rackv1.PBRack, error) {
	result := make([]*rackv1.PBRack, len(rs))
	for i := range rs {
		var err error
		result[i], err = TranslateRackForward(ctx, &rs[i])
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// TranslateRacksBackward converts a slice of PBRack to Rack.
func TranslateRacksBackward(ctx context.Context, pbs []*rackv1.PBRack) ([]api.Rack, error) {
	result := make([]api.Rack, len(pbs))
	for i, pb := range pbs {
		r, err := TranslateRackBackward(ctx, pb)
		if err != nil {
			return nil, err
		}
		if r != nil {
			result[i] = *r
		}
	}
	return result, nil
}
