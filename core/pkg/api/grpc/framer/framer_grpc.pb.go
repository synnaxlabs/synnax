// Copyright 2026 Synnax Labs, Inc.
//
// Use of this software is governed by the Business Source License included in the file
// licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with the Business Source
// License, use of this software will be governed by the Apache License, Version 2.0,
// included in the file licenses/APL.txt.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: core/pkg/api/grpc/framer/framer.proto

package framer

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FrameIteratorService_Exec_FullMethodName = "/grpc.framer.FrameIteratorService/Exec"
)

// FrameIteratorServiceClient is the client API for FrameIteratorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FrameIteratorServiceClient interface {
	Exec(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[IteratorRequest, IteratorResponse], error)
}

type frameIteratorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFrameIteratorServiceClient(cc grpc.ClientConnInterface) FrameIteratorServiceClient {
	return &frameIteratorServiceClient{cc}
}

func (c *frameIteratorServiceClient) Exec(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[IteratorRequest, IteratorResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &FrameIteratorService_ServiceDesc.Streams[0], FrameIteratorService_Exec_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[IteratorRequest, IteratorResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FrameIteratorService_ExecClient = grpc.BidiStreamingClient[IteratorRequest, IteratorResponse]

// FrameIteratorServiceServer is the server API for FrameIteratorService service.
// All implementations should embed UnimplementedFrameIteratorServiceServer
// for forward compatibility.
type FrameIteratorServiceServer interface {
	Exec(grpc.BidiStreamingServer[IteratorRequest, IteratorResponse]) error
}

// UnimplementedFrameIteratorServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFrameIteratorServiceServer struct{}

func (UnimplementedFrameIteratorServiceServer) Exec(grpc.BidiStreamingServer[IteratorRequest, IteratorResponse]) error {
	return status.Error(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedFrameIteratorServiceServer) testEmbeddedByValue() {}

// UnsafeFrameIteratorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FrameIteratorServiceServer will
// result in compilation errors.
type UnsafeFrameIteratorServiceServer interface {
	mustEmbedUnimplementedFrameIteratorServiceServer()
}

func RegisterFrameIteratorServiceServer(s grpc.ServiceRegistrar, srv FrameIteratorServiceServer) {
	// If the following call panics, it indicates UnimplementedFrameIteratorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FrameIteratorService_ServiceDesc, srv)
}

func _FrameIteratorService_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FrameIteratorServiceServer).Exec(&grpc.GenericServerStream[IteratorRequest, IteratorResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FrameIteratorService_ExecServer = grpc.BidiStreamingServer[IteratorRequest, IteratorResponse]

// FrameIteratorService_ServiceDesc is the grpc.ServiceDesc for FrameIteratorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FrameIteratorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.framer.FrameIteratorService",
	HandlerType: (*FrameIteratorServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exec",
			Handler:       _FrameIteratorService_Exec_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "core/pkg/api/grpc/framer/framer.proto",
}

const (
	FrameWriterService_Exec_FullMethodName = "/grpc.framer.FrameWriterService/Exec"
)

// FrameWriterServiceClient is the client API for FrameWriterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FrameWriterServiceClient interface {
	Exec(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[WriterRequest, WriterResponse], error)
}

type frameWriterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFrameWriterServiceClient(cc grpc.ClientConnInterface) FrameWriterServiceClient {
	return &frameWriterServiceClient{cc}
}

func (c *frameWriterServiceClient) Exec(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[WriterRequest, WriterResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &FrameWriterService_ServiceDesc.Streams[0], FrameWriterService_Exec_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WriterRequest, WriterResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FrameWriterService_ExecClient = grpc.BidiStreamingClient[WriterRequest, WriterResponse]

// FrameWriterServiceServer is the server API for FrameWriterService service.
// All implementations should embed UnimplementedFrameWriterServiceServer
// for forward compatibility.
type FrameWriterServiceServer interface {
	Exec(grpc.BidiStreamingServer[WriterRequest, WriterResponse]) error
}

// UnimplementedFrameWriterServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFrameWriterServiceServer struct{}

func (UnimplementedFrameWriterServiceServer) Exec(grpc.BidiStreamingServer[WriterRequest, WriterResponse]) error {
	return status.Error(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedFrameWriterServiceServer) testEmbeddedByValue() {}

// UnsafeFrameWriterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FrameWriterServiceServer will
// result in compilation errors.
type UnsafeFrameWriterServiceServer interface {
	mustEmbedUnimplementedFrameWriterServiceServer()
}

func RegisterFrameWriterServiceServer(s grpc.ServiceRegistrar, srv FrameWriterServiceServer) {
	// If the following call panics, it indicates UnimplementedFrameWriterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FrameWriterService_ServiceDesc, srv)
}

func _FrameWriterService_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FrameWriterServiceServer).Exec(&grpc.GenericServerStream[WriterRequest, WriterResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FrameWriterService_ExecServer = grpc.BidiStreamingServer[WriterRequest, WriterResponse]

// FrameWriterService_ServiceDesc is the grpc.ServiceDesc for FrameWriterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FrameWriterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.framer.FrameWriterService",
	HandlerType: (*FrameWriterServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exec",
			Handler:       _FrameWriterService_Exec_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "core/pkg/api/grpc/framer/framer.proto",
}

const (
	FrameStreamerService_Exec_FullMethodName = "/grpc.framer.FrameStreamerService/Exec"
)

// FrameStreamerServiceClient is the client API for FrameStreamerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FrameStreamerServiceClient interface {
	Exec(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamerRequest, StreamerResponse], error)
}

type frameStreamerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFrameStreamerServiceClient(cc grpc.ClientConnInterface) FrameStreamerServiceClient {
	return &frameStreamerServiceClient{cc}
}

func (c *frameStreamerServiceClient) Exec(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamerRequest, StreamerResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &FrameStreamerService_ServiceDesc.Streams[0], FrameStreamerService_Exec_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamerRequest, StreamerResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FrameStreamerService_ExecClient = grpc.BidiStreamingClient[StreamerRequest, StreamerResponse]

// FrameStreamerServiceServer is the server API for FrameStreamerService service.
// All implementations should embed UnimplementedFrameStreamerServiceServer
// for forward compatibility.
type FrameStreamerServiceServer interface {
	Exec(grpc.BidiStreamingServer[StreamerRequest, StreamerResponse]) error
}

// UnimplementedFrameStreamerServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFrameStreamerServiceServer struct{}

func (UnimplementedFrameStreamerServiceServer) Exec(grpc.BidiStreamingServer[StreamerRequest, StreamerResponse]) error {
	return status.Error(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedFrameStreamerServiceServer) testEmbeddedByValue() {}

// UnsafeFrameStreamerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FrameStreamerServiceServer will
// result in compilation errors.
type UnsafeFrameStreamerServiceServer interface {
	mustEmbedUnimplementedFrameStreamerServiceServer()
}

func RegisterFrameStreamerServiceServer(s grpc.ServiceRegistrar, srv FrameStreamerServiceServer) {
	// If the following call panics, it indicates UnimplementedFrameStreamerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FrameStreamerService_ServiceDesc, srv)
}

func _FrameStreamerService_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FrameStreamerServiceServer).Exec(&grpc.GenericServerStream[StreamerRequest, StreamerResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FrameStreamerService_ExecServer = grpc.BidiStreamingServer[StreamerRequest, StreamerResponse]

// FrameStreamerService_ServiceDesc is the grpc.ServiceDesc for FrameStreamerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FrameStreamerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.framer.FrameStreamerService",
	HandlerType: (*FrameStreamerServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exec",
			Handler:       _FrameStreamerService_Exec_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "core/pkg/api/grpc/framer/framer.proto",
}

const (
	FrameDeleteService_Exec_FullMethodName = "/grpc.framer.FrameDeleteService/Exec"
)

// FrameDeleteServiceClient is the client API for FrameDeleteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FrameDeleteServiceClient interface {
	Exec(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type frameDeleteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFrameDeleteServiceClient(cc grpc.ClientConnInterface) FrameDeleteServiceClient {
	return &frameDeleteServiceClient{cc}
}

func (c *frameDeleteServiceClient) Exec(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FrameDeleteService_Exec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FrameDeleteServiceServer is the server API for FrameDeleteService service.
// All implementations should embed UnimplementedFrameDeleteServiceServer
// for forward compatibility.
type FrameDeleteServiceServer interface {
	Exec(context.Context, *DeleteRequest) (*emptypb.Empty, error)
}

// UnimplementedFrameDeleteServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFrameDeleteServiceServer struct{}

func (UnimplementedFrameDeleteServiceServer) Exec(context.Context, *DeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedFrameDeleteServiceServer) testEmbeddedByValue() {}

// UnsafeFrameDeleteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FrameDeleteServiceServer will
// result in compilation errors.
type UnsafeFrameDeleteServiceServer interface {
	mustEmbedUnimplementedFrameDeleteServiceServer()
}

func RegisterFrameDeleteServiceServer(s grpc.ServiceRegistrar, srv FrameDeleteServiceServer) {
	// If the following call panics, it indicates UnimplementedFrameDeleteServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FrameDeleteService_ServiceDesc, srv)
}

func _FrameDeleteService_Exec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameDeleteServiceServer).Exec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameDeleteService_Exec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameDeleteServiceServer).Exec(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FrameDeleteService_ServiceDesc is the grpc.ServiceDesc for FrameDeleteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FrameDeleteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.framer.FrameDeleteService",
	HandlerType: (*FrameDeleteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Exec",
			Handler:    _FrameDeleteService_Exec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "core/pkg/api/grpc/framer/framer.proto",
}
