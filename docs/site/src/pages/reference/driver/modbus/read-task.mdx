---
layout: "@/layouts/Reference.astro"
title: "Modbus Read Task"
description: "Learn how to acquire data from Modbus TCP devices with Synnax."
next: "Write Task"
nextURL: "/reference/driver/modbus/write-task"
prev: "Connect to a Server"
prevURL: "/reference/driver/modbus/connect-server"
---

import { Divider, Note, Icon, Text } from "@synnaxlabs/pluto";
import { Video, Image } from "@/components/media/Media";
import { Fragment } from "react";
import Details from "@/components/details/Details.astro";
import ChannelType from "@/components/details/ChannelType.astro";
import DetailsGroup from "@/components/details/Group.astro";
import { Client } from "@/components/client";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

For task lifecycle management, see the
[Task Basics](/reference/driver/task-basics#how-to) page.

<Divider.Divider x />

## Task Configuration Reference

| Parameter     | Type    | Required | Default       | Description                                                   |
| ------------- | ------- | -------- | ------------- | ------------------------------------------------------------- |
| `name`        | string  | Yes      | -             | Human-readable task name                                      |
| `device`      | string  | Yes      | -             | Key of the Modbus server device                               |
| `sample_rate` | number  | Yes      | -             | Samples per second (Hz)                                       |
| `stream_rate` | number  | No       | `sample_rate` | Rate data is streamed to Synnax (Hz), must be ≤ `sample_rate` |
| `data_saving` | boolean | No       | `false`       | Enable permanent storage in Synnax                            |
| `auto_start`  | boolean | No       | `false`       | Automatically start task after configuration                  |
| `channels`    | array   | Yes      | -             | List of input channel configurations                          |

<Divider.Divider x />

## Register Types Reference

<DetailsGroup>

<ChannelType>
<Text.Text slot="summary" level="p"><Icon.Wave.Sine /> Holding Register Input ([`holding_register_input`](https://www.modbustools.com/modbus.html#function03))</Text.Text>

Reads from 16-bit read/write registers (Function Code 03). Typically used for
configuration parameters and analog outputs that can also be read back.

| Parameter    | Type    | Required | Default   | Description                                                |
| ------------ | ------- | -------- | --------- | ---------------------------------------------------------- |
| `channel`    | number  | Yes      | -         | Synnax channel key                                         |
| `address`    | number  | Yes      | -         | Modbus register address (0-65535)                          |
| `data_type`  | enum    | No       | `float32` | Data type: `int16`, `uint16`, `int32`, `uint32`, `float32` |
| `swap_bytes` | boolean | No       | `false`   | Swap byte order within 16-bit words                        |
| `swap_words` | boolean | No       | `false`   | Swap word order for 32-bit+ values                         |

**Data Type Sizes:**

- `int16`/`uint16`: 1 register (2 bytes)
- `int32`/`uint32`/`float32`: 2 registers (4 bytes)

</ChannelType>

<ChannelType>
<Text.Text slot="summary" level="p"><Icon.Wave.Sine /> Input Register ([`register_input`](https://www.modbustools.com/modbus.html#function04))</Text.Text>

Reads from 16-bit read-only registers (Function Code 04). Typically used for analog
sensor values like temperature, pressure, or flow.

| Parameter    | Type    | Required | Default   | Description                                                |
| ------------ | ------- | -------- | --------- | ---------------------------------------------------------- |
| `channel`    | number  | Yes      | -         | Synnax channel key                                         |
| `address`    | number  | Yes      | -         | Modbus register address (0-65535)                          |
| `data_type`  | enum    | No       | `float32` | Data type: `int16`, `uint16`, `int32`, `uint32`, `float32` |
| `swap_bytes` | boolean | No       | `false`   | Swap byte order within 16-bit words                        |
| `swap_words` | boolean | No       | `false`   | Swap word order for 32-bit+ values                         |

**Data Type Sizes:**

- `int16`/`uint16`: 1 register (2 bytes)
- `int32`/`uint32`/`float32`: 2 registers (4 bytes)

</ChannelType>

<ChannelType>
<Text.Text slot="summary" level="p"><Icon.Wave.Square /> Coil Input ([`coil_input`](https://www.modbustools.com/modbus.html#function01))</Text.Text>

Reads from 1-bit read/write coils (Function Code 01). Typically used for discrete output
states that can be read back (e.g., relay states, valve positions).

| Parameter | Type   | Required | Default | Description                   |
| --------- | ------ | -------- | ------- | ----------------------------- |
| `channel` | number | Yes      | -       | Synnax channel key            |
| `address` | number | Yes      | -       | Modbus coil address (0-65535) |

**Data Type:** Always boolean (0/1)

</ChannelType>

<ChannelType>
<Text.Text slot="summary" level="p"><Icon.Wave.Square /> Discrete Input ([`discrete_input`](https://www.modbustools.com/modbus.html#function02))</Text.Text>

Reads from 1-bit read-only discrete inputs (Function Code 02). Typically used for binary
sensor inputs (e.g., limit switches, proximity sensors).

| Parameter | Type   | Required | Default | Description                             |
| --------- | ------ | -------- | ------- | --------------------------------------- |
| `channel` | number | Yes      | -       | Synnax channel key                      |
| `address` | number | Yes      | -       | Modbus discrete input address (0-65535) |

**Data Type:** Always boolean (0/1)

</ChannelType>

</DetailsGroup>

<Divider.Divider x />

## Important Rules

- **Sample rates** -> All channels in a task sample at the same rate. Create separate
  tasks for different rates.
- **Software timing** -> Modbus tasks use software timing with ~100 μs precision (may
  degrade under heavy load).
- **One running task per channel** -> A channel can only receive live data from one task
  at a time.
- **Stream rate optimization** -> For low-rate tasks (< 50 Hz), set the stream rate to
  the sample rate. For high-rate tasks, keep the stream rate less than 50 Hz for better
  performance.
- **Byte/word order** -> Ensure swap settings match your server configuration for
  multi-register data types.

<Divider.Divider x />

## How-To

<Client.Tabs client:load exclude={["cpp"]}>
  <Fragment slot="console">
    <Video
      client:only="react"
      id="device-drivers/modbus/read-task/modbus-read"
    />
  </Fragment>
  <Fragment slot="python">

<Details>
<Text.Text slot="summary" level="p"><Icon.Play /> Configure and run task</Text.Text>

```python
import synnax as sy
from synnax import modbus

client = sy.Synnax()

# Retrieve device
dev = client.devices.retrieve(name="Modbus Server")

# Create index channel
modbus_time = client.channels.create(
    name="modbus_time",
    is_index=True,
    data_type=sy.DataType.TIMESTAMP,
    retrieve_if_name_exists=True,
)

# Create data channels
input_reg_0 = client.channels.create(
    name="input_register_0",
    index=modbus_time.key,
    data_type=sy.DataType.UINT8,
    retrieve_if_name_exists=True,
)

input_reg_1 = client.channels.create(
    name="input_register_1",
    index=modbus_time.key,
    data_type=sy.DataType.UINT8,
    retrieve_if_name_exists=True,
)

# Create and configure task
task = modbus.ReadTask(
    name="Modbus Read Task",
    device=dev.key,
    sample_rate=sy.Rate.HZ * 10,
    stream_rate=sy.Rate.HZ * 10,
    data_saving=True,
    channels=[
        modbus.InputRegisterChan(
            channel=input_reg_0.key,
            address=0,
            data_type="uint8",
        ),
        modbus.InputRegisterChan(
            channel=input_reg_1.key,
            address=1,
            data_type="uint8",
        ),
    ],
)

client.tasks.configure(task)

# Start task and read data
with task.run():
    with client.open_streamer(["input_register_0", "input_register_1"]) as streamer:
        for _ in range(10):
            frame = streamer.read()
            print(frame)
```

</Details>

<Details>
<Text.Text slot="summary" level="p"><Icon.Edit /> Edit task configuration</Text.Text>

```python
# Retrieve existing task
task = client.tasks.retrieve(name="Modbus Read Task")
task = modbus.ReadTask(internal=task)

# Update task-level configuration
task.config.auto_start = True
task.config.stream_rate = int(sy.Rate.HZ * 5)

# Update first channel configuration
task.config.channels[0].address = 10
task.config.channels[0].data_type = "uint16"

# Update second channel configuration
task.config.channels[1].address = 11
task.config.channels[1].data_type = "uint16"

# Apply changes
client.tasks.configure(task)
```

</Details>

  </Fragment>
  <Fragment slot="typescript">

<Details>
<Text.Text slot="summary" level="p"><Icon.Play /> Configure and run task</Text.Text>

```typescript
import { Synnax } from "@synnaxlabs/client";

const client = new Synnax();

// Retrieve device
const dev = await client.devices.retrieve({ name: "Modbus Server" });

// Create index channel
const modbusTime = await client.channels.create({
  name: "modbus_time",
  isIndex: true,
  dataType: "timestamp",
  retrieveIfNameExists: true,
});

// Create data channels
const inputReg0 = await client.channels.create({
  name: "input_register_0",
  index: modbusTime.key,
  dataType: "uint8",
  retrieveIfNameExists: true,
});

const inputReg1 = await client.channels.create({
  name: "input_register_1",
  index: modbusTime.key,
  dataType: "uint8",
  retrieveIfNameExists: true,
});

// Create and configure task
const task = await client.tasks.create({
  name: "Modbus Read Task",
  type: "modbus_read",
  config: JSON.stringify({
    device: dev.key,
    sample_rate: 10,
    stream_rate: 10,
    data_saving: true,
    channels: [
      {
        type: "register_input",
        channel: inputReg0.key,
        address: 0,
        data_type: "uint8",
      },
      {
        type: "register_input",
        channel: inputReg1.key,
        address: 1,
        data_type: "uint8",
      },
    ],
  }),
});

// Start task
await task.executeCommandSync("start");

// Read data
const streamer = await client.openStreamer(["input_register_0", "input_register_1"]);
for (let i = 0; i < 10; i++) {
  const frame = await streamer.read();
  console.log(frame);
}

// Stop task
await task.executeCommandSync("stop");
await streamer.close();
```

</Details>

<Details>
<Text.Text slot="summary" level="p"><Icon.Edit /> Edit task configuration</Text.Text>

```typescript
// Retrieve existing task
const task = await client.tasks.retrieve({ name: "Modbus Read Task" });

// Parse and update configuration
const config = JSON.parse(task.config);

// Update task-level configuration
config.auto_start = true;
config.stream_rate = 5;

// Update first channel configuration
config.channels[0].address = 10;
config.channels[0].data_type = "uint16";

// Update second channel configuration
config.channels[1].address = 11;
config.channels[1].data_type = "uint16";

// Apply changes
await client.tasks.create({
  key: task.key,
  name: task.name,
  type: task.type,
  config: JSON.stringify(config),
});
```

</Details>

  </Fragment>
</Client.Tabs>
