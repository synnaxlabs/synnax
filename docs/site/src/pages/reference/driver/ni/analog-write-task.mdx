---
layout: "@/layouts/Reference.astro"
title: "NI Analog Write Task"
description: "Learn how to send analog commands to NI devices with Synnax."
prev: "Analog Read Task"
prevURL: "/reference/driver/ni/analog-read-task"
next: "Counter Read Task"
nextURL: "/reference/driver/ni/counter-read-task"
---

import { Divider, Note, Icon, Text } from "@synnaxlabs/pluto";
import { Video, Image } from "@/components/media/Media";
import { Fragment } from "react";
import Details from "@/components/details/Details.astro";
import ChannelType from "@/components/details/ChannelType.astro";
import DetailsGroup from "@/components/details/Group.astro";
import { Client } from "@/components/client";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

For task lifecycle management, see the
[Task Basics](/reference/driver/task-basics#how-to) page.

<Divider.Divider x />

## How Commands Work

Write tasks use **command** and **state** channels:

- **Command channels** (`_cmd`): Write values here to set analog outputs
- **State channels** (`_state`): Reflect the current output state
- **Command time channels** (`_cmd_time`): Index channels storing command timestamps

When you write to a command channel, the task processes it and updates the state
channel, providing acknowledgment that the command was executed.

<Divider.Divider x />

## Task Configuration Reference

| Parameter     | Type    | Required | Default | Description                                   |
| ------------- | ------- | -------- | ------- | --------------------------------------------- |
| `name`        | string  | Yes      | -       | Human-readable task name                      |
| `state_rate`  | number  | No       | `20`    | Rate (Hz) at which state channels are updated |
| `data_saving` | boolean | No       | `false` | Enable permanent storage in Synnax            |
| `auto_start`  | boolean | No       | `false` | Automatically start task after configuration  |
| `channels`    | array   | Yes      | -       | List of analog output channel configurations  |

<Divider.Divider x />

## Channel Types Reference

<DetailsGroup>

<ChannelType>
<Text.Text slot="summary" level="p"><Icon.Units.Voltage /> Voltage ([`ao_voltage`](https://www.ni.com/docs/en-US/bundle/ni-daqmx-c-api-ref/page/daqmxcfunc/daqmxcreateaovoltagechan.html))</Text.Text>

| Parameter       | Type   | Required | Default | Description                |
| --------------- | ------ | -------- | ------- | -------------------------- |
| `cmd_channel`   | number | Yes      | -       | Synnax command channel key |
| `state_channel` | number | Yes      | -       | Synnax state channel key   |
| `device`        | string | Yes      | -       | Device identifier          |
| `port`          | number | Yes      | -       | Physical port              |
| `min_val`       | number | No       | `-10.0` | Minimum voltage (Volts)    |
| `max_val`       | number | No       | `10.0`  | Maximum voltage (Volts)    |
| `custom_scale`  | object | No       | -       | Custom scaling             |

</ChannelType>

<ChannelType>
<Text.Text slot="summary" level="p"><Icon.Units.Current /> Current ([`ao_current`](https://www.ni.com/docs/en-US/bundle/ni-daqmx-c-api-ref/page/daqmxcfunc/daqmxcreateaocurrentchan.html))</Text.Text>

| Parameter       | Type   | Required | Default | Description                |
| --------------- | ------ | -------- | ------- | -------------------------- |
| `cmd_channel`   | number | Yes      | -       | Synnax command channel key |
| `state_channel` | number | Yes      | -       | Synnax state channel key   |
| `device`        | string | Yes      | -       | Device identifier          |
| `port`          | number | Yes      | -       | Physical port              |
| `min_val`       | number | No       | `0.004` | Minimum current (Amps)     |
| `max_val`       | number | No       | `0.02`  | Maximum current (Amps)     |
| `custom_scale`  | object | No       | -       | Custom scaling             |

</ChannelType>

</DetailsGroup>

<Divider.Divider x />

## Important Rules

- **Command/State pairs** -> Each analog output requires both a command and state
  channel.
- **One task per module** -> Only one running task can claim a module at a time.
- **State rate** -> Higher state rates provide faster feedback but consume more
  resources.

<Divider.Divider x />

## How-To

<Client.Tabs client:load exclude={["cpp"]}>
  <Fragment slot="console">
    <Video
      client:only="react"
      id="device-drivers/ni/analog-write-task/ni-analog-write"
    />
  </Fragment>
  <Fragment slot="python">

<Details>
<Text.Text slot="summary" level="p"><Icon.Play /> Configure and run task</Text.Text>

```python
import synnax as sy
from synnax import ni

client = sy.Synnax()

# Retrieve device
c_dev = client.devices.retrieve(name="Mod1_Current")

# Create command and state time indices
ao_cmd_time = client.channels.create(
    name="ao_cmd_time",
    is_index=True,
    data_type=sy.DataType.TIMESTAMP,
    retrieve_if_name_exists=True,
)
ao_state_time = client.channels.create(
    name="ao_state_time",
    is_index=True,
    data_type=sy.DataType.TIMESTAMP,
    retrieve_if_name_exists=True,
)

# Create command and state channels
current_cmd = client.channels.create(
    name="current_cmd",
    index=ao_cmd_time.key,
    data_type=sy.DataType.FLOAT32,
    retrieve_if_name_exists=True,
)
current_state = client.channels.create(
    name="current_state",
    index=ao_state_time.key,
    data_type=sy.DataType.FLOAT32,
    retrieve_if_name_exists=True,
)

# Create and configure task
task = ni.AnalogWriteTask(
    name="Analog Write Task",
    state_rate=sy.Rate.HZ * 20,
    data_saving=True,
    channels=[
        ni.AOCurrentChan(
            cmd_channel=current_cmd.key,
            state_channel=current_state.key,
            device=c_dev.key,
            port=0,
            min_val=0.004,
            max_val=0.02,
        ),
    ],
)

client.tasks.configure(task)

# Start task and write commands
with task.run():
    with client.open_writer(
        start=sy.TimeStamp.now(),
        channels=["current_cmd"],
    ) as writer:
        # Set output to 0.01A
        writer.write({
            "current_cmd": 0.01,
        })

        # Read back state
        with client.open_streamer(["current_state"]) as streamer:
            frame = streamer.read()
            print(f"State: {frame['current_state']}")
```

</Details>

<Details>
<Text.Text slot="summary" level="p"><Icon.Edit /> Edit task configuration</Text.Text>

```python
# Retrieve existing task
task = client.tasks.retrieve(name="Analog Write Task")
task = ni.AnalogWriteTask(internal=task)

# Update task-level configuration
task.config.auto_start = True
task.config.state_rate = int(sy.Rate.HZ * 50)

# Update channel-level configuration
task.config.channels[0].port = 1
task.config.channels[0].min_val = 0.002
task.config.channels[0].max_val = 0.01

# Apply changes
client.tasks.configure(task)
```

</Details>

  </Fragment>
  <Fragment slot="typescript">

<Details>
<Text.Text slot="summary" level="p"><Icon.Play /> Configure and run task</Text.Text>

```typescript
import { Synnax, TimeStamp, Rate } from "@synnaxlabs/client";

const client = new Synnax();

// Retrieve device
const cDev = await client.devices.retrieve({ name: "Mod1_Current" });

// Create command and state time indices
const aoCmdTime = await client.channels.create({
  name: "ao_cmd_time",
  isIndex: true,
  dataType: "timestamp",
  retrieveIfNameExists: true,
});
const aoStateTime = await client.channels.create({
  name: "ao_state_time",
  isIndex: true,
  dataType: "timestamp",
  retrieveIfNameExists: true,
});

// Create command and state channels
const currentCmd = await client.channels.create({
  name: "current_cmd",
  index: aoCmdTime.key,
  dataType: "float32",
  retrieveIfNameExists: true,
});
const currentState = await client.channels.create({
  name: "current_state",
  index: aoStateTime.key,
  dataType: "float32",
  retrieveIfNameExists: true,
});

// Create and configure task
const task = await client.tasks.create({
  name: "Analog Write Task",
  type: "ni_analog_write",
  config: JSON.stringify({
    state_rate: 20,
    data_saving: true,
    channels: [
      {
        type: "ao_current",
        cmd_channel: currentCmd.key,
        state_channel: currentState.key,
        device: cDev.key,
        port: 0,
        min_val: 0.004,
        max_val: 0.02,
      },
    ],
  }),
});

// Start task
await task.executeCommandSync("start");

// Write command
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["current_cmd"],
});

await writer.write({
  current_cmd: 0.01,
});

// Read state
const streamer = await client.openStreamer(["current_state"]);
const frame = await streamer.read();
console.log(`State: ${frame["current_state"]}`);

// Stop task
await task.executeCommandSync("stop");
await writer.close();
await streamer.close();
```

</Details>

<Details>
<Text.Text slot="summary" level="p"><Icon.Edit /> Edit task configuration</Text.Text>

```typescript
// Retrieve existing task
const task = await client.tasks.retrieve({ name: "Analog Write Task" });

// Parse and update configuration
const config = JSON.parse(task.config);

// Update task-level configuration
config.auto_start = true;
config.state_rate = 50;

// Update channel-level configuration
config.channels[0].port = 1;
config.channels[0].min_val = 0.002;
config.channels[0].max_val = 0.01;

// Apply changes
await client.tasks.create({
  key: task.key,
  name: task.name,
  type: task.type,
  config: JSON.stringify(config),
});
```

</Details>

  </Fragment>
</Client.Tabs>
