---
layout: "@/layouts/Reference.astro"
title: "NI Counter Write Task"
description: "Learn how to use Counter Write Tasks for NI hardware."
next: "Digital Read Task"
nextURL: "/reference/driver/ni/digital-read-task"
prev: "Counter Read Task"
prevURL: "/reference/driver/ni/counter-read-task"
---

import { Divider, Note, Icon, Text } from "@synnaxlabs/pluto";
import { Video, Image } from "@/components/Media";
import { Fragment } from "react";
import { Client } from "@/components/client";
import ExampleDetails from "@/components/details/ExampleDetails.astro";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

<Note.Note variant="error">**TO DO**: Update video for this page</Note.Note>

Generates pulse train outputs on counter channels for NI devices.

<Divider.Divider x />

<Note.Note variant="warning">
  **Configuration Only**: Counter write tasks are configuration-only. Once configured
  and started, the task will continuously generate the specified pulse train based on
  the parameters set during configuration. No command or state channels are created, and
  the pulse output cannot be modified at runtime without reconfiguring the task.
</Note.Note>

<Divider.Divider x />

## Task Configuration Reference

| Parameter    | Type    | Required | Default | Description                                   |
| ------------ | ------- | -------- | ------- | --------------------------------------------- |
| `name`       | string  | Yes      | -       | Human-readable task name                      |
| `auto_start` | boolean | No       | `false` | Automatically start task after configuration  |
| `channels`   | array   | Yes      | -       | List of counter output channel configurations |

<Divider.Divider x />

## Channel Configuration

[Pulse Output NI-DAQmx C API Reference](https://www.ni.com/docs/en-US/bundle/ni-daqmx-c-api-ref/page/daqmxcfunc/daqmxcreatecopulsechantime.html)

| Parameter       | Type   | Required | Default | Description                                 |
| --------------- | ------ | -------- | ------- | ------------------------------------------- |
| `device`        | string | Yes      | -       | Device identifier                           |
| `port`          | number | Yes      | -       | Counter port (0-indexed)                    |
| `idle_state`    | enum   | No       | `Low`   | `Low`, `High` - output level when idle      |
| `initial_delay` | number | No       | `0`     | Delay before first pulse (seconds)          |
| `high_time`     | number | No       | `1e-6`  | Duration of high portion of pulse (seconds) |
| `low_time`      | number | No       | `1e-6`  | Duration of low portion of pulse (seconds)  |

<Divider.Divider x />

## Important Rules

- **Configuration only**: Pulse parameters are set once when the task is configured and
  cannot be changed at runtime
- **No command/state channels**: Unlike other write tasks, counter write tasks do not
  create or use command and state channels
- **One task per module**: Only one running task can claim a module at a time
- **Continuous output**: Once started, the task generates pulses continuously until
  stopped
- **Port validation**: Counter ports cannot be duplicated within the same task

<Divider.Divider x />

## How To

<Client.Tabs client:only="react" exclude={["cpp"]}>
  <Fragment slot="console">
    <Video
      client:only="react"
      id="device-drivers/ni/counter-write-task/counter-write-task-select-device"
    />
  </Fragment>
  <Fragment slot="python">

<ExampleDetails>
<Text.Text slot="summary" level="p"><Icon.Play /> Configure and Run Task</Text.Text>

```python
import synnax as sy
from synnax.hardware import ni

client = sy.Synnax()

# Retrieve device
counter_dev = client.hardware.devices.retrieve(name="Mod1_Counter")

# Create and configure task
# Note: No channels need to be created - task is configuration-only
task = ni.CounterWriteTask(
    name="Counter Write Task",
    channels=[
        ni.COPulseOutputChan(
            device=counter_dev.key,
            port=0,
            idle_state="Low",
            initial_delay=0.0,
            high_time=0.001,  # 1ms high
            low_time=0.001,   # 1ms low (500Hz pulse train)
        ),
        ni.COPulseOutputChan(
            device=counter_dev.key,
            port=1,
            idle_state="High",
            initial_delay=0.0,
            high_time=0.002,  # 2ms high
            low_time=0.001,   # 1ms low (333Hz pulse train)
        ),
        ni.COPulseOutputChan(
            device=counter_dev.key,
            port=2,
            idle_state="Low",
            initial_delay=0.5,  # 500ms delay before starting
            high_time=0.0005,  # 0.5ms high
            low_time=0.0005,   # 0.5ms low (1kHz pulse train)
        ),
    ],
)

client.hardware.tasks.configure(task)

# Start task - pulse trains begin immediately (or after initial_delay)
with task.run():
    # Task is now generating continuous pulse trains on counters 0, 1, and 2
    # No commands to send - output is fixed at configuration time
    sy.sleep(5)  # Let it run for 5 seconds

# Task stops when exiting context
```

</ExampleDetails>

<ExampleDetails>
<Text.Text slot="summary" level="p"><Icon.Edit /> Edit Task Configuration</Text.Text>

```python
# Retrieve existing task
task = client.hardware.tasks.retrieve(name="Counter Write Task")
task = ni.CounterWriteTask(internal=task)

# Update task-level configuration
task.config.auto_start = True

# Update first pulse output channel
task.config.channels[0].high_time = 0.002  # Change to 2ms high
task.config.channels[0].low_time = 0.002   # Change to 2ms low (250Hz)
task.config.channels[0].idle_state = "High"

# Update second pulse output channel
task.config.channels[1].initial_delay = 0.1  # Add 100ms delay
task.config.channels[1].high_time = 0.001
task.config.channels[1].low_time = 0.004    # Change to 4ms low (200Hz)

# Update third pulse output channel
task.config.channels[2].high_time = 0.0001  # Change to 0.1ms high
task.config.channels[2].low_time = 0.0001   # Change to 0.1ms low (5kHz)

# Apply changes
client.hardware.tasks.configure(task)
```

</ExampleDetails>

  </Fragment>
  <Fragment slot="typescript">

<ExampleDetails>
<Text.Text slot="summary" level="p"><Icon.Play /> Configure and Run Task</Text.Text>

```typescript
import { Synnax, TimeSpan } from "@synnaxlabs/client";
import { sleep } from "@synnaxlabs/x";

const client = new Synnax();

// Retrieve device
const counterDev = await client.hardware.devices.retrieve({ name: "Mod1_Counter" });

// Create and configure task
// Note: No channels need to be created - task is configuration-only
const task = await client.hardware.tasks.create({
  name: "Counter Write Task",
  type: "ni_counter_write",
  config: JSON.stringify({
    channels: [
      {
        type: "co_pulse_output",
        device: counterDev.key,
        port: 0,
        idle_state: "Low",
        initial_delay: 0.0,
        high_time: 0.001, // 1ms high
        low_time: 0.001, // 1ms low (500Hz pulse train)
        units: "Seconds",
      },
      {
        type: "co_pulse_output",
        device: counterDev.key,
        port: 1,
        idle_state: "High",
        initial_delay: 0.0,
        high_time: 0.002, // 2ms high
        low_time: 0.001, // 1ms low (333Hz pulse train)
        units: "Seconds",
      },
      {
        type: "co_pulse_output",
        device: counterDev.key,
        port: 2,
        idle_state: "Low",
        initial_delay: 0.5, // 500ms delay before starting
        high_time: 0.0005, // 0.5ms high
        low_time: 0.0005, // 0.5ms low (1kHz pulse train)
        units: "Seconds",
      },
    ],
  }),
});

// Start task - pulse trains begin immediately (or after initial_delay)
await task.executeCommandSync("start");

// Task is now generating continuous pulse trains on counters 0, 1, and 2
// No commands to send - output is fixed at configuration time

// Wait 5 seconds
await sleep.sleep(TimeSpan.seconds(5));

// Stop task
await task.executeCommandSync("stop");
```

</ExampleDetails>

<ExampleDetails>
<Text.Text slot="summary" level="p"><Icon.Edit /> Edit Task Configuration</Text.Text>

```typescript
// Retrieve existing task
const task = await client.hardware.tasks.retrieve({ name: "Counter Write Task" });

// Parse and update configuration
const config = JSON.parse(task.config);

// Update task-level configuration
config.auto_start = true;

// Update first pulse output channel
config.channels[0].high_time = 0.002; // Change to 2ms high
config.channels[0].low_time = 0.002; // Change to 2ms low (250Hz)
config.channels[0].idle_state = "High";

// Update second pulse output channel
config.channels[1].initial_delay = 0.1; // Add 100ms delay
config.channels[1].high_time = 0.001;
config.channels[1].low_time = 0.004; // Change to 4ms low (200Hz)

// Update third pulse output channel
config.channels[2].high_time = 0.0001; // Change to 0.1ms high
config.channels[2].low_time = 0.0001; // Change to 0.1ms low (5kHz)

// Apply changes
await client.hardware.tasks.create({
  key: task.key,
  name: task.name,
  type: task.type,
  config: JSON.stringify(config),
});
```

</ExampleDetails>

  </Fragment>
</Client.Tabs>

For task lifecycle management, see the
[Task Basics](/reference/driver/task-basics#how-to) page.
