---
layout: "@/layouts/Reference.astro"
title: "Build a Device Driver"
description: "Creating custom hardware integrations with device drivers."
prev: "Time Types"
prevURL: "/reference/client/advanced/time-types"
next: "Examples"
nextURL: "/reference/client/examples"
clients: ["python", "typescript"]
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { Fragment } from "react";
import { Image, Video } from "@/components/Media";
import { Client } from "@/components/client";
import StepText from "@/components/StepText.astro";
import Code from "@/components/code/Code.astro";
import ExampleDetails from "@/components/details/ExampleDetails.astro";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

While the [Synnax Driver](/reference/driver) is great for the devices it supports, you
may need to integrate your own hardware with Synnax. This guide walks you through
building a reliable, performant driver using the client libraries. The guide uses an
Arduino as an example, but the patterns apply to any serial-based device.

<Divider.Divider x />

## Prerequisites

Before starting, ensure you have:

- **Synnax Core** running ([installation guide](/reference/core/installation))
- **Synnax Console** installed ([get started](/reference/console/get-started))
- **Arduino IDE** ([download](https://www.arduino.cc/en/software)) - any Arduino board
  works (this guide uses an Arduino Mega 2560)

<Client.Tabs client:load exclude={["console", "cpp"]}>
  <Fragment slot="python">
    - **Python 3.12+** with the Synnax client: `pip install synnax` - **pyserial**
    package: `pip install pyserial`
  </Fragment>
  <Fragment slot="typescript">
    - **Node.js 18+** with the Synnax client: `npm install @synnaxlabs/client` -
    **serialport** package: `npm install serialport @serialport/parser-readline`
  </Fragment>
</Client.Tabs>

<Image
  client:only="react"
  id="guides/software/arduino-splashscreen"
  themed={false}
  style={{ maxWidth: 500 }}
/>

<Divider.Divider x />

## Read-Only Driver

This section sets up the Arduino to continuously read from an analog input and send the
value over serial. The driver script captures each incoming value and writes it to a
[channel](/reference/concepts/channels) in Synnax.

### <StepText step={1} level="h3">Arduino Code</StepText>

Upload this code to your Arduino.

```cpp
const int analogPin = A0;

void setup() {
  Serial.begin(9600);
}

void loop() {
  float analogValue = analogRead(analogPin);
  Serial.println(analogValue);
  delay(100); // ~10Hz sampling rate
}
```

### <StepText step={2} level="h3">Serial Connection</StepText>

Create a driver file. Find your Arduino's port in the Arduino IDE (top-right corner when
connected via USB).

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">

```python
import serial

PORT = "/dev/ttyACM0"  # Update with your port
BAUD_RATE = 9600

ser = serial.Serial(PORT, BAUD_RATE)
if ser.is_open:
    print("Serial connection established")
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
import { SerialPort } from "serialport";
import { ReadlineParser } from "@serialport/parser-readline";

const PORT = "/dev/ttyACM0"; // Update with your port
const BAUD_RATE = 9600;

const port = new SerialPort({ path: PORT, baudRate: BAUD_RATE });
const parser = port.pipe(new ReadlineParser({ delimiter: "\n" }));

port.on("open", () => console.log("Serial connection established"));
```

  </Fragment>

</Client.Tabs>

### <StepText step={3} level="h3">Reading from Arduino</StepText>

Read values in a loop.

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">

```python
while True:
    value = float(ser.readline().decode("utf-8").rstrip())
    print(value)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
parser.on("data", (line: string) => {
  const value = parseFloat(line.trim());
  console.log(value);
});
```

  </Fragment>

</Client.Tabs>

### <StepText step={4} level="h3">Setting up Synnax Client</StepText>

Create a client and two channels - an **index channel** for timestamps and a **data
channel** for values.

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">

```python
import synnax as sy

client = sy.Synnax(
    host="localhost",
    port=9090,
    username="synnax",
    password="seldon",
)

index_channel = client.channels.create(
    name="arduino_time",
    is_index=True,
    data_type="timestamp",
    retrieve_if_name_exists=True,
)

data_channel = client.channels.create(
    name="arduino_value",
    index=index_channel.key,
    data_type="float32",
    retrieve_if_name_exists=True,
)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
import Synnax, { DataType } from "@synnaxlabs/client";

const client = new Synnax({
  host: "localhost",
  port: 9090,
  username: "synnax",
  password: "seldon",
});

const indexChannel = await client.channels.create({
  name: "arduino_time",
  isIndex: true,
  dataType: DataType.TIMESTAMP,
  retrieveIfNameExists: true,
});

const dataChannel = await client.channels.create({
  name: "arduino_value",
  index: indexChannel.key,
  dataType: DataType.FLOAT32,
  retrieveIfNameExists: true,
});
```

  </Fragment>

</Client.Tabs>

### <StepText step={5} level="h3">Writing to Synnax</StepText>

Open a writer and stream data.

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">

```python
with client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["arduino_time", "arduino_value"]
) as writer:
    while True:
        value = float(ser.readline().decode("utf-8").rstrip())
        writer.write({
            "arduino_time": sy.TimeStamp.now(),
            "arduino_value": value,
        })
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
import { TimeStamp } from "@synnaxlabs/client";

const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["arduino_time", "arduino_value"],
});

parser.on("data", async (line: string) => {
  const value = parseFloat(line.trim());
  await writer.write({
    arduino_time: TimeStamp.now(),
    arduino_value: value,
  });
});

// Remember to close the writer when done
process.on("SIGINT", async () => {
  await writer.close();
  process.exit();
});
```

  </Fragment>

</Client.Tabs>

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">
<ExampleDetails open>
<span slot="summary">`driver_read.py`</span>

```python
import synnax as sy
import serial

PORT = "/dev/ttyACM0"
BAUD_RATE = 9600

client = sy.Synnax(
    host="localhost",
    port=9090,
    username="synnax",
    password="seldon",
)

index_channel = client.channels.create(
    name="arduino_time",
    is_index=True,
    data_type="timestamp",
    retrieve_if_name_exists=True,
)

data_channel = client.channels.create(
    name="arduino_value",
    index=index_channel.key,
    data_type="float32",
    retrieve_if_name_exists=True,
)

ser = serial.Serial(PORT, BAUD_RATE)
if not ser.is_open:
    raise ConnectionError("Failed to establish serial connection")

with client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["arduino_time", "arduino_value"],
) as writer:
    while True:
        value = float(ser.readline().decode("utf-8").rstrip())
        writer.write({
            "arduino_time": sy.TimeStamp.now(),
            "arduino_value": value,
        })
```

</ExampleDetails>
  </Fragment>

  <Fragment slot="typescript">
<ExampleDetails open>
<span slot="summary">`driver_read.ts`</span>

```typescript
import Synnax, { DataType, TimeStamp } from "@synnaxlabs/client";
import { SerialPort } from "serialport";
import { ReadlineParser } from "@serialport/parser-readline";

const PORT = "/dev/ttyACM0";
const BAUD_RATE = 9600;

const client = new Synnax({
  host: "localhost",
  port: 9090,
  username: "synnax",
  password: "seldon",
});

const indexChannel = await client.channels.create({
  name: "arduino_time",
  isIndex: true,
  dataType: DataType.TIMESTAMP,
  retrieveIfNameExists: true,
});

const dataChannel = await client.channels.create({
  name: "arduino_value",
  index: indexChannel.key,
  dataType: DataType.FLOAT32,
  retrieveIfNameExists: true,
});

const port = new SerialPort({ path: PORT, baudRate: BAUD_RATE });
const parser = port.pipe(new ReadlineParser({ delimiter: "\n" }));

port.on("error", (err) => {
  throw new Error(`Failed to open serial port: ${err.message}`);
});

const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["arduino_time", "arduino_value"],
});

parser.on("data", async (line: string) => {
  const value = parseFloat(line.trim());
  await writer.write({
    arduino_time: TimeStamp.now(),
    arduino_value: value,
  });
});

process.on("SIGINT", async () => {
  await writer.close();
  process.exit();
});
```

</ExampleDetails>
  </Fragment>

</Client.Tabs>

### <StepText step={6} level="h3">Console Plot</StepText>

With the script running, set up a line plot in the Console:

<Video client:only="react" id="client/resources/build-device-driver/line-plot" />

<Divider.Divider x />

## Write-Only Driver

This section covers receiving commands from Synnax to control digital outputs on the
Arduino.

### <StepText step={1} level="h3">Arduino Code</StepText>

Upload this code (uses the built-in LED on pin 13).

```cpp
const int digitalPin = 13;

void setup() {
  Serial.begin(9600);
  pinMode(digitalPin, OUTPUT);
}

void loop() {
  if (Serial.available() > 0) {
    char command = Serial.read();
    if (command == '1') {
      digitalWrite(digitalPin, HIGH);
      Serial.println("ON");
    } else if (command == '0') {
      digitalWrite(digitalPin, LOW);
      Serial.println("OFF");
    }
  }
  delay(10);
}
```

### <StepText step={2} level="h3">Synnax Command Channel</StepText>

Create a **virtual** command channel. Virtual channels do not store historical values.
As a consequence, an index channel is not needed.

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">

```python
command_channel = client.channels.create(
    name="arduino_command",
    data_type="uint8",
    virtual=True,
    retrieve_if_name_exists=True,
)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const commandChannel = await client.channels.create({
  name: "arduino_command",
  dataType: DataType.UINT8,
  virtual: true,
  retrieveIfNameExists: true,
});
```

  </Fragment>

</Client.Tabs>

### <StepText step={3} level="h3">Streaming Commands</StepText>

Open a streamer to receive commands and write them to serial.

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">

```python
with client.open_streamer(["arduino_command"]) as streamer:
    for frame in streamer:
        command = str(frame["arduino_command"][0])
        ser.write(command.encode("utf-8"))
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const streamer = await client.openStreamer(["arduino_command"]);

for await (const frame of streamer) {
  const command = String(frame.get("arduino_command").at(0));
  port.write(command);
}
```

  </Fragment>

</Client.Tabs>

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">
<ExampleDetails open>
<span slot="summary">`driver_write.py`</span>

```python
import synnax as sy
import serial

PORT = "/dev/ttyACM0"
BAUD_RATE = 9600

ser = serial.Serial(PORT, BAUD_RATE)
if not ser.is_open:
    raise ConnectionError("Failed to establish serial connection")

client = sy.Synnax(
    host="localhost",
    port=9090,
    username="synnax",
    password="seldon",
)

command_channel = client.channels.create(
    name="arduino_command",
    data_type="uint8",
    virtual=True,
    retrieve_if_name_exists=True,
)

with client.open_streamer(["arduino_command"]) as streamer:
    for frame in streamer:
        command = str(frame["arduino_command"][0])
        ser.write(command.encode("utf-8"))
```

</ExampleDetails>
  </Fragment>

  <Fragment slot="typescript">
<ExampleDetails open>
<span slot="summary">`driver_write.ts`</span>

```typescript
import Synnax, { DataType } from "@synnaxlabs/client";
import { SerialPort } from "serialport";

const PORT = "/dev/ttyACM0";
const BAUD_RATE = 9600;

const port = new SerialPort({ path: PORT, baudRate: BAUD_RATE });

port.on("error", (err) => {
  throw new Error(`Failed to open serial port: ${err.message}`);
});

const client = new Synnax({
  host: "localhost",
  port: 9090,
  username: "synnax",
  password: "seldon",
});

const commandChannel = await client.channels.create({
  name: "arduino_command",
  dataType: DataType.UINT8,
  virtual: true,
  retrieveIfNameExists: true,
});

const streamer = await client.openStreamer(["arduino_command"]);

for await (const frame of streamer) {
  const command = String(frame.get("arduino_command").at(0));
  port.write(command);
}
```

</ExampleDetails>
  </Fragment>

</Client.Tabs>

### <StepText step={4} level="h3">Console Control</StepText>

Set up a switch on a [schematic](/reference/console/schematics).

<Video client:only="react" id="client/resources/build-device-driver/schematic" />

<Divider.Divider x />

## Read-Write Driver

You may have noticed the previous section set both "State" and "Command" to the same
channel. This works, but has a problem: if the driver stops, clicking the switch still
appears to work (it toggles visually) even though nothing happens on the hardware.

The solution is to use **separate channels**: a **command channel** for sending
commands, and a **state channel** that reflects the actual hardware state. The switch
only updates when the state channel confirms the change.

### <StepText step={1} level="h3">Arduino Code</StepText>

This code reads commands, controls the output, and sends back both state and analog
values.

```cpp
const int digitalPin = 13;
const int analogPin = A0;
int state = 0;

void setup() {
  Serial.begin(9600);
  pinMode(digitalPin, OUTPUT);
}

void loop() {
  if (Serial.available() > 0) {
    char command = Serial.read();
    if (command == '1') {
      digitalWrite(digitalPin, HIGH);
      state = 1;
    } else if (command == '0') {
      digitalWrite(digitalPin, LOW);
      state = 0;
    }
  }
  float analogValue = analogRead(analogPin);
  String output = String(state) + "," + String(analogValue);
  Serial.println(output);
  delay(10);
}
```

### <StepText step={2} level="h3">Synnax Channels</StepText>

Create four channels: command, time, state, and value.

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">

```python
arduino_command = client.channels.create(
    name="arduino_command",
    data_type="uint8",
    virtual=True,
    retrieve_if_name_exists=True,
)

arduino_time = client.channels.create(
    name="arduino_time",
    is_index=True,
    data_type="timestamp",
    retrieve_if_name_exists=True,
)

arduino_state = client.channels.create(
    name="arduino_state",
    index=arduino_time.key,
    data_type="uint8",
    retrieve_if_name_exists=True,
)

arduino_value = client.channels.create(
    name="arduino_value",
    index=arduino_time.key,
    data_type="float32",
    retrieve_if_name_exists=True,
)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const arduinoCommand = await client.channels.create({
  name: "arduino_command",
  dataType: DataType.UINT8,
  virtual: true,
  retrieveIfNameExists: true,
});

const arduinoTime = await client.channels.create({
  name: "arduino_time",
  isIndex: true,
  dataType: DataType.TIMESTAMP,
  retrieveIfNameExists: true,
});

const arduinoState = await client.channels.create({
  name: "arduino_state",
  index: arduinoTime.key,
  dataType: DataType.UINT8,
  retrieveIfNameExists: true,
});

const arduinoValue = await client.channels.create({
  name: "arduino_value",
  index: arduinoTime.key,
  dataType: DataType.FLOAT32,
  retrieveIfNameExists: true,
});
```

  </Fragment>

</Client.Tabs>

### <StepText step={3} level="h3">Combined Read-Write Loop</StepText>

Stream commands while writing state and values.

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">

```python
with client.open_streamer(["arduino_command"]) as streamer:
    with client.open_writer(
        start=sy.TimeStamp.now(),
        channels=["arduino_time", "arduino_state", "arduino_value"],
    ) as writer:
        while True:
            fr = streamer.read(timeout=0)
            if fr is not None:
                command = str(fr["arduino_command"][0])
                ser.write(command.encode("utf-8"))
            data = ser.readline().decode("utf-8").rstrip()
            if data:
                split = data.split(",")
                writer.write({
                    "arduino_time": sy.TimeStamp.now(),
                    "arduino_state": int(split[0]),
                    "arduino_value": float(split[1]),
                })
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const streamer = await client.openStreamer(["arduino_command"]);
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["arduino_time", "arduino_state", "arduino_value"],
});

// Handle incoming commands
streamer.read().then(async function processCommand(frame) {
  if (frame) {
    const command = String(frame.get("arduino_command").at(0));
    port.write(command);
  }
  streamer.read().then(processCommand);
});

// Handle incoming data from Arduino
parser.on("data", async (line: string) => {
  const data = line.trim();
  if (data) {
    const [state, value] = data.split(",");
    await writer.write({
      arduino_time: TimeStamp.now(),
      arduino_state: parseInt(state),
      arduino_value: parseFloat(value),
    });
  }
});

process.on("SIGINT", async () => {
  streamer.close();
  await writer.close();
  process.exit();
});
```

  </Fragment>

</Client.Tabs>

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">
<ExampleDetails open>
<span slot="summary">`driver.py`</span>

```python
import synnax as sy
import serial

PORT = "/dev/ttyACM0"
BAUD_RATE = 9600

ser = serial.Serial(PORT, BAUD_RATE)
if not ser.is_open:
    raise ConnectionError("Failed to establish serial connection")

client = sy.Synnax(
    host="localhost",
    port=9090,
    username="synnax",
    password="seldon",
)

arduino_command = client.channels.create(
    name="arduino_command",
    data_type="uint8",
    virtual=True,
    retrieve_if_name_exists=True,
)

arduino_time = client.channels.create(
    name="arduino_time",
    is_index=True,
    data_type="timestamp",
    retrieve_if_name_exists=True,
)

arduino_state = client.channels.create(
    name="arduino_state",
    index=arduino_time.key,
    data_type="uint8",
    retrieve_if_name_exists=True,
)

arduino_value = client.channels.create(
    name="arduino_value",
    index=arduino_time.key,
    data_type="float32",
    retrieve_if_name_exists=True,
)

with client.open_streamer(["arduino_command"]) as streamer:
    with client.open_writer(
        start=sy.TimeStamp.now(),
        channels=["arduino_time", "arduino_state", "arduino_value"],
    ) as writer:
        while True:
            fr = streamer.read(timeout=0)
            if fr is not None:
                command = str(fr["arduino_command"][0])
                ser.write(command.encode("utf-8"))
            data = ser.readline().decode("utf-8").rstrip()
            if data:
                split = data.split(",")
                writer.write({
                    "arduino_time": sy.TimeStamp.now(),
                    "arduino_state": int(split[0]),
                    "arduino_value": float(split[1]),
                })
```

</ExampleDetails>
  </Fragment>

  <Fragment slot="typescript">
<ExampleDetails open>
<span slot="summary">`driver.ts`</span>

```typescript
import Synnax, { DataType, TimeStamp } from "@synnaxlabs/client";
import { SerialPort } from "serialport";
import { ReadlineParser } from "@serialport/parser-readline";

const PORT = "/dev/ttyACM0";
const BAUD_RATE = 9600;

const port = new SerialPort({ path: PORT, baudRate: BAUD_RATE });
const parser = port.pipe(new ReadlineParser({ delimiter: "\n" }));

port.on("error", (err) => {
  throw new Error(`Failed to open serial port: ${err.message}`);
});

const client = new Synnax({
  host: "localhost",
  port: 9090,
  username: "synnax",
  password: "seldon",
});

const arduinoCommand = await client.channels.create({
  name: "arduino_command",
  dataType: DataType.UINT8,
  virtual: true,
  retrieveIfNameExists: true,
});

const arduinoTime = await client.channels.create({
  name: "arduino_time",
  isIndex: true,
  dataType: DataType.TIMESTAMP,
  retrieveIfNameExists: true,
});

const arduinoState = await client.channels.create({
  name: "arduino_state",
  index: arduinoTime.key,
  dataType: DataType.UINT8,
  retrieveIfNameExists: true,
});

const arduinoValue = await client.channels.create({
  name: "arduino_value",
  index: arduinoTime.key,
  dataType: DataType.FLOAT32,
  retrieveIfNameExists: true,
});

const streamer = await client.openStreamer(["arduino_command"]);
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["arduino_time", "arduino_state", "arduino_value"],
});

// Handle incoming commands
streamer.read().then(async function processCommand(frame) {
  if (frame) {
    const command = String(frame.get("arduino_command").at(0));
    port.write(command);
  }
  streamer.read().then(processCommand);
});

// Handle incoming data from Arduino
parser.on("data", async (line: string) => {
  const data = line.trim();
  if (data) {
    const [state, value] = data.split(",");
    await writer.write({
      arduino_time: TimeStamp.now(),
      arduino_state: parseInt(state),
      arduino_value: parseFloat(value),
    });
  }
});

process.on("SIGINT", async () => {
  streamer.close();
  await writer.close();
  process.exit();
});
```

</ExampleDetails>
  </Fragment>

</Client.Tabs>

### <StepText step={4} level="h3">Console Setup</StepText>

Now configure the switch with separate channels:

- **Command**: `arduino_command`
- **State**: `arduino_state`

Add a line plot for `arduino_value` to see the analog input.

<Video client:only="react" id="client/resources/build-device-driver/console-setup" />

<Divider.Divider x />

## Production Drivers

For production-grade hardware integrations, see the
[C++ Driver documentation](/reference/driver). The C++ driver offers:

- **Built-in support** for LabJack, National Instruments, OPC UA, and Modbus devices
- **Better performance** for high-frequency data acquisition
- **Device pooling** and connection management
- **Cross-platform support** (Windows, macOS, Linux)
- **Integration** with the Synnax task management system
