---
layout: "@/layouts/Reference.astro"
title: "Writing Data"
description: "Learn the fundamentals of writing data to channels in Synnax."
next: "Series & Frames"
nextURL: "/reference/client/working-with-data/series-and-frames"
prev: "Reading Data"
prevURL: "/reference/client/fundamentals/read-data"
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { Fragment } from "react";
import { Client } from "@/components/client";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

<Note.Note variant="error">
  TODO: Even though another page will cover "advanced writing pattern", we should still add another simple example.
</Note.Note>

This guide covers the fundamental patterns for writing data to Synnax channels. We'll
focus on simple, straightforward writes to get you started quickly.

If you'd like a conceptual overview of how writes work in Synnax, check out the
[writes concepts guide](/reference/concepts/writes). The
[rules of writes](/reference/concepts/writes#rules-of-writes) are especially important
to understand.

<Note.Note variant="info">
  Using writers, transactions, authorities, auto-commit, and streaming modes are covered
  in [Advanced Topics - Writers](/reference/client/advanced/writers).
</Note.Note>

<Divider.Divider x />

## Writing to a Channel

<Client.Tabs client:load exclude={["console", "cpp"]}>

  <Fragment slot="python">
      ```python
      start = sy.TimeStamp.now()
      times = [
          start,
          start + 1 * sy.TimeSpan.MINUTE,
          start + 2 * sy.TimeSpan.MINUTE,
          start + 3 * sy.TimeSpan.MINUTE,
          start + 4 * sy.TimeSpan.MINUTE,
      ]
      temperatures = [55, 55.1, 55.7, 57.2, 58.1]

      # Write the timestamps to the index
      time_channel.write(start, times)

      # Write the data to the channel
      temp_channel.write(start, temperatures)
      ```

  </Fragment>

  <Fragment slot="typescript">
    ```typescript
    const start = TimeStamp.now();
    const timestamps = new BigInt64Array([
      start.valueOf(),
      start.add(TimeSpan.seconds(1)).valueOf(),
      start.add(TimeSpan.seconds(2)).valueOf(),
      start.add(TimeSpan.seconds(3)).valueOf(),
      start.add(TimeSpan.seconds(4)).valueOf(),
    ]);
    const temperatures = new Float32Array([20.0, 20.1, 20.2, 20.3, 20.4]);

    // Write the timestamps to the index first
    await timeChannel.write(start, timestamps);

    // Then write the data
    await temperatureChannel.write(start, temperatures);
    ```

  </Fragment>
</Client.Tabs>

### Index and Data Alignment

Notice how we align the two arrays using the common `start` timestamp. This tells Synnax
that the first sample in the `temperatures` array is associated with the first timestamp
in the `timestamps` array.

Synnax will raise a `ValidationError` if the index channel does not contain a
corresponding timestamp for every sample in the data channel. After all, it wouldn't
make sense to have a temperature reading without an associated timestamp.

<Note.Note variant="info" className="compact">
  Writers, transactions, authorities, and advanced writing patterns are covered in{" "}
  <a href="/reference/client/advanced/writers">Advanced Topics - Writers</a>.
</Note.Note>

<Divider.Divider x />
