---
layout: "@/layouts/Reference.astro"
title: "Streaming Data"
description: "Real-time data streaming patterns for live telemetry."
next: "Iterators"
nextURL: "/reference/client/working-with-data/iterators"
prev: "Ranges"
prevURL: "/reference/client/working-with-data/ranges"
clients: ["python", "typescript"]
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { Fragment } from "react";
import { Client } from "@/components/client";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

Streaming data is useful for real-time processing, visualization, and monitoring. This
guide covers using the Synnax client to stream data from a Synnax cluster. If you'd like
a conceptual overview of how streaming works in Synnax, check out the
[streams](/reference/concepts/streams) page.

<Divider.Divider x />

## Opening a Streamer

To start streaming data, call the <Client.Var client:load py="open_streamer"
ts="openStreamer" /> method on the client and provide a list of channels to stream.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
streamer = client.open_streamer(["channel1", "channel2"])
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const streamer = await client.openStreamer(["temperature1", "temperature2"]);
```

  </Fragment>
</Client.Tabs>

### Downsampling Option

To stream data at a lower rate, use the <Client.Var client:load py="downsample_factor"
ts="downsampleFactor" /> parameter. The streamer will skip the specified number of
samples in each series before returning the next frame. Note that this does not average
values—it skips samples.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
# Read every 2nd sample
streamer = client.open_streamer(
    channels=["temperature", "pressure"],
    downsample_factor=2,
)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
// Read every 2nd sample
const streamer = await client.openStreamer({
  channels: ["temperature", "pressure"],
  downsampleFactor: 2,
});
```

  </Fragment>
</Client.Tabs>

### Using an Async Streamer

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

For `asyncio` support, use `open_async_streamer`. It has the same interface as the
synchronous streamer:

```python
async with await client.open_async_streamer(["channel1", "channel2"]) as streamer:
    async for frame in streamer:
        # Process the frame
```

  </Fragment>

  <Fragment slot="typescript">

<br />

<Note.Note variant="info">TypeScript streaming is async by default.</Note.Note>

  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Reading Frames

To read the next incoming frame, call the `read` method on the streamer.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
frame = streamer.read()
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const frame = await streamer.read();
```

  </Fragment>
</Client.Tabs>

This call will block until a new frame is available. Note that a frame may not contain
data for every channel—see [Handling Partial Frames](#handling-partial-frames) for
details.

For more on working with frames, see
[Series and Frames](/reference/client/working-with-data/series-and-frames).

### Using a For Loop

The streamer implements an iterator, allowing you to use a for loop to continuously
process incoming frames.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
# Process frames synchronously

for frame in streamer:
    print(frame.at(-1))
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
// Process frames asynchronously
for await (const frame of streamer) {
  console.log(frame.at(-1));
}
```

  </Fragment>
</Client.Tabs>

### Handling Partial Frames

When reading frames from a streamer, it's important to note that a frame may not contain
data for every channel specified when opening the streamer. For example, when reading
from two sensors, `temperature` and `pressure`, that are being sampled by different
devices at different rates, a frame may contain data only for the first channel,
followed by a frame containing only data for the second channel.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
streamer = client.open_streamer(["temperature", "pressure"])

frame = streamer.read()
print(frame[-1])
# Output: {"temperature": 25.0}

frame = streamer.read()
print(frame[-1])
# Output: {"pressure": 1013.25}

frame = streamer.read()
print(frame[-1])
# Output: {"temperature": 25.1, "pressure": 1013.25}

# Check if a frame contains data for a specific channel
if "temperature" in frame:
    print(frame["temperature"])
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const streamer = await client.openStreamer(["temperature", "pressure"]);

const frame = await streamer.read();
console.log(frame.at(-1));
// Output: { temperature: 25.0 }

const frame2 = await streamer.read();
console.log(frame2.at(-1));
// Output: { pressure: 1013.25 }

const frame3 = await streamer.read();
console.log(frame3.at(-1));
// Output: { temperature: 25.1, pressure: 1013.25 }

// Check if a frame contains data for a specific channel
if (frame.has("temperature")) console.log(frame.get("temperature"));
```

  </Fragment>
</Client.Tabs>

### Specifying a Timeout

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

Add a `timeout` parameter to the `read` method. If the timeout is reached before a new
frame is available, the method returns `None`.

```python
# Wait for 5 seconds
frame = streamer.read(timeout=5)

# A `TimeSpan` object can also be used
frame = streamer.read(timeout=5 * sy.TimeSpan.SECOND)

if frame is None:
    print("Timed out waiting for a frame")
```

  </Fragment>

  <Fragment slot="typescript">

TypeScript doesn't have built-in timeout support. Instead, you can use `Promise.race()`
to achieve the equivalent functionality.

```typescript
const timeout = (ms: number) =>
  new Promise<null>((resolve) => setTimeout(() => resolve(null), ms));

// Wait for 5 seconds
const frame = await Promise.race([streamer.read(), timeout(5000)]);

if (frame === null) {
  console.log("Timed out waiting for a frame");
}
```

  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Updating the Channel List

To update the list of channels being streamed, call the <Client.Var client:load
py="update*channels" ts="update" /> method on the streamer. This will \_replace* the
current list of channels, not add to it.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
streamer.update_channels(["temperature", "pressure", "humidity"])
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
await streamer.update(["temperature", "pressure", "humidity"]);
```

  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Closing the Streamer

After you're done streaming, it's essential that you call the `close` method on the
streamer to release the network connection and other related resources.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
streamer.close()
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
streamer.close();
```

  </Fragment>
</Client.Tabs>

Using structured cleanup patterns ensures the streamer is always closed, even if an
exception is thrown.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
# Using the streamer as a context manager ensures
# the streamer is always closed correctly.

with client.open_streamer(["temperature1", "temperature2"]) as streamer:
    for frame in streamer:
        # Process the frame
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const streamer = await client.openStreamer(["temperature1", "temperature2"]);
try {
  for await (const frame of streamer) {
    // Process the frame
  }
} finally {
  streamer.close();
}
```

  </Fragment>
</Client.Tabs>
