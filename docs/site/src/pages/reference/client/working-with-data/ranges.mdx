---
layout: "@/layouts/Reference.astro"
title: "Ranges"
description: "Organizing telemetry data with time-based ranges and metadata."
next: "Streaming Data"
nextURL: "/reference/client/working-with-data/streaming-data"
prev: "Series & Frames"
prevURL: "/reference/client/working-with-data/series-and-frames"
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { Fragment } from "react";
import { Client } from "@/components/client";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

This guide covers working with Ranges - time-based categorizations of data with
metadata. Ranges are useful for organizing telemetry into tests, runs, events, or other
logical groupings.

<Divider.Divider x />

## Range Configuration Reference

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

| Parameter                 | Type        | Required | Default | Description                                                                                       |
| ------------------------- | ----------- | -------- | ------- | ------------------------------------------------------------------------------------------------- |
| `name`                    | string      | Yes      | -       | Human-readable name for the range                                                                 |
| `time_range`              | `TimeRange` | Yes      | -       | Time interval spanned by the range (start must be ≤ end)                                          |
| `color`                   | string      | No       | `""`    | Hex color code for identifying the range in visualizations (e.g., `"#FF0000"`)                    |
| `key`                     | `UUID`      | No       | Auto    | Unique identifier (automatically generated by Synnax if not provided)                             |
| `retrieve_if_name_exists` | boolean     | No       | `False` | If `True`, retrieves existing range with same name and time range instead of creating a duplicate |
| `parent`                  | `ID`        | No       | `None`  | Optional parent ontology item for creating child ranges                                           |

**Understanding `time_range`**

A `TimeRange` defines the start and end boundaries of a range. It specifies the time
interval that the range covers.

**Key Points:**

- **Start and End**: A `TimeRange` has two properties: `start` and `end`, both of which
  are timestamps
- **End-Exclusive**: The range includes data from `start` up to (but not including)
  `end`
- **Validation**: The `start` time must be less than or equal to the `end` time

**Example:**

```python
import synnax as sy

# Create a TimeRange using TimeStamp and TimeSpan
start = sy.TimeStamp.now()
end = start + sy.TimeSpan.HOUR * 2
time_range = sy.TimeRange(start=start, end=end)

# Using the convenience method span_range (recommended)
start = sy.TimeStamp.now()
time_range = start.span_range(sy.TimeSpan.HOUR * 2)

# Create from specific date/time (use string parsing)
start = sy.TimeStamp("2023-02-12 12:30:00")
end = sy.TimeStamp("2023-02-12 14:30:00")
time_range = sy.TimeRange(start=start, end=end)
```

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

| Parameter   | Type        | Required | Default | Description                                                         |
| ----------- | ----------- | -------- | ------- | ------------------------------------------------------------------- |
| `name`      | string      | Yes      | -       | Human-readable name for the range                                   |
| `timeRange` | `TimeRange` | Yes      | -       | Time interval spanned by the range (start must be ≤ end)            |
| `color`     | string      | No       | -       | Hex color code for identifying the range in visualizations          |
| `key`       | string      | No       | Auto    | UUID identifier (automatically generated by Synnax if not provided) |

**Understanding `timeRange`**

A `TimeRange` defines the start and end boundaries of a range. It specifies the time
interval that the range covers.

**Key Points:**

- **Start and End**: A `TimeRange` has two properties: `start` and `end`, both of which
  are timestamps
- **End-Exclusive**: The range includes data from `start` up to (but not including)
  `end`
- **Validation**: The `start` time must be less than or equal to the `end` time

**Example:**

```typescript
import { TimeRange, TimeSpan, TimeStamp } from "@synnaxlabs/client";

// Create a TimeRange using TimeStamp and TimeSpan
const start = TimeStamp.now();
const end = start.add(TimeSpan.hours(2));
const timeRange = new TimeRange(start, end);

// Using the convenience span method (recommended)
const start = TimeStamp.now();
const timeRange = start.span(TimeSpan.hours(2));

// Create from specific date/time
const start = new TimeStamp("2023-02-12 12:30:00");
const end = new TimeStamp("2023-02-12 14:30:00");
const timeRange = new TimeRange(start, end);
```

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Creating Ranges

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

To create a range, we can use the `client.ranges.create` method:

```python
import synnax as sy

# Create a range with a specific time interval
start = sy.TimeStamp("2023-02-12 12:30:00")
end = sy.TimeStamp("2023-02-12 14:30:00")

my_range = client.ranges.create(
    # This name does not need to be unique, but it's a good idea to
    # pick something that will be easy to identify later.
    name="My Range",
    time_range=sy.TimeRange(start=start, end=end),
)

# Or use the convenience span_range method
start = sy.TimeStamp.now()
my_range = client.ranges.create(
    name="My Range",
    time_range=start.span_range(sy.TimeSpan.HOUR * 2),
)
```

Synnax will automatically generate a unique identifier for the range.

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

To create a range, we can use the `client.ranges.create` method:

```typescript
import { TimeRange, TimeSpan, TimeStamp } from "@synnaxlabs/client";

// Create a range with a specific time interval
const start = new TimeStamp("2023-02-12 12:30:00");
const end = new TimeStamp("2023-02-12 14:30:00");
const range = await client.ranges.create({
  name: "My Range",
  timeRange: new TimeRange(start, end),
  color: "#FF0000", // Optional: color for visualization
});

// Or use the convenience span method
const start = TimeStamp.now();
const range = await client.ranges.create({
  name: "My Range",
  timeRange: start.span(TimeSpan.hours(2)),
  color: "#FF0000",
});
```

This creates a range inside Synnax that you can then view from the Console.

    </Note.Note>
  </Fragment>
</Client.Tabs>

### Only Create a Range if it Doesn't Exist

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

If we only want to create a range if one with the same name doesn't already exist, we
can pass in the `retrieve_if_name_exists` parameter:

```python
start = sy.TimeStamp("2023-02-12 12:30:00")
end = sy.TimeStamp("2023-02-12 14:30:00")

my_range = client.ranges.create(
    name="My Range",
    time_range=sy.TimeRange(start=start, end=end),
    retrieve_if_name_exists=True,
)
```

In the event the range already exists, Synnax will return the existing range instead of
creating a new one.

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

TypeScript doesn't support conditional range creation.

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Creating Child Ranges

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

For more information on child ranges, see the
[ranges](/reference/concepts/ranges#child-ranges) page.

```python
start = sy.TimeStamp("2023-02-12 12:30:00")
end = sy.TimeStamp("2023-02-12 14:30:00")

child_range = parent_range.create_child_range(
    name="My Child Range",
    time_range=sy.TimeRange(start=start, end=end),
)
```

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

TypeScript doesn't have a dedicated `create_child_range` method. See Retrieving Child Ranges below.

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Retrieving Ranges

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

We can fetch a range using the `client.ranges.retrieve` method.

### Retrieving a Single Range

We can retrieve a range by its name or key:

```python
# By name
my_range = client.ranges.retrieve(name="My Range")

# By key
my_range = client.ranges.retrieve(key=my_range.key)
```

Synnax will raise a `NotFoundError` if the range does not exist, and a
`MultipleFoundError` if multiple ranges with the given name exist. If you'd like to
accept multiple or no results, provide a list to the `retrieve` method as shown below.

The `retrieve` method only supports passing in named parameters i.e. `name`, `key`,
`names`, `keys`. If you try to pass in unnamed parameters, Synnax will raise a
`TypeError`.

### Retrieving Multiple Ranges

We can retrieve multiple ranges by passing a list of names or keys to the `retrieve`
method:

```python
# By name
my_ranges = client.ranges.retrieve(names=["My Range", "My Other Range"])

# By key
my_ranges = client.ranges.retrieve(keys=[my_range.key, my_other_range.key])

# This won't work!
my_ranges = client.ranges.retrieve(names=["My Range", my_other_range.key])
```

In these examples, Synnax will not raise an error if a range cannot be found. Instead,
the missing range will be omitted from the returned list.

### Retrieving Child Ranges

We can retrieve child ranges using the `children` property.

```python
child_ranges = my_range.children
```

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

We can retrieve a range using the `client.ranges.retrieve` method:

```typescript
// you can retrieve a single range by its key or name
const tr1 = client.ranges.retrieve("9/7/2025 Hotfire");
const tr2 = client.ranges.retrieve(tr1.key);

// you can also retrieve multiple ranges by their names or keys
const trs = client.ranges.retrieve(["9/7/2025 Hotfire", "9/8/2025 Hotfire"]);
const trs2 = client.ranges.retrieve([tr1.key, tr2.key]);

// you can also retrieve by a search term
const ranges = client.ranges.retrieve({ searchTerm: "Hotfire", limit: 10 });
```

Synnax will throw a `NotFoundError` if you try to retrieve a range that does not exist,
or a `MultipleFoundError` if you try to retrieve a range by its name and multiple ranges
matching that name are found.

```typescript
import { MultipleFoundError, NotFoundError } from "@synnaxlabs/client";

try {
  const tr = client.ranges.retrieve("My Range");
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log("Range not found");
  }
  if (error instanceof MultipleFoundError) {
    console.log("Multiple ranges found");
  }
}
```

### Retrieving Child Ranges or a Parent Range

You can also retrieve the child ranges or parent range of a range:

```typescript
const tr = await client.ranges.retrieve("9/7/2025 Hotfire");
const childRanges = await tr.retrieveChildren();
const parentRange = await tr.retrieveParent();
```

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Updating a Range

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

To update an existing range, we use the same `client.ranges.create` method but specify
the `key` of the range we want to update. This allows us to modify the range's name,
time range, or color.

```python
import synnax as sy

# First, retrieve the range you want to update
my_range = client.ranges.retrieve(name="My Range")

# Update the range by providing its key and new values
updated_range = client.ranges.create(
    key=my_range.key,  # Specify the key to update existing range
    name="My Updated Range",  # New name
    time_range=sy.TimeRange(
        start=sy.TimeStamp("2023-02-12 13:00:00"),
        end=sy.TimeStamp("2023-02-12 15:00:00"),
    ),
    color="#00FF00",  # New color
)
```

When updating a range, you must provide the `key` parameter. If you provide a `key`
that doesn't exist, Synnax will create a new range with that key instead of raising an
error.

**Warning**: Updating a range will completely replace its properties. Make sure to include all the
properties you want to keep, not just the ones you want to change.

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

To update an existing range, we use the same `client.ranges.create` method but specify
the `key` of the range we want to update. This allows us to modify the range's name,
time range, or color.

```typescript
import { TimeRange, TimeStamp } from "@synnaxlabs/client";

// First, retrieve the range you want to update
const myRange = await client.ranges.retrieve("My Range");

// Update the range by providing its key and new values
const updatedRange = await client.ranges.create({
  key: myRange.key, // Specify the key to update existing range
  name: "My Updated Range", // New name
  timeRange: new TimeRange(
    new TimeStamp("2023-02-12 13:00:00"),
    new TimeStamp("2023-02-12 15:00:00"),
  ),
  color: "#00FF00", // New color
});
```

When updating a range, you must provide the `key` parameter. If you provide a `key`
that doesn't exist, Synnax will create a new range with that key instead of raising an
error.

**Warning**: Updating a range will completely replace its properties. Make sure to include all the
properties you want to keep, not just the ones you want to change.

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Working with Channels

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

### Accessing Channels

We can access the channels on a range as if they were class properties or dictionary
keys:

```python
my_range = client.ranges.retrieve(name="My Range")

# Using a property accessor
my_pressure_channel = my_range.pressure_2
# Using a dictionary accessor
my_pressure_channel = my_range["pressure_2"]
```

### Accessing Multiple Channels

We can also access multiple channels on the range by passing a regular expression to our
property accessor:

```python
my_range = client.ranges.retrieve(name="My Range")

# Returns an iterable object containing matching channels
my_pressure_channels = my_range["^pressure"]
```

If we try to access channel-specific methods on the returned object, such as a `name` or
`data`, Synnax will raise `MultipleFoundError`. Instead, we should iterate over the
returned list. Here's a simple example where we plot the data from all of our pressure
channels:

```python
import matplotlib.pyplot as plt

for ch in my_range["^pressure"]:
    plt.plot(my_range.timestamps, ch, label=ch.name)
```

This iteration pattern is valid even if we only have one channel that matches our
regular expression.

### Aliasing Channels

Channels must maintain their original names, but situations arise where we'd like to
give a channel a more descriptive name in the context of a particular range. Ranges
allow us to do just that.

Imagine we have a channel named `daq_analog_input_1` that we'd like to refer to as
`tank_pressure` for a tank burst test. We can do this by aliasing the channel:

```python
burst_test = client.ranges.retrieve(name="Oct 10 Burst Test")

# Set our alias
burst_test.daq_analog_input_1.set_alias("tank_pressure")

# We can also set an alias like this
burst_test.set_alias("daq_analog_input_1", "tank_pressure")
```

We can now access the channel using its alias:

```python
burst_test.tank_pressure
```

Subsequent calls to `set_alias` will overwrite the previous alias.

**Warning**: Aliases are only valid within the context of a particular range. If you try to access
an aliased channel outside of the range, Synnax will not be able to find it.

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

TypeScript doesn't have dedicated channel access methods on ranges. Use the metadata API instead.

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Attaching Metadata

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

### Setting Metadata

It's common to have non-data information we'd like to attach to a particular range, such
as test configuration parameters, numeric results, part numbers, etc. We can attach this
metadata to a range using the `meta_data` property:

```python
burst_test = client.ranges.retrieve(name="Oct 10 Burst Test")

# Set a single key/value pair
burst_test.meta_data.set("part_number", "12345")

# Another way to set a single key/value pair
burst_test.meta_data["part_number"] = "12345"

# Set multiple key/value pairs
burst_test.meta_data.set({
    "part_number": "12345",
    "test_configuration": "Test 1",
    "test_result": "123.45",
})
```

All metadata values are stored as strings. It's up to you to correctly cast the values
to the appropriate type.

### Getting Metadata

Getting metadata is as easy as setting it:

```python
burst_test = client.ranges.retrieve(name="Oct 10 Burst Test")

# Retrieve a single key
part_number = burst_test.meta_data.get("part_number")

# Another way to retrieve a single key
part_number = burst_test.meta_data["part_number"]
```

### Deleting Metadata

We can delete metadata using the `delete` method:

```python
burst_test = client.ranges.retrieve(name="Oct 10 Burst Test")

# Delete a single key
burst_test.meta_data.delete("part_number")

# Another way to delete a single key
del burst_test.meta_data["part_number"]

# Delete multiple keys
burst_test.meta_data.delete(["part_number", "test_configuration"])
```

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

Ranges can store metadata, which is a key-value store of interesting information about
the range:

```typescript
const tr = await client.ranges.retrieve("9/7/2025 Hotfire");
await tr.kv.set("part_number", "12345");
const partNumber = await tr.kv.get("part_number");
console.log(partNumber); // "12345"
```

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Deleting Ranges

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

Deleting a range is as simple as passing in its name or key to the `delete` method:

```python
client.ranges.delete(name="My Range")
client.ranges.delete(key=my_range.key)
```

**Note**: Deleting a range by name will delete _all_ ranges with that name. Be careful!

We can delete multiple ranges by passing a list of names or keys to the `delete` method:

```python
client.ranges.delete(names=["My Range", "My Other Range"])
client.ranges.delete(keys=[my_range.key, my_other_range.key])
```

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

You can delete a range by passing in its key to the `client.ranges.delete` method:

```typescript
const tr = await client.ranges.retrieve("9/7/2025 Hotfire");
await client.ranges.delete(tr.key);
```

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## <span style={{ color: "red" }}>Reading from Ranges</span>

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

While the above methods are useful for executing precise reads, they require us to know
the exact range of time we're interested in reading.
[Ranges](/reference/python-client/ranges) are a useful way of categorizing important
time ranges in Synnax. We can read directly from these ranges.

We can access channels on a `Range` object and call `read` on them to access their data:

```python
rng = client.ranges.retrieve("My Interesting Test")

# Read the data from the channel
data = rng.my_precise_tc.read()

data = data - 273.15
```

It turns out that we don't even need to call the `read` method at all. We can just use
the channel name directly to perform operations on the data:

```python
data = rng.my_precise_tc - 273.15
```

We can also plot the data just as easily:

```python
import matplotlib.pyplot as plt

# Plot time on the x-axis and temperature on the y-axis
plt.plot(rng.time, rng.my_precise_tc)
```

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

TypeScript doesn't support range-based channel retrieval or reading.

    </Note.Note>
  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## <span style={{ color: "red" }}>Writing to Ranges</span>

<Client.Tabs client:load exclude={["cpp","console"]}>
  <Fragment slot="console">
  </Fragment>

  <Fragment slot="python">
    <Note.Note variant="warning">

Writing to a range takes away the burden of needing to correctly align the data from
different channels.

We'll create the following range as an example:

```python
import synnax as sy

# Create the range
burst_test = client.ranges.create(
    name="burst_test",
    time_range=sy.TimeRange(
        start=sy.TimeStamp.now(),
        end=sy.TimeStamp.now() + 1 * sy.TimeSpan.HOUR
    )
)
```

Then, we'll write to the range using the `write` method:

```python
temperatures = [55, 55.1, 55.7, 57.2, 58.1, 58.9, 59.1, 59.2, 59.3]
pressures = [100, 100.1, 100.7, 102.2, 103.1, 103.9, 104.1, 104.2, 104.3]

# This call to write will assume that the timestamp of the first sample is
# the start of the range.
burst_test.write({
    "my_precise_tc": temperatures,
    "my_precise_pt": pressures,
})
```

    </Note.Note>
  </Fragment>

  <Fragment slot="typescript">
    <Note.Note variant="info">

TypeScript doesn't support range-based writing.

    </Note.Note>
  </Fragment>
</Client.Tabs>
