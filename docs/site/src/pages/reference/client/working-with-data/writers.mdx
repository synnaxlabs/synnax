---
layout: "@/layouts/Reference.astro"
title: "Writers"
description:
  "Advanced writing patterns with transactions, authorities, and streaming modes."
next: "Delete Data"
nextURL: "/reference/client/advanced/delete-data"
prev: "Streaming Data"
prevURL: "/reference/client/working-with-data/streaming-data"
clients: ["python", "typescript"]
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { Fragment } from "react";
import { Client } from "@/components/client";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

This guide covers advanced writing patterns using Writer objects for fine-grained
control over transactions, concurrent access, and performance modes.

If you're looking for simple writes, check out the
[Writing Data](/reference/client/write-data) guide instead.

<Divider.Divider x />

## Opening a Writer

While standard write methods are great for writing static, existing data, it's common to
write data in a streaming fashion as it's acquired. This is useful for control sequences
and live data processing. The `Writer` class is designed for this use case (and is used
under the hood by other write methods).

Writers maintain a file-like interface governed by transactions. To learn more about
transactions and how writes work in Synnax, see the
[concepts](/reference/concepts/writes) page.

To open a writer, use the <Client.Var client:load py="open_writer" ts="openWriter" />
method with a starting timestamp and a list of channels to write to.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
# Python's context manager is recommended
with client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
) as writer:
    for i in range(100):
        writer.write({
            "time": sy.TimeStamp.now(),
            "temperature": i * 0.1,
        })
        sy.sleep(0.1)
    writer.commit()
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
});

try {
  for (let i = 0; i < 100; i++)
    await writer.write({ time: TimeStamp.now(), temperature: i * 0.1 });
  await writer.commit();
} finally {
  await writer.close();
}
```

  </Fragment>
</Client.Tabs>

These examples write 100 samples to the `temperature` channel, each spaced roughly 100ms
apart, and commit all writes when finished. It's typical to write and commit millions of
samples over the course of hours or days, intermittently calling commit to persist data
to the cluster.

### Auto-Commit

By default, writers are configured with auto-commit enabled, meaning each write is
immediately committed and available for read access. This is ideal for real-time data
acquisition where you want data to be immediately available for monitoring and analysis.

#### When to Disable Auto-Commit

You may want to disable auto-commit in the following scenarios:

- **Chunk-based file ingestion**: When loading historical data from files, you may want
  to commit data in logical chunks (e.g., after processing each file) to ensure atomic
  visibility of complete datasets.
- **Batch processing**: When ingesting large volumes of historical data where real-time
  visibility is not required and you want to optimize performance by reducing commit
  overhead.
- **Atomic transactions**: When you need multiple writes to appear together atomically
  to maintain data consistency across channels.

To disable auto-commit, set the <Client.Var client:load py="enable_auto_commit"
ts="enableAutoCommit" /> option to

<Client.Var client:load py="False" ts="false" /> when opening the writer.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
with client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
    enable_auto_commit=False,
) as writer:

    for chunk in range(10):
        for i in range(1000):
            writer.write({
                "time": sy.TimeStamp.now(),
                "temperature": i * 0.1,
            })
        # Commit the chunk
        writer.commit()
```

  <div style={{ margin: "4rem 0" }}>

  </div>

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
  enableAutoCommit: false,
});
try {
  for (let chunk = 0; chunk < 10; chunk++) {
    for (let i = 0; i < 1000; i++)
      await writer.write({ time: TimeStamp.now(), temperature: i });
    await writer.commit();
  }
} finally {
  await writer.close();
}
```

  </Fragment>
</Client.Tabs>

### Write Authorities

Writers support dynamic control handoff. Multiple writers can be opened on a channel at
the same time, but only one writer is allowed to write to the channel. To determine
which writer has control, an authority from 0 to 255 is assigned to each writer (or,
optionally, each channel in the writer). The writer with the highest authority will be
allowed to write. If two writers have the same authority, the writer that opened first
will be allowed to write. For more information, see the
[concepts](/reference/concepts/writes#dynamic-control---write-authorities) page.

By default, writers are opened with an authority of `ABSOLUTE` (255). This means that no
other writers can write to the channel as long as the writer is open.

#### Same Authority on All Channels

To open a writer with the same authority on all channels, pass the `authorities`
parameter with an integer.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
writer = client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
    authorities=100,
)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
  authorities: 100,
});
```

  </Fragment>
</Client.Tabs>

#### Different Authorities per Channel

To open a writer with different authorities on each channel, pass the `authorities`
parameter with a list of integers. This list must be the same length as the number of
channels in the writer.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
writer = client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
    authorities=[100, 200],
)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
  authorities: [100, 200],
});
```

  </Fragment>
</Client.Tabs>

#### Adjusting Authority After Open

To change the authority of a writer during operation, use the <Client.Var client:load
py="set_authority" ts="setAuthority" /> method.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
# Set the authority on all channels
writer.set_authority(200)

# Set the authority on specific channels
writer.set_authority({
    "time": 150,
    "temperature": 250,
})
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
// Set the authority on all channels
await writer.setAuthority(200);

// Set the authority on specific channels
await writer.setAuthority({
  time: 150,
  temperature: 250,
});
```

  </Fragment>
</Client.Tabs>

### Persistence/Streaming Mode

By default, writers are opened in stream + persist
[mode](/reference/concepts/writes#persistencestreaming-modes). To change the mode of a
writer, specify the `mode` argument when opening the writer. The available modes are:

- `persist` - Only persist data to the database (no streaming to subscribers)
- `stream` - Only stream data to subscribers (no persistence)
- <Client.Var client:load py="persist_stream" ts="persistStream" /> - Both persist and
  stream (default)

For example, to open a writer that only persists data:

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
writer = client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
    mode="persist",
)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
  mode: "persist",
});
```

  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Writing Data

The `write` method accepts several argument formats. Use the one that best fits your use
case.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
# Write a single sample for a channel
writer.write("temperature", 25.5)

# Write multiple samples for a channel
writer.write("temperature", [25.5, 26.0, 26.5])

# Write a single sample for several channels
writer.write({
    "time": sy.TimeStamp.now(),
    "temperature": 25.5,
})

# Write multiple samples using lists or numpy arrays
import numpy as np

start = sy.TimeStamp.now()
writer.write({
    "time": [start, start + sy.TimeSpan.SECOND],
    "temperature": np.array([25.5, 26.0], dtype=np.float32),
})

# Write using a list of channels and corresponding series
writer.write(
    ["time", "temperature"],
    [timestamps, temperatures],
)

# Write a pandas DataFrame
import pandas as pd

df = pd.DataFrame({
    "time": [sy.TimeStamp.now(), sy.TimeStamp.now() + sy.TimeSpan.SECOND],
    "temperature": [25.5, 26.0],
})
writer.write(df)

# Write a Synnax Frame
frame = sy.Frame({ "time": timestamps, "temperature": temperatures })
writer.write(frame)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
import { Frame, Series, TimeSpan, TimeStamp } from "@synnaxlabs/client";

// Write a single sample for a channel
await writer.write("temperature", 25.5);

// Write multiple samples for a channel
await writer.write("temperature", [25.5, 26.0, 26.5]);

// Write a single sample for several channels
await writer.write({
  time: TimeStamp.now(),
  temperature: 25.5,
});

// Write multiple samples using arrays
const start = TimeStamp.now();
await writer.write({
  time: [start, start.add(TimeSpan.seconds(1))],
  temperature: [25.5, 26.0],
});

// Write using a list of channels and corresponding series
await writer.write(["time", "temperature"], [timestamps, temperatures]);

// Write a Frame with typed arrays (high-performance)
const now = TimeStamp.now();
await writer.write(
  new Frame({
    [timeChannel.key]: new Series({
      data: new BigInt64Array([now.valueOf(), now.add(TimeSpan.seconds(1)).valueOf()]),
    }),
    [tempChannel.key]: new Series({
      data: new Float32Array([25.5, 26.0]),
    }),
  }),
);
```

  <div style={{ margin: "4rem 0" }}>

  </div>

  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Closing a Writer

After you're done writing, it's essential to close the writer to release network
connections and other resources. If a writer is not closed, other writers may not be
able to write to the same channels.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
writer.close()
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
await writer.close();
```

  </Fragment>
</Client.Tabs>

Using structured cleanup patterns ensures the writer is always closed, even if an
exception is thrown.

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
# Python's context manager is the recommended approach
with client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
) as writer:
    # Write data here

# Alternatively, use a try/finally block
writer = client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
)
try:
    # Write data here
finally:
    writer.close()
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
});

try {
  for (let i = 0; i < 100; i++)
    await writer.write({ time: TimeStamp.now(), temperature: i * 0.1 });
  await writer.commit();
} finally {
  await writer.close();
}
```

  <div style={{ margin: "18rem 0" }}>

  </div>

  </Fragment>
</Client.Tabs>

<Divider.Divider x />

## Common Pitfalls

There are several common pitfalls to avoid when writing data to Synnax. These can lead
to performance degradation and/or control issues.

### Using Many Individual Write Calls Instead of a Writer

When writing large volumes of data in a streaming fashion (or in batches), use a writer
instead of making individual write calls to a channel. Calls to `write` on a channel use
an entirely new transaction for each call - constantly creating, committing, and closing
transactions has a dramatic impact on performance.

<span style={{ color: "red" }}>**Don't do this**</span> - writing directly to channels
in a loop:

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
time = client.channels.retrieve("time")
temperature = client.channels.retrieve("temperature")
for i in range(100):
    ts = sy.TimeStamp.now()
    time.write(ts, ts)
    temperature.write(ts, i * 0.1)
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const time = await client.channels.retrieve("time");
const temperature = await client.channels.retrieve("temperature");
for (let i = 0; i < 100; i++) {
  const ts = TimeStamp.now();
  await time.write(ts, ts);
  await temperature.write(ts, i * 0.1);
}
```

  </Fragment>
</Client.Tabs>

<span style={{ color: "red" }}>**Also don't do this**</span> - opening and closing a
writer for every write:

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
for i in range(100):
    with client.open_writer(
        start=sy.TimeStamp.now(),
        channels=["time", "temperature"],
    ) as writer:
        writer.write({
            "time": sy.TimeStamp.now(),
            "temperature": i * 0.1,
        })
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
for (let i = 0; i < 100; i++) {
  const writer = await client.openWriter({
    start: TimeStamp.now(),
    channels: ["time", "temperature"],
  });
  await writer.write({
    time: TimeStamp.now(),
    temperature: i * 0.1,
  });
  await writer.close();
}
```

  </Fragment>
</Client.Tabs>

<span style={{ color: "green" }}>**Do this instead**</span> - repeatedly call `write` on
a single writer:

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
with client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
) as writer:
    for i in range(100):
        writer.write({
            "time": sy.TimeStamp.now(),
            "temperature": i * 0.1,
        })
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
});
try {
  for (let i = 0; i < 100; i++)
    await writer.write({
      time: TimeStamp.now(),
      temperature: i * 0.1,
    });
} finally {
  await writer.close();
}
```

  </Fragment>
</Client.Tabs>

### Calling Commit on Every Write

If you've disabled auto-commit, call `commit` periodically to persist data. However,
calling `commit` on every write is a bad idea because it requires a round-trip to the
cluster. This can be very slow when writing large volumes of data. Instead, commit every
few seconds or use auto-commit (which is enabled by default).

<span style={{ color: "red" }}>**Don't do this**</span> - committing on every write:

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
with client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
) as writer:
    for i in range(100):
        writer.write({
            "time": sy.TimeStamp.now(),
            "temperature": i * 0.1,
        })
        writer.commit()
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
});
try {
  for (let i = 0; i < 100; i++) {
    await writer.write({
      time: TimeStamp.now(),
      temperature: i * 0.1,
    });
    await writer.commit();
  }
} finally {
  await writer.close();
}
```

  </Fragment>
</Client.Tabs>

<span style={{ color: "green" }}>**Do this instead**</span> - use auto-commit (enabled
by default):

<Client.Tabs client:load exclude={["cpp","console"]}>

  <Fragment slot="python">

```python
with client.open_writer(
    start=sy.TimeStamp.now(),
    channels=["time", "temperature"],
    # enable_auto_commit=True is the default
) as writer:
    for i in range(100):
        writer.write({
            "time": sy.TimeStamp.now(),
            "temperature": i * 0.1,
        })
```

  </Fragment>

  <Fragment slot="typescript">

```typescript
const writer = await client.openWriter({
  start: TimeStamp.now(),
  channels: ["time", "temperature"],
  // enableAutoCommit: true is the default
});
try {
  for (let i = 0; i < 100; i++)
    await writer.write({
      time: TimeStamp.now(),
      temperature: i * 0.1,
    });
} finally {
  await writer.close();
}
```

  </Fragment>
</Client.Tabs>
