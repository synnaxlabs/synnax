---
layout: "@/layouts/Reference.astro"
title: "Sequence Recipes"
---

import { Divider } from "@synnaxlabs/pluto";
import { Image } from "@/components/Media";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

This page documents a number of common patterns we've found useful when writing control
sequences.

<Divider.Divider direction="x" />

## Checking if a Channel Has Received Telemetry

Synnax's sequences operate in a separate environment than any data acquisition/output
that may feed data to them. This means that sequences are not guaranteed to have a
defined value for every channel requested in the "Read From" field of the sequence.

For example, imagine we're writing a control sequence that reads a set of analog
inputs from a National Instruments (NI) device that represent pressure values, and
writing to a set of digital outputs on another NI device that control a valve.

In this setup, we'll create an [NI Analog Read Task]() that samples the pressure
channels at 100Hz, then e'll create an [NI Digital Write Task]() to write to the
outputs of the device. We won't start any of them, so we're not acquiring data
or controlling outputs yet.

Finally, we'll create a control sequence that runs at 10Hz with the following code:

```lua
if analog_input_1 > 50 then
    set("digital_output_1", true)
else
    set("digital_output_1", false)
end
```

We'll set the sequence rate to 10Hz, hit the play button, and see that it immediately
crashes with the following error:

```

```

Why isn't `analog_input_1` defined if we specified it in the list of channels to read
from? This is because our analog data acquisition task is not running, so we're not
supplying any fresh values for the sequence to pull from. To fix this, we should add
the following check at the top of our sequence code:

```lua
-- Return early and don't make any control decisions
-- if we don't have incoming telemetry.
if analog_input_1 == nil then
    return
end

if analog_input_1 > 50 then
    set("digital_output_1", true)
else
    set("digital_output_1", false)
end
```

Now we can start our sequence just fine, and as soon as we start our analog read and
digital write tasks, the sequence will receive fresh values and start executing the
conditional block wih valid pressure values.

We recommend **always** checking if a channel value is defined before using it, as
it will prevent any unexpected issues from arising.

<Divider.Divider direction="x" />

## Initializing Variables one Time

In some cases, it's useful to initialize one or more variables a single time during
the first loop in a sequence. This is particularly relevant for building [State
Machines]() as we'll discuss in the next section. To do this, we can use the
built-in `iteration` variable along with a conditional check surrounding the block
where we define our first variables:

```lua
if iteration == 1 then
    state = "pressurizing"
end

-- Rest of sequence logic
```

Now, `state` will only be set to its initial value once during the first iteration
of the sequence.

<Divider.Divider direction="x" />

## Fixed Delays Between Commands

<Divider.Divider direction="x" />

## State Machines

State machines are one of the most powerful patterns we can use in our control
sequences, as they can allow us to separate distinct control phases into isolated
blocks of logic. In this recipe, we'll build a simple sequence that pressurizes a tank,
holds pressure for a few seconds, and then vents the tank:

```lua
-- Set the initial state of the sequence to "pressurizing"
if iteration == 1 then
    state = "pressurizing"
end

-- Make sure we're receiving pressure values
if tank_pressure == nil then
    return
end

if state == "pressurizing" then
    -- If we're not at our target pressure, then
    -- open the press valve and close the vent valve
    if tank_pressure < 50 then
        set("press_vlv_cmd", true)
        set("vent_vlv_cmd", false)
    -- If we've hit our target pressure, move into the holding
    -- state and mark the time at which we started holding.
    else
        state = "holding"
        -- store the elapsed time at which we entered a hold
        -- state so we can hold for a fixed amount of time
        hold_start = elapsed_time
    end
else if state == "holding" then
    -- If 5 seconds or more have elapsed, move into the vent
    -- state
    if elapsed_time - hold_start > 5 then
        state = "venting"
    end
else if state == "venting" then
    -- If we're still below ambient, then open the vent
    -- valve and close the press valve.
    if tank_pressure > 3 then
        set("press_vlv_cmd", false)
        set("vent_vlv_cmd", true)
    end
end
```

Building state machines within the Synnax control sequence editor fundamentally
involves defining an initial state, and then using a chain of conditional logic in
order to execute specific control code within the state, and then transition to a
different phase by assigning to the `state` variable when ready.

<Divider.Divider direction="x" />

## Abort Sequence
