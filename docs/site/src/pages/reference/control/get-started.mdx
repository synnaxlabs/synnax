---
layout: "@/layouts/Reference.astro"
title: "Control Sequences"
description: "Get started with control sequences in Synnax."
nextURL: "/reference/control/control-authority"
next: "Control Authority"
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { Image, Video } from "@/components/Media";
import { mdxOverrides } from "@/components/mdxOverrides";
import Diagram from "@/components/Diagram.astro";
import Table from "@/components/Table.astro";
export const components = mdxOverrides;

Control sequences are the primary means for automating hardware operations in your
Synnax deployment. They provide a systematic way to control actuators and other
mechanisms. On this page, we'll explore the different types of control sequences
available within Synnax.

<Divider.Divider x />

## Control Sequence Types

There are two primary ways to write control sequences in Synnax:

**[Arc](/reference/control/arc/introduction)** is Synnax's automation language for
hardware control. Arc is reactive, meaning you declare what should happen when data
changes rather than writing polling loops. It offers both a visual Graph Mode and a Text
Mode, runs directly on [drivers](/reference/driver/get-started) (including
[NI Linux Real-Time](/reference/driver/installation?platform=ni-linux-rt)), and is
performant enough for real-time control applications. Arc automations can be edited and
deployed directly from within the [Synnax Console](/reference/console/get-started).

**[Python client](/reference/python-client/get-started)** gives you the flexibility to
write whatever software you need, with access to the entire Python ecosystem. Python
sequences run externally and communicate with Synnax over the network, which introduces
latency and makes control loop timing less predictable. Use Python for automations where
you need maximum flexibility, and Arc for automations where you need consistent,
low-latency control.

<Note.Note variant="warning">
  The [Embedded Sequence Editor](/reference/control/embedded/get-started) (Lua-based) is
  deprecated. New automations should use Arc instead.
</Note.Note>

<Divider.Divider x />

## How Control Sequences Work

Control sequences [stream data](/reference/concepts/streams) from a set of input
channels, perform some computation, and [write data](/reference/concepts/writes) to a
set of output channels.

Arc uses a reactive model where you declare what should happen when data changes. When a
channel updates, Arc automatically runs the relevant computations:

```arc
// Open the valve when pressure is below threshold, close it otherwise
func bang_bang{threshold f64}(pressure f64) u8 {
    if pressure < threshold { return 1 }
    return 0
}

pressure -> bang_bang{threshold=100.0} -> press_vlv_cmd
```

There is no mention of hardware configuration in this sequence. Parameters like
acquisition rates, scaling, and other hardware specific details are kept independent
from sequencing mechanisms. This allows for a high degree of flexibility, including the
ability to move and change hardware without changing the control sequence algorithms.

### Example Deployment

To illustrate how control sequences fit into a larger system, here's an example Synnax
deployment that communicates with National Instruments devices:

<Diagram>
  <Image
    client:only="react"
    id="control/sequence-structure-v2"
    themed={false}
    extension="svg"
  />
</Diagram>

{/* prettier-ignore */}
<Table>
  <thead>
    <tr>
      <th style={{width: "160px"}}>Component</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[NI Analog Read Task](/reference/driver/ni/analog-read-task)</td>
      <td>Reads data from the analog input ports of an
        [NI-9205](https://www.ni.com/en-us/shop/model/ni-9205.html) at a fixed sample
        rate. Scaling and calibration information is configured within this task. The
        task pushes scaled values to the Synnax Core for consumption by the control
        sequence and Console for visualization.</td>
    </tr>
    <tr>
      <td>[NI Digital Write Task](/reference/driver/ni/digital-write-task)</td>
      <td>Writes to the digital output ports of a
        [NI-9375](https://www.ni.com/en-us/shop/model/ni-9375.html) based on commands
        sent to the `di_X_cmd` channels by the control sequence. The task also
        communicates the state of the digital outputs to the control sequence via the
        `di_X_state` channels.</td>
    </tr>
    <tr>
      <td>[Synnax Core](/reference/core/quick-start)</td>
      <td>Stores and streams all incoming and outgoing data from the NI devices, control
        sequences, and Synnax Console. All data will pass through the Core to travel
        from one component to another.</td>
    </tr>
    <tr>
      <td>[Synnax Console](/reference/console/get-started)</td>
      <td>Displays real-time sensor values and actuator states on [line
        plots](/reference/console/line-plots).</td>
    </tr>
    <tr>
      <td>[Control Sequence](/reference/control/get-started)</td>
      <td>Reads the sensor values from the Analog Read Task and writes commands to the
        Digital Write Task.</td>
    </tr>
  </tbody>
</Table>
