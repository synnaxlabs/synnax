---
layout: "@/layouts/Reference.astro"
title: "Sensor Averaging"
description: "Smooth noisy sensor data with rolling averages and statistics in Arc"
prev: "Unit Conversions"
prevURL: "/reference/control/arc/how-to/unit-conversions"
next: "Derived Calculations"
nextURL: "/reference/control/arc/how-to/derived-calculations"
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { mdxOverrides } from "@/components/mdxOverrides";

export const components = mdxOverrides;

Sensor data is often noisy. A pressure reading might fluctuate by several PSI even when
the actual pressure is stable. Averaging reduces this noise, giving you a more accurate
picture of the true value.

<Divider.Divider x />

## Running Average

The simplest approach tracks a running average using stateful variables:

```arc
func running_avg(value f64) f64 {
    total $= 0.0
    count $= 0
    total = total + value
    count = count + 1
    return total / f64(count)
}

tank_pressure -> running_avg{} -> pressure_avg
```

This averages all values since the function started. The average stabilizes as more
samples accumulate, but it responds slowly to actual changes in the signal.

<Divider.Divider x />

## Moving Average (Sample Window)

A moving average considers only the last N samples, making it more responsive to
changes:

```arc
func moving_avg{window i64} (value f64) f64 {
    // Track recent values and position
    buffer series f64 $= []

    // Add new value
    buffer = buffer + [value]

    // Trim to window size
    if len(buffer) > window {
        buffer = buffer[1:len(buffer)]
    }

    // Calculate average
    total := 0.0
    i := 0
    // Note: Arc doesn't have loops, so we use series operations
    return (buffer[0] + buffer[len(buffer)-1]) / 2.0  // Simplified
}
```

<Note.Note variant="warning">
  The example above is simplified. Arc doesn't have loops, so implementing a true moving
  average with arbitrary window size requires using series element-wise operations. For
  production use, consider using built-in statistical nodes if available, or keep the
  window small enough to compute explicitly.
</Note.Note>

<Divider.Divider x />

## Exponential Moving Average

An exponential moving average (EMA) weights recent values more heavily. It's efficient
because it only needs to track one value:

```arc
func ema{alpha f64} (value f64) f64 {
    avg $= 0.0
    first $= 1

    if first {
        avg = value
        first = 0
    } else {
        avg = alpha * value + (1.0 - alpha) * avg
    }

    return avg
}

// alpha = 0.1 for heavy smoothing, 0.5 for moderate, 0.9 for light
tank_pressure -> ema{alpha=0.2} -> pressure_smooth
```

The `alpha` parameter controls responsiveness:

- `alpha` close to 0: Heavy smoothing, slow response
- `alpha` close to 1: Light smoothing, fast response

<Divider.Divider x />

## Tracking Min and Max

Track the minimum and maximum values seen:

```arc
func track_max(value f64) f64 {
    max_val $= -999999.0
    if value > max_val {
        max_val = value
    }
    return max_val
}

func track_min(value f64) f64 {
    min_val $= 999999.0
    if value < min_val {
        min_val = value
    }
    return min_val
}

tank_pressure -> track_max{} -> pressure_max
tank_pressure -> track_min{} -> pressure_min
```

<Divider.Divider x />

## Combining Statistics

Track multiple statistics with separate flows:

```arc
func running_stats(value f64) f64 {
    total $= 0.0
    n $= 0
    total = total + value
    n = n + 1
    return total / f64(n)
}

// Run separate flows for each statistic
tank_pressure -> running_stats{} -> pressure_avg
tank_pressure -> track_max{} -> pressure_max
tank_pressure -> track_min{} -> pressure_min
```

<Divider.Divider x />

## Resettable Statistics

In test sequences, you often want to reset statistics at specific points. Use a separate
reset channel:

```arc
func resettable_avg{
    reset chan u8
} (value f64) f64 {
    total $= 0.0
    count $= 0

    // Check for reset signal
    if reset {
        total = 0.0
        count = 0
    }

    total = total + value
    count = count + 1
    return total / f64(count)
}

tank_pressure -> resettable_avg{reset=stats_reset} -> pressure_avg
```

Wire a button or stage transition to the `stats_reset` channel to clear the accumulated
values.

<Divider.Divider x />

## Averaging Multiple Sensors

Combine readings from redundant sensors:

```arc
func avg_sensors{
    sensor_a chan f64,
    sensor_b chan f64
} () f64 {
    a := sensor_a
    b := sensor_b
    return (a + b) / 2.0
}

// Run on an interval rather than sensor updates
interval{period=50ms} -> avg_sensors{sensor_a=pressure_1, sensor_b=pressure_2} -> pressure_avg
```

Using `interval` ensures the average is calculated at a fixed rate regardless of when
individual sensor updates arrive.

<Divider.Divider x />

## Median Filter (Three Sensors)

For three redundant sensors, a median filter rejects outliers:

```arc
func median3{
    a chan f64,
    b chan f64,
    c chan f64
} () f64 {
    va := a
    vb := b
    vc := c

    // Find median of three values
    if (va >= vb and va <= vc) or (va >= vc and va <= vb) {
        return va
    }
    if (vb >= va and vb <= vc) or (vb >= vc and vb <= va) {
        return vb
    }
    return vc
}

interval{period=50ms} -> median3{a=pressure_1, b=pressure_2, c=pressure_3} -> pressure_voted
```

The median rejects a single faulty sensor reading, making it useful for safety-critical
measurements.
