---
layout: "@/layouts/Reference.astro"
title: "Sensor Validation"
description: "Check sensor readings for validity before using them in control logic"
prev: "Rate of Change"
prevURL: "/reference/control/arc/how-to/rate-of-change"
next: "Alarms"
nextURL: "/reference/control/arc/how-to/alarms"
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { mdxOverrides } from "@/components/mdxOverrides";

export const components = mdxOverrides;

Bad sensor data can cause control systems to make bad decisions. A disconnected
thermocouple might read -200Â°C, causing a heater to run at full power. A failed pressure
transducer might show 0 PSI, triggering a false leak alarm. Validating sensor readings
before using them catches these failures.

<Divider.Divider x />

## Range Checking

Reject readings outside the sensor's valid range:

```arc
func range_check{
    min f64,
    max f64
} (value f64) (valid f64, in_range u8) {
    if value < min or value > max {
        valid = min     // return minimum as safe default
        in_range = 0
    } else {
        valid = value
        in_range = 1
    }
}

// Use the validated output for control logic
tank_pressure -> range_check{min=0.0, max=1000.0} -> pressure_validated
```

Downstream control logic uses `pressure_validated` instead of the raw reading.

<Divider.Divider x />

## Thermocouple Validation

Thermocouples have specific failure modes. Open circuits often read very negative or
very positive values:

```arc
func tc_validate{
    min_temp f64,      // lowest expected temperature
    max_temp f64,      // highest expected temperature
    open_low f64,      // open circuit reads below this
    open_high f64      // open circuit reads above this
} (raw f64) (temp f64, valid u8, open_circuit u8) {
    // Check for open circuit (disconnected TC)
    if raw < open_low or raw > open_high {
        temp = min_temp    // safe default
        valid = 0
        open_circuit = 1
        return
    }

    // Check for in-range reading
    if raw < min_temp or raw > max_temp {
        temp = raw         // pass through, but mark invalid
        valid = 0
        open_circuit = 0
        return
    }

    temp = raw
    valid = 1
    open_circuit = 0
}

// Simplified: output validated temperature only
func tc_validate_simple{
    min_temp f64,
    max_temp f64,
    open_low f64,
    open_high f64
} (raw f64) f64 {
    // Return min_temp as safe default on failure
    if raw < open_low or raw > open_high {
        return min_temp
    }
    return raw
}

tank_temp_raw -> tc_validate_simple{
    min_temp=-50.0,
    max_temp=500.0,
    open_low=-200.0,
    open_high=1500.0
} -> tank_temp
```

<Divider.Divider x />

## Stuck Sensor Detection

A sensor that never changes might be stuck or have a wiring fault:

```arc
func stuck_detector{
    threshold f64,     // minimum change to consider "not stuck"
    max_stuck i64      // samples before declaring stuck
} (value f64) (stuck u8) {
    prev $= 0.0
    stuck_count $= 0
    first $= 1

    if first {
        prev = value
        first = 0
        stuck = 0
        return
    }

    delta := value - prev
    if delta < 0 {
        delta = 0.0 - delta   // absolute value
    }

    if delta < threshold {
        stuck_count = stuck_count + 1
    } else {
        stuck_count = 0
    }

    prev = value

    if stuck_count > max_stuck {
        stuck = 1
    } else {
        stuck = 0
    }
}

tank_pressure -> stuck_detector{threshold=0.1, max_stuck=100} -> sensor_stuck
```

<Note.Note variant="info">
  Set `threshold` based on expected sensor noise. A perfectly stable reading might
  indicate a failed sensor, but some sensors legitimately hold steady values.
</Note.Note>

<Divider.Divider x />

## Rate-of-Change Validation

Sudden jumps often indicate sensor faults rather than real changes:

```arc
func spike_filter{
    max_delta f64      // maximum allowed change per sample
} (value f64) (filtered f64, spike u8) {
    prev $= 0.0
    first $= 1

    if first {
        prev = value
        first = 0
        filtered = value
        spike = 0
        return
    }

    delta := value - prev

    // Check magnitude
    abs_delta := delta
    if abs_delta < 0 {
        abs_delta = 0.0 - abs_delta
    }

    if abs_delta > max_delta {
        // Spike detected - hold previous value
        filtered = prev
        spike = 1
    } else {
        // Normal reading
        filtered = value
        prev = value
        spike = 0
    }
}

// Output filtered value only; check spike separately if needed
func spike_filter_simple{max_delta f64} (value f64) f64 {
    prev $= 0.0
    first $= 1

    if first {
        prev = value
        first = 0
        return value
    }

    delta := value - prev
    abs_delta := delta
    if abs_delta < 0 {
        abs_delta = 0.0 - abs_delta
    }

    if abs_delta > max_delta {
        return prev  // hold previous on spike
    }

    prev = value
    return value
}

tank_pressure -> spike_filter_simple{max_delta=50.0} -> pressure_filtered
```

<Divider.Divider x />

## Redundant Sensor Voting

With multiple sensors measuring the same thing, use voting to reject outliers:

```arc
func vote_three{
    a chan f64,
    b chan f64,
    c chan f64,
    tolerance f64      // max deviation from median
} () (value f64, all_agree u8, outlier_count i64) {
    va := a
    vb := b
    vc := c

    // Find median
    med := va
    if (vb >= va and vb <= vc) or (vb >= vc and vb <= va) {
        med = vb
    } else if (vc >= va and vc <= vb) or (vc >= vb and vc <= va) {
        med = vc
    }

    // Count outliers
    outliers := 0

    diff_a := va - med
    if diff_a < 0 {
        diff_a = 0.0 - diff_a
    }
    if diff_a > tolerance {
        outliers = outliers + 1
    }

    diff_b := vb - med
    if diff_b < 0 {
        diff_b = 0.0 - diff_b
    }
    if diff_b > tolerance {
        outliers = outliers + 1
    }

    diff_c := vc - med
    if diff_c < 0 {
        diff_c = 0.0 - diff_c
    }
    if diff_c > tolerance {
        outliers = outliers + 1
    }

    value = med
    outlier_count = outliers

    if outliers == 0 {
        all_agree = 1
    } else {
        all_agree = 0
    }
}

// Simplified voting that returns median only
func vote_median{
    a chan f64,
    b chan f64,
    c chan f64
} () f64 {
    va := a
    vb := b
    vc := c

    // Find median
    if (vb >= va and vb <= vc) or (vb >= vc and vb <= va) {
        return vb
    }
    if (vc >= va and vc <= vb) or (vc >= vb and vc <= va) {
        return vc
    }
    return va
}

interval{period=50ms} -> vote_median{
    a=pressure_1,
    b=pressure_2,
    c=pressure_3
} -> pressure_voted
```

<Divider.Divider x />

## Combined Validation Pipeline

Chain multiple validation checks:

```arc
func validate_pt{
    min f64,
    max f64,
    max_rate f64,
    dt_ms f64
} (raw f64) (value f64, valid u8, reason i64) {
    prev $= 0.0
    first $= 1

    // Reason codes: 0=ok, 1=out of range, 2=rate exceeded
    reason = 0

    // Range check
    if raw < min or raw > max {
        value = prev
        valid = 0
        reason = 1
        return
    }

    // Rate check (skip on first sample)
    if first {
        first = 0
        prev = raw
        value = raw
        valid = 1
        return
    }

    delta := raw - prev
    if delta < 0 {
        delta = 0.0 - delta
    }

    dt_s := dt_ms / 1000.0
    rate := delta / dt_s

    if rate > max_rate {
        value = prev
        valid = 0
        reason = 2
        return
    }

    // All checks passed
    prev = raw
    value = raw
    valid = 1
}

// Simplified: output validated value only
func validate_pt_simple{
    min f64,
    max f64,
    max_rate f64,
    dt_ms f64
} (raw f64) f64 {
    prev $= 0.0
    first $= 1

    // Range check
    if raw < min or raw > max {
        return prev
    }

    if first {
        first = 0
        prev = raw
        return raw
    }

    // Rate check
    delta := raw - prev
    if delta < 0 { delta = 0.0 - delta }
    dt_s := dt_ms / 1000.0
    rate := delta / dt_s

    if rate > max_rate {
        return prev
    }

    prev = raw
    return raw
}

pressure_raw -> validate_pt_simple{
    min=0.0,
    max=1000.0,
    max_rate=500.0,
    dt_ms=50.0
} -> tank_pressure
```

<Divider.Divider x />

## Using Validation in Sequences

Only proceed when sensor data is valid:

```arc
func in_range{min f64, max f64}(value f64) u8 {
    if value >= min and value <= max {
        return 1
    }
    return 0
}

sequence main {
    stage verify_sensors {
        // Check all critical sensors are in valid range
        inlet_pressure -> in_range{min=0.0, max=1000.0} -> inlet_valid,
        outlet_pressure -> in_range{min=0.0, max=1000.0} -> outlet_valid,

        // All sensors must be valid to proceed
        inlet_valid and outlet_valid => next,

        // Alert if sensors fail
        not inlet_valid => sensor_fault,
        not outlet_valid => sensor_fault
    }

    stage pressurize {
        // Safe to proceed with validated data
        // ...
    }

    stage sensor_fault {
        // Handle sensor failure
        0 -> valve_cmd
    }
}
```

<Note.Note variant="warning">
  Always use validated sensor values in control logic. Raw sensor inputs should go
  through validation before being used for decisions or fed to actuators.
</Note.Note>
