---
layout: "@/layouts/Reference.astro"
title: "Calculated Channels"
description: "Process live telemetry with calculated channels."
prev: "Channels"
prevURL: "/reference/console/channels"
next: "Workspaces"
nextURL: "/reference/console/workspaces"
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { Video, Image } from "@/components/Media";
import Diagram from "@/components/Diagram.astro";
import Table from "@/components/Table.astro";
import Code from "@/components/code/Code.astro";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

Calculated channels derive real-time data from existing
[channels](/reference/console/channels). They enable live data processing and analysis,
such as:

- Scaling, converting or filtering raw data
- Implementing sensor voting algorithms
- Creating channels to conditionally trigger alarms or warnings.

<Note.Note variant="warning">
  **Calculated channels now use the Arc language.** Existing Lua-based channels will
  continue to work but should be [migrated to Arc](#migration-from-lua).
</Note.Note>

{/* [SCREENSHOT NEEDED] Console showing legacy channel deprecation warning */}

<Divider.Divider x />

## Creating Calculated Channels

To create a calculated channel, open the Search and Command Palette and run the "Create
Calculated Channel" command.

- Click the search bar at the top and type `>` to open the palette.
- Alternatively, press `Ctrl+Shift+P` (Windows) / `Cmd+Shift+P` (macOS).

<Video client:only="react" id="console/calculated-channels/create" />

{/* [SCREENSHOT NEEDED] Calculated channel creation dialog with Arc editor */}
{/* [SCREENSHOT NEEDED] Arc code editor showing syntax highlighting */}

### Channel Parameters

When creating a calculated channel, you will be prompted to fill in the following
fields:

<Table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Name</td>
      <td>A name for the channel.</td>
    </tr>
    <tr>
      <td>Expression</td>
      {
        <td>
          The Arc expression that calculates the value to be written to the calculated
          channel. This expression must end with a <code>return</code> statement.
          Channel dependencies are automatically detected from the expression.
        </td>
      }
    </tr>
    <tr>
      <td>Operation (Optional)</td>
      {
        <td>
          Post-processing operation applied to the expression result. Options include{" "}
          <code>min</code>, <code>max</code>, and <code>avg</code> for{" "}
          <a href="#operations">running aggregations</a>.
        </td>
      }
    </tr>
    <tr>
      <td>Window (Optional)</td>
      {
        <td>
          Time duration for operation resets. When the duration expires, the operation
          state is reset. Set to 0 for no duration-based reset. Only applies when an
          operation is selected.
        </td>
      }
    </tr>
    <tr>
      <td>Reset Channel (Optional)</td>
      {
        <td>
          A <code>uint8</code>{" "}
          <a href="#reset-channels">channel that triggers operation reset</a> when its
          value equals 1. Only applies when an operation is selected.
        </td>
      }
    </tr>
  </tbody>
</Table>

<Divider.Divider x />

## Writing Expressions

Calculated channels use the [Arc](https://docs.synnax.com/reference/arc) language for
expressions. Arc is a domain-specific language designed for real-time telemetry
processing.

### Basic Syntax

#### Channel References

Reference channels directly by name without any prefix or special syntax:

```arc
return temperature
return sensor_a + sensor_b
return voltage * current
```

Channel names are automatically detected and used as inputs to the calculation.

#### Return Statement

Every expression must end with a `return` statement:

```arc
return pressure * 1.5
```

#### Variables

Use `:=` to declare intermediate variables:

```arc
scaled := pressure * 2.5
offset := scaled + 10
return offset
```

### Operators

Arc supports standard operators for calculations:

**Arithmetic:** `+`, `-`, `*`, `/`, `%`

```arc
return (temp_1 + temp_2 + temp_3) / 3  // Average
```

**Comparison:** `==`, `!=`, `<`, `>`, <code
style={{fontVariantLigatures: 'none'}}>&lt;=</code>, <code
style={{fontVariantLigatures: 'none'}}>&gt;=</code>

```arc
return pressure > 100  // Returns 1 (true) or 0 (false)
```

**Logical:** `and`, `or`, `not`

```arc
return temp > 100 and pressure > 50
```

### Conditionals

Use `if` statements with curly braces for conditional logic:

```arc
if (temperature > 100) {
    return 1
} else {
    return 0
}
```

Multi-condition example:

```arc
if (temp > 100 and pressure > 50) {
    return 2
} else if (temp > 50) {
    return 1
} else {
    return 0
}
```

### Data Types

The calculated channel's data type is automatically inferred from the Arc expression's
return value. The system analyzes your expression to determine the appropriate data type
(e.g., `float64`, `int32`, etc.).

<Divider.Divider x />

## Editing Calculations

To edit a calculated channel, right-click it in the Channels Toolbar and select "Edit
Calculation" from the context menu:

<Video client:only="react" id="console/calculated-channels/edit" />

<Divider.Divider x />

## Operations

Operations are optional post-processing steps that apply aggregations to your calculated
channel. They enable stateful computations like running minimums, maximums, and
averages.

### How Operations Work

Operations process the expression result before writing to the output channel:

<Code showCopyButton={false}>
  <code>
    {`Expression Result → Operation → Output Channel
                       ↑
                  Reset Channel`}
  </code>
</Code>

The operation maintains internal state across executions, outputting a single aggregated
value rather than processing individual samples.

{/* [SCREENSHOT NEEDED] Operation configuration UI (type/window/reset channel) */}

### Supported Operations

<Table>
  <thead>
    <tr>
      <th>Operation</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`none`</td>
      <td>No operation (default). Passes expression result directly to output.</td>
    </tr>
    <tr>
      <td>`min`</td>
      <td>Running minimum. Tracks the smallest value seen since the last reset.</td>
    </tr>
    <tr>
      <td>`max`</td>
      <td>Running maximum. Tracks the largest value seen since the last reset.</td>
    </tr>
    <tr>
      <td>`avg`</td>
      <td>Running average. Computes the mean of all values since the last reset.</td>
    </tr>
  </tbody>
</Table>

### Reset Mechanisms

Operations can reset their state through three mechanisms (any can trigger a reset):

1. **Duration-based (Window)**: Resets after a specified time duration based on input
   timestamps
2. **Signal-based (Reset Channel)**: Resets when a `uint8` channel receives value `1`
3. **Never**: Set duration to 0 and omit reset channel for a continuous operation

### Example Configurations

**Running average over 10 seconds:**

- Operation: `avg`
- Window: `10` seconds
- Reset Channel: (none)

The average resets every 10 seconds based on data timestamps.

**Maximum until manual reset:**

- Operation: `max`
- Window: `0` (no duration reset)
- Reset Channel: `manual_reset_button`

The maximum runs indefinitely until the reset channel triggers.

**Minimum with both reset types:**

- Operation: `min`
- Window: `60` seconds
- Reset Channel: `cycle_complete`

The minimum resets either after 60 seconds OR when the reset channel triggers—whichever
comes first.

<Divider.Divider x />

## Reset Channels

Reset channels provide signal-based control over operation state and must have data type
`uint8`. When a reset channel receives a value of `1`, the associated operation clears
its accumulated state and restarts.

{/* [VIDEO NEEDED] Demonstration of reset channel triggering and operation resetting */}

### Use Cases

**Manual Reset Button:**

Create a virtual `uint8` channel that you can write to from a schematic button or
control panel to manually reset the calculation.

**Periodic Reset Signal:**

Use a timer or sequence to generate periodic reset pulses for regular operation resets.

**Conditional Reset Logic:**

Create a calculated channel that outputs `1` when a certain condition is met (e.g.,
"cycle complete" flag from another system).

### Behavior Example

```
Time:           0s → 5s  → 10s → 10.1s (reset=1) → 15s → 20s
Pressure:       50 → 100 → 75  → 75              → 90  → 110
Max Operation:  50 → 100 → 100 → (reset to 75)   → 90  → 110
```

At 10.1s, the reset channel triggers, clearing the max value. The operation restarts
from the current input (75) and continues tracking the new maximum.

<Divider.Divider x />

## Examples

### Simple Operations

**Scaling a sensor:**

```arc
return pressure * 1.5
```

**Adding an offset:**

```arc
return temperature + 273.15  // Convert Celsius to Kelvin
```

**Power calculation:**

```arc
return voltage * current
```

### Multi-Channel Calculations

**Sum of multiple sensors:**

```arc
return sensor_1 + sensor_2 + sensor_3
```

**Average (in expression):**

```arc
return (temp_1 + temp_2 + temp_3) / 3
```

**Differential measurement:**

```arc
return inlet_pressure - outlet_pressure
```

### Conditional Logic

**Threshold detection:**

```arc
if (pressure > 100) {
    return 1  // High alarm
} else {
    return 0  // Normal
}
```

**Multi-level thresholds:**

```arc
if (temp > 100 and pressure > 50) {
    return 2  // Critical
} else if (temp > 50) {
    return 1  // Warning
} else {
    return 0  // Normal
}
```

**Safe division (avoid divide-by-zero):**

```arc
if (denominator == 0) {
    return 0
} else {
    return numerator / denominator
}
```

### Multi-Step Calculations

**Unit conversion with intermediate variables:**

```arc
celsius := sensor_temp
fahrenheit := celsius * 9 / 5 + 32
return fahrenheit
```

**Pressure compensation:**

```arc
raw_pressure := sensor_reading
temp_correction := temperature * 0.01
compensated := raw_pressure - temp_correction
return compensated
```

### Using Operations

**Running maximum with manual reset:**

- Expression: `return pressure`
- Operation: `max`
- Window: `0` (no duration reset)
- Reset Channel: `reset_button`

This tracks the maximum pressure value until the reset button is triggered.

**10-second rolling average:**

- Expression: `return temperature`
- Operation: `avg`
- Window: `10` seconds
- Reset Channel: (none)

This computes the average temperature over 10-second windows.

<Divider.Divider x />

## How Calculated Channels Work

Calculated channels are [virtual](/reference/concepts/channels#virtual-channels),
meaning their data is computed on-demand rather than stored permanently to disk. This
section explains how they work under the hood.

### On-Demand Computation

Calculated channels don't run continuously in the background. Instead, they only execute
when someone actively reads or streams the channel. When you start visualizing a
calculated channel in a line plot or request its data through the API, Synnax
automatically activates the calculation. When you stop streaming, the calculation
pauses.

This on-demand approach conserves system resources: calculations only consume CPU and
memory when their results are actually needed.

### Historical Evaluation

Calculated channels can be evaluated historically, allowing you to query past data as if
the calculation had been running at that time. For this to work:

- **All input channels** must have data available in the time range you're querying
- **Simple expressions** (like `return pressure * 1.5`) work reliably with historical
  data
- **Operations** (min, max, avg) with time-based windows may have limitations with
  historical queries

**Example:** If your calculation depends on `sensor_1` and `sensor_2`, you can query
historical data for any time range where both sensors have recorded data. The
calculation will be applied to the historical data as if it had been running
continuously.

**Nested calculations** also work historically. If `calc_2` depends on `calc_1`, and
`calc_1` depends on persisted channels, you can query `calc_2` historically as long as
the underlying data exists.

### Nested Calculations

Calculated channels can depend on other calculated channels, creating calculation
chains:

```
sensor_raw → temp_celsius → temp_fahrenheit → temp_status
```

When data arrives at `sensor_raw`, it automatically propagates through the chain:

1. `temp_celsius` calculates and outputs its result
2. `temp_fahrenheit` receives that output and calculates its result
3. `temp_status` receives that output and produces the final result

There's no limit to nesting depth, but keep in mind that each level adds computation
time. Design your calculations thoughtfully to balance clarity and performance.

### Handling Different Arrival Rates

Calculated channels operate on **series (arrays of samples)**, not individual scalar
values. When you write `return temperature + pressure`, you're performing an elementwise
operation on arrays.

When inputs have different numbers of samples, Arc uses **last-value-hold** semantics:

- The output length equals the **maximum** of the input lengths
- Shorter series repeat their last value for remaining positions
- This happens **per frame**, not across time

**Example:** Consider a frame where:

```arc
return temperature + pressure
```

If the frame contains:

- `temperature`: 10 samples `[20, 21, 22, 23, 24, 25, 26, 27, 28, 29]`
- `pressure`: 5 samples `[30, 31, 32, 33, 34]`

The calculation produces **10 output samples**:

1. Pressure's last value (34) repeats for positions 6-10
2. Elementwise addition: `[50, 52, 54, 56, 58, 59, 60, 61, 62, 63]`

**What this means for different rates:**

If `temperature` updates at 100 Hz and `pressure` at 10 Hz, when a frame arrives with
100 temperature samples and 10 pressure samples, the calculated channel produces **100
output samples**. Pressure's 10th value is used for output samples 11-100.

**Note:** This is not interpolation; it's a last-value-hold. The system doesn't create
new pressure values; it reuses the most recent one.

<Divider.Divider x />

## Migration from Lua

If you have existing Lua-based calculated channels, here's how to migrate them to Arc:

{/* [SCREENSHOT NEEDED] Side-by-side Lua vs Arc comparison in Console */}

### Syntax Comparison

<Table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Lua (Legacy)</th>
      <th>Arc (Current)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Channel Access</td>
      <td>`channels.name` or `get("name")`</td>
      <td>`name`</td>
    </tr>
    <tr>
      <td>Variables</td>
      <td>`local x = 5`</td>
      <td>`x := 5`</td>
    </tr>
    <tr>
      <td>Conditionals</td>
      <td>`if x then ... end`</td>
      <td style="font-variant-ligatures: none;">`if (x) { ... }`</td>
    </tr>
    <tr>
      <td>Logical AND</td>
      <td>`and`</td>
      <td>`and`</td>
    </tr>
    <tr>
      <td>Logical OR</td>
      <td>`or`</td>
      <td>`or`</td>
    </tr>
    <tr>
      <td>Logical NOT</td>
      <td>`not`</td>
      <td>`not`</td>
    </tr>
    <tr>
      <td>Not Equal</td>
      <td>`~=`</td>
      <td>`!=`</td>
    </tr>
    <tr>
      <td>Return</td>
      <td>`return value`</td>
      <td>`return value`</td>
    </tr>
  </tbody>
</Table>

### Migration Examples

**Simple scaling:**

```lua
// Lua
return channels.sensor * 2
```

```arc
// Arc
return sensor * 2
```

**Conditional logic:**

```lua
// Lua
if channels.temp > 100 then
    return 1
else
    return 0
end
```

```arc
// Arc
if (temp > 100) {
    return 1
} else {
    return 0
}
```

**Multi-step with variables:**

```lua
// Lua
local scaled = channels.pressure * 2.5
local offset = scaled + 10
return offset
```

```arc
// Arc
scaled := pressure * 2.5
offset := scaled + 10
return offset
```

### Key Differences

1. **No channel prefix needed** - Reference channels by name directly
2. **Curly braces for blocks** - Use `{}` instead of `then...end`
3. **Keyword operators** - Arc uses the same `and`, `or`, `not` keywords as Lua
4. **Auto-detected dependencies** - No need to manually specify `requires` field

### Channel Naming for Arc

**Important**: Arc identifiers can only contain letters, digits, and underscores, and
must start with a letter or underscore. Channel names with special characters (like
dashes, spaces, or dots) **cannot be directly referenced** in Arc expressions.

**Best Practice**: When creating channels that will be used in Arc calculated channels,
use underscores instead of special characters:

- ✅ `sensor_1`, `temp_reading`, `channel_a`
- ❌ `sensor-1`, `temp reading`, `channel.a`

For complex calculations involving loops or tables, consider breaking them into multiple
calculated channels or exploring
[Arc's more advanced features](https://docs.synnax.com/reference/arc).
