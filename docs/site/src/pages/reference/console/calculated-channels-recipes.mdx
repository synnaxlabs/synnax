---
layout: "@/layouts/Reference.astro"
title: "Calculated Channels Recipes"
description: "Common patterns and examples for calculated channels."
prev: "Calculated Channels"
prevURL: "/reference/console/calculated-channels"
next: "Workspaces"
nextURL: "/reference/console/workspaces"
---

import { Divider, Note } from "@synnaxlabs/pluto";
import { Video, Image } from "@/components/Media";
import Table from "@/components/Table.astro";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

This page provides practical recipes for common calculated channel patterns. Each recipe
includes a description, Arc expression, and configuration notes.

For fundamentals, see the
[Calculated Channels](/reference/console/calculated-channels) documentation.

<Divider.Divider x />

## Basic Operations

### Scaling

Multiply a sensor reading by a constant factor:

```arc
return sensor * 2.5
```

 ^ Use case: ^  Converting raw ADC values to engineering units, applying calibration
factors.

### Offset

Add or subtract a constant value:

```arc
return temperature + 273.15
```

 ^ Use case: ^  Converting Celsius to Kelvin, applying zero-point corrections.

### Linear Transformation

Combine scaling and offset:

```arc
scaled := raw_sensor * 0.5
return scaled + 10
```

 ^ Use case: ^  General calibration `y = mx + b` where `m = 0.5` and `b = 10`.

### Inversion

Invert a signal:

```arc
return -1 * signal
```

 ^ Use case: ^  Reversing polarity, converting pressure drop to pressure rise.

<Divider.Divider x />

## Unit Conversions

### Temperature: Celsius to Fahrenheit

```arc
return celsius * 9 / 5 + 32
```

### Temperature: Fahrenheit to Celsius

```arc
return (fahrenheit - 32) * 5 / 9
```

### Pressure: PSI to Pascals

```arc
return psi * 6894.76
```

### Pressure: Bar to PSI

```arc
return bar * 14.5038
```

### Flow: GPM to L/min

```arc
return gpm * 3.78541
```

### Distance: Inches to Meters

```arc
return inches * 0.0254
```

<Divider.Divider x />

## Multi-Channel Operations

### Sum

Add multiple channels together:

```arc
return ch1 + ch2 + ch3
```

 ^ Use case: ^  Total flow from multiple sensors, combined force measurements.

### Average

Compute the mean of multiple channels:

```arc
return (temp_1 + temp_2 + temp_3 + temp_4) / 4
```

 ^ Use case: ^  Average temperature from redundant sensors, sensor voting.

### Differential

Subtract one channel from another:

```arc
return inlet_pressure - outlet_pressure
```

 ^ Use case: ^  Pressure drop across a component, differential measurements.

### Weighted Average

Combine channels with different weights:

```arc
return (sensor_a * 0.5 + sensor_b * 0.3 + sensor_c * 0.2)
```

 ^ Use case: ^  Sensor fusion with confidence weights, blended measurements.

### Ratio

Divide one channel by another:

```arc
if (denominator == 0) {
    return 0
} else {
    return numerator / denominator
}
```

 ^ Use case: ^  Efficiency calculations, mixture ratios.

<Note.Note variant="info">
  Always check for division by zero in ratio calculations to avoid errors.
</Note.Note>

<Divider.Divider x />

## Electrical Calculations

### Power (DC)

```arc
return voltage * current
```

### Resistance (Ohm's Law)

```arc
if (current == 0) {
    return 0
} else {
    return voltage / current
}
```

### Energy (Watt-hours)

Use a running average operation over 3600 seconds:

- Expression: `return power`
- Operation: `avg`
- Window: `3600` seconds

### Three-Phase Power

```arc
return 1.732 * voltage * current * power_factor
```

<Divider.Divider x />

## Thermodynamics & Fluids

### Ideal Gas Law (solving for n)

Given pressure (Pa), volume (m³), temperature (K), and R = 8.314:

```arc
return (pressure * volume) / (8.314 * temperature)
```

### Bernoulli's Principle (velocity)

```arc
pressure_diff := p1 - p2
density := 1000  // kg/m³ for water
return (2 * pressure_diff / density)  ^  0.5
```

**Note:** Arc uses `^` for exponentiation, so `^ 0.5` computes square root.

### Reynolds Number

```arc
density := 1000
velocity := flow_rate / cross_section_area
diameter := 0.05
viscosity := 0.001
return (density * velocity * diameter) / viscosity
```

<Divider.Divider x />

## Conditional Logic

### Threshold Detection

```arc
if (pressure > 100) {
    return 1
} else {
    return 0
}
```

 ^ Use case: ^  Binary alarm when pressure exceeds limit.

### Multi-Level Thresholds

```arc
if (temp > 100) {
    return 3  // Critical
} else if (temp > 75) {
    return 2  // High
} else if (temp > 50) {
    return 1  // Normal
} else {
    return 0  // Low
}
```

 ^ Use case: ^  Traffic light alarms with multiple severity levels.

### Hysteresis (Dead Band)

```arc
if (value > 105) {
    return 1  // Trigger high
} else if (value < 95) {
    return 0  // Trigger low
} else {
    return previous_state  // Maintain state
}
```

 ^ Note: ^  For true hysteresis, use a stateful Arc program or external logic. This
example shows the concept but requires additional implementation.

### Range Checking

```arc
if (value >= min_limit && value <= max_limit) {
    return 1  // In range
} else {
    return 0  // Out of range
}
```

### Clamping (Limiting)

```arc
if (value > max_limit) {
    return max_limit
} else if (value < min_limit) {
    return min_limit
} else {
    return value
}
```

 ^ Use case: ^  Preventing output from exceeding safe operating limits.

<Divider.Divider x />

## Statistical Operations

### Running Maximum

Track the maximum value over time:

- Expression: `return sensor`
- Operation: `max`
- Window: `0` (continuous)
- Reset Channel: `manual_reset`

 ^ Use case: ^  Peak detection, maximum load tracking.

{/* [VIDEO NEEDED] Operations in action showing aggregation over time */}

### Running Minimum

Track the minimum value over time:

- Expression: `return sensor`
- Operation: `min`
- Window: `60` seconds
- Reset Channel: (none)

 ^ Use case: ^  Minimum temperature in last minute, valley detection.

### Rolling Average

Compute average over a time window:

- Expression: `return noisy_sensor`
- Operation: `avg`
- Window: `10` seconds
- Reset Channel: (none)

 ^ Use case: ^  Smoothing noisy signals, trend analysis.

### Peak-to-Peak

Combine two calculated channels:

1. Create `max_channel` with `max` operation
2. Create `min_channel` with `min` operation
3. Create `peak_to_peak` with expression: `return max_channel - min_channel`

 ^ Use case: ^  Signal amplitude measurement, vibration analysis.

<Divider.Divider x />

## Advanced Patterns

### Temperature Compensation

Adjust a sensor reading based on temperature:

```arc
temp_coefficient := 0.02  // 2% per degree
temp_error := (temperature - 25) * temp_coefficient
correction_factor := 1 - temp_error
return raw_sensor * correction_factor
```

 ^ Use case: ^  Compensating for thermal drift in sensors.

### Altitude Pressure Compensation

```arc
sea_level_pressure := 101325  // Pa
altitude := 1000  // meters
temp := 288.15  // Kelvin at sea level
lapse_rate := 0.0065  // K/m
temp_at_altitude := temp - lapse_rate * altitude
pressure := sea_level_pressure * (temp_at_altitude / temp)  ^  5.255
return pressure
```

### Exponential Moving Average (Approximation)

```arc
alpha := 0.1  // Smoothing factor (0-1)
smoothed := alpha * current_value + (1 - alpha) * previous_smoothed
return smoothed
```

 ^ Note: ^  True exponential moving average requires stateful computation. For production
use, consider the built-in `avg` operation.

### State Machine (Simple)

```arc
if (enable == 0) {
    return 0  // Disabled state
} else if (sensor < 50) {
    return 1  // Low state
} else if (sensor < 100) {
    return 2  // Medium state
} else {
    return 3  // High state
}
```

### Sensor Voting (Median of 3)

```arc
// Simple median for 3 sensors
if (s1 >= s2 && s1 <= s3) {
    return s1
} else if (s1 >= s3 && s1 <= s2) {
    return s1
} else if (s2 >= s1 && s2 <= s3) {
    return s2
} else if (s2 >= s3 && s2 <= s1) {
    return s2
} else {
    return s3
}
```

 ^ Note: ^  This assumes `s1`, `s2`, `s3` are three redundant sensors. For more complex
voting algorithms, consider breaking into multiple calculated channels.

### Efficiency Calculation

```arc
if (input_power == 0) {
    return 0
} else {
    efficiency := (output_power / input_power) * 100
    return efficiency
}
```

 ^ Use case: ^  Motor efficiency, heat exchanger effectiveness, system performance.

<Divider.Divider x />

## Reset Channel Patterns

### Manual Reset Button

Create a virtual `uint8` channel called `reset_button`, then use it in a calculated
channel:

- Expression: `return sensor`
- Operation: `max`
- Reset Channel: `reset_button`

Write `1` to `reset_button` from a schematic button to trigger reset.

### Periodic Reset (External Timer)

Create a calculated channel that outputs `1` every N seconds using an external timer or
sequence, then use it as a reset channel.

### Conditional Reset

Create a reset signal based on a condition:

```arc
if (cycle_complete_flag == 1) {
    return 1  // Trigger reset
} else {
    return 0
}
```

Use this calculated channel as the reset channel for another calculated channel with an
operation.

<Divider.Divider x />

## Common Use Cases

### Fuel Consumption Rate

```arc
mass_flow := volumetric_flow * fuel_density
return mass_flow
```

### Thrust Calculation

```arc
exhaust_velocity := 2500  // m/s
mass_flow_rate := mdot    // kg/s
return mass_flow_rate * exhaust_velocity
```

### Specific Impulse

```arc
g := 9.81  // m/s²
if (mass_flow == 0) {
    return 0
} else {
    return thrust / (mass_flow * g)
}
```

### Tank Level from Pressure

```arc
density := 1000  // kg/m³ (water)
g := 9.81        // m/s²
pressure_pa := pressure_sensor * 1000  // Convert kPa to Pa
height := pressure_pa / (density * g)
return height
```

### Signal-to-Noise Ratio (SNR)

```arc
if (noise_power == 0) {
    return 0
} else {
    snr := 10 * log10(signal_power / noise_power)
    return snr
}
```

 ^ Note: ^  Arc currently doesn't have built-in `log10`. For logarithmic operations,
consider pre-processing or using full Arc programs.

<Divider.Divider x />

## Tips & Best Practices

### Avoid Division by Zero

Always check denominators before dividing:

```arc
if (denominator == 0) {
    return 0  // or appropriate fallback
} else {
    return numerator / denominator
}
```

### Use Intermediate Variables

Break complex calculations into steps:

```arc
step1 := a * b
step2 := step1 + c
result := step2 / d
return result
```

### Type Consistency

Ensure your expression result matches the calculated channel's data type. For integer
channels, avoid floating-point results unless you want truncation.

### Combine with Operations

Use operations for stateful aggregations rather than implementing them in expressions:

- ✅ Use `max` operation for running maximum
- ❌ Don't try to implement stateful logic in expressions (without full Arc programs)

### Debugging

Start simple and build complexity incrementally. Test each step before adding more logic.

<Divider.Divider x />

## Additional Resources

- [Calculated Channels Documentation](/reference/console/calculated-channels)
- [Arc Language Reference](/reference/arc)
- [Channels Concepts](/reference/concepts/channels)
