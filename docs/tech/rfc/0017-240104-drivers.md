# 16 - General Purpose Device Drivers

**Feature Name**: General Purpose Device Drivers <br />
**Start Date**: 2024-01-04 <br />
**Authors**: Emiliano Bonilla <br />
**Status**: Draft <br />

# 5 - Detailed Design

## 5.0 - Inbound and Outbound Pipelines

Driver functionality can be separated into two distinct pipelines: outbound and inbound.
Outbound pipelines acquire data from sensors hardware and forward it to Synnax, while
inbound pipelines receive commands from Synnax and execute them on the hardware. This
marks a clear point of design separation, and has a few beneficial properties:

1. Inbound and outbound pipelines don't need to share state (aside from what is
   implemented in hardware specific libraries like DAQmx).
2. The failure of an inbound pipeline should not affect the operation of an outbound
   pipeline, and vice versa.

These two properties reduce the cognitive overhead, as both pipelines can be implemented
independently, only sharing essential primitives. Naturally, each pipeline should be
executed in its own thread.

## 5.1 - Outbound Pipeline Overview

Outbound pipelines operate as a continuous acquisition loop that performs three tasks:

1. Acquire data from hardware.
2. Apply any necessary calibrations, transformations, taring.
3. Write data to Synnax.

This loop should run at a nearly-fixed rate, and only consume a clear amount of CPU,
memory, and DAQ device resources (we'll touch more on timing later). From a high level,
implementing this loop seems quite simple. There are three emergent details that make it
far more difficult:

1. **Error handling** - Happy path execution is simple, but errors can occur in any of
   these steps. Some of these errors are critical and should halt pipeline execution,
   while some are transient and require retries or pipeline restarts. Correctly
   identifying, communicating, and handling these errors requires careful design.

2. **Configuration** - Every pipeline requires detailed configuration information to
   operate: channel names, physical device ports, calibrations, etc. These
   configurations are dynamic, and need to be updated mid-driver operation. Invalid
   configuration parameters are an additional source of errors, and need to be carefully
   communicated to and resolved by the user.

3. **Hardware 'Polymorphism'** - We're aiming to support DAQ hardware from a growing
   number of vendors, and, for the most part, the loop structure remains the same no
   matter the device. Ideally we'd make it possible to keep the majority of the pipeline
   code the same, and develop a standard interface for implementing step #1.

## 5.2 - Inbound Pipeline Overview

## 5.3 - Configuration

There are important properties and patterns to examine.

### 5.3.0 - Properties

#### 5.3.0.0 - Dynamism

Adaptive teams are always making changes to their system configuration: adding and
exchanging sensors, changing calibrations, and swapping DAQ modules. From a user
perspective, these changes are quite frequent. During setup batched configuration
changes can come every few minutes. From a software, perspective, however, these changes
are _very_ infrequent. If a pipeline runs at 200hz and a configuration change comes
every ten minutes, that's 120,000 pipeline iterations between each application. Even
using 100 pipeline iterations (0.5s) to fetch and apply configuration changes would be
almost negligible to operation.

In consequence, it's worthwhile to make the configuration process more expensive to
achieve the following:

1. Improve the configuration process for the user by providing clear, reliable feedback.
2. Improve hot path (i.e. pipeline loop) performance and reduce complexity.

#### 5.3.0.1 - Flexibility

Different organizations configure different hardware in different ways. This makes it
largely impossible to define a fixed schema for configuration parameters; attempting to
do so would not only bloat the codebase, but result in very tight coupling between the
driver, core, and frontend.

#### 5.3.0.2 - Error Variants and Emergence

There are two levels of errors that can occur during configuration: critical and warning.
Critical errors mean the system can't operate, while warnings allow the system to run
but still must be communicated.

The more complex aspect of error handling is that configuration errors can occur at two
points: during pipeline setup and during pipeline execution. For example, the hardware
may validate the acquisition rate, but during runtime an ADC may not be able to keep
pace with the system.

## 5.4 - Key Primitives

### 5.4.0 - The Rack

### 5.4.1 - The Module

### 5.4.2 - The Pipeline

### 5.4.3 - The DAQ

## Working Notes

### How do we communicate module configuration and runtime errors?

1. Rack is in charge of starting, stopping, and
