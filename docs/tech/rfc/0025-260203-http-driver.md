# HTTP Driver Specification

## Overview

Add an HTTP driver integration to the Synnax Driver system that enables:

- **Read Tasks**: Poll REST API endpoints and write response data to Synnax channels
- **Write Tasks**: Receive data from Synnax channels and send HTTP requests to control devices
- **Scan Tasks**: Proactive health monitoring of HTTP endpoints

Integration name: `http` (task types: `http_read`, `http_write`, `http_scan`)

---

## Architecture

### Directory Structure

```
x/cpp/
├── json_pointer/                 # JSON Pointer (RFC 6901) extraction (NEW)
│   ├── BUILD.bazel
│   ├── json_pointer.h
│   ├── json_pointer.cpp
│   └── json_pointer_test.cpp
├── json_convert/                 # JSON ↔ Synnax type conversion (NEW)
│   ├── BUILD.bazel
│   ├── json_convert.h            # Conversion functions
│   ├── json_convert.cpp
│   └── json_convert_test.cpp

driver/http/
├── BUILD.bazel
├── http.h                        # Factory, integration constants, error types
├── factory.cpp                   # Factory implementation
├── read_task.h                   # ReadTask + ReadTaskSource
├── write_task.h                  # WriteTask + WriteTaskSink
├── scan_task.h/.cpp              # Scanner implementation
├── device/
│   ├── BUILD.bazel
│   ├── device.h                  # HTTP client wrapper (RAII over libcurl)
│   ├── device.cpp
│   ├── device_test.cpp           # Device/client tests
│   └── manager.h                 # Connection manager with pooling
|   └── manager_test.cpp          # Connection manager tests
├── util/
│   ├── BUILD.bazel
│   ├── request_builder.h         # Request body construction utilities
│   ├── request_builder.cpp
│   └── request_builder_test.cpp  # Request builder tests
├── mock/
│   ├── BUILD.bazel
│   └── server.h                  # Mock HTTP server for testing
│   └── server_test.cpp           # Mock HTTP server testing implementation
├── read_task_test.cpp
├── write_task_test.cpp
└── scan_task_test.cpp

console/src/hardware/http/        # Console UI for HTTP devices (NEW)
├── device/                       # Device connection UI
├── task/                         # Task configuration UI
└── ...

client/py/
├── examples/http/                # Example scripts (NEW)
│   ├── __init__.py
│   ├── connect_server.py         # Device connection example
│   ├── read_task.py              # Read task example
│   ├── write_task.py             # Write task example
│   ├── scan_task.py              # Scan task example
│   ├── server.py                 # Mock server for examples
│   └── README.md
├── synnax/http/                  # HTTP driver package (NEW)
│   ├── __init__.py
│   └── types.py                  # HTTP driver types
└── tests/
    └── test_http.py              # HTTP driver unit tests

integration/tests/driver/         # Integration tests
├── http_read.py                  # Read task integration tests
├── http_write.py                 # Write task integration tests
└── http_scan.py                  # Scan task integration tests

docs/site/src/pages/              # Documentation (NEW)
└── reference/device-drivers/http/
    ├── get-started.mdx
    ├── read-task.mdx
    ├── write-task.mdx
    └── scan-task.mdx
```

### Dependencies

- **libcurl**: HTTP client library (add via Bazel Central Registry in MODULE.bazel)
- **nlohmann/json**: Already in codebase for JSON parsing
- **cpp-httplib**: For mock HTTP server in tests (add to MODULE.bazel or vendor)
- **Existing driver infrastructure**:
  - `driver/task/` - Task, Factory, Context interfaces
  - `driver/pipeline/` - Acquisition/Control pipelines
  - `driver/task/common/` - Base task implementations
  - `driver/errors/` - Error type hierarchy
  - `x/cpp/xjson/` - Configuration parsing
  - `x/cpp/breaker/` - Retry with exponential backoff

---

## Configuration Schemas

### Device Properties (stored in `synnax::Device.properties`)

```json
{
  "connection": {
    "base_url": "https://api.example.com",
    "timeout_ms": 30000,
    "auth": {
      "type": "bearer",
      "token": "abc123"
    },
    "headers": {
      "X-API-Version": "2",
      "X-Tenant-ID": "customer-001"
    }
  }
}
```

**Authentication Types:**

- `"none"` - No authentication
- `"api_key"` - `{"type": "api_key", "header": "X-API-Key", "key": "secret"}`
- `"basic"` - `{"type": "basic", "username": "user", "password": "pass"}`
- `"bearer"` - `{"type": "bearer", "token": "jwt-token"}`

### Read Task Configuration (`synnax::Task.config`)

```json
{
  "device": "device_key",
  "data_saving": true,
  "auto_start": false,
  "rate": 1.0,
  "error_on_bad_field": false,
  "endpoint": {
    "path": "/api/sensors",
    "method": "GET",
    "query_params": { "format": "json", "ids": "1,2,3" },
    "body": "{\"format\": \"json\", \"ids\": \"1,2,3\"}"
  },
  "channels": [
    {
      "pointer": "/temperature",
      "channel": 12345,
      "type": "number",
      "optional": false,
      "strict": false
    },
    {
      "pointer": "/humidity",
      "channel": 12346,
      "type": "number",
      "optional": true,
      "strict": false
    },
    {
      "pointer": "/status",
      "channel": 12347,
      "type": "string",
      "optional": false
    },
    {
      "pointer": "/sensors/0/pressure",
      "channel": 12348,
      "type": "number",
      "optional": false,
      "strict": false
    }
  ],
  "timestamp": "/data/timestamp"
}
```

**Read Task Fields:**

- `device`: Device key to retrieve connection config
- `data_saving`: Whether to persist data to disk
- `auto_start`: Whether to start the task automatically when the driver starts
- `rate`: Polling frequency in Hz (e.g., 1.0 = once per second)
- `error_on_bad_field`: If true, any bad field (wrong type, unparseable) puts task in error state and no values are written. If false, bad fields log warnings but good values still get written.
- `endpoint`: Single endpoint to poll (use query params for filtering multiple resources)
- `endpoint.method`: `"GET"` or `"POST"`
- `endpoint.query_params`: URL query parameters (manually configured by user)
- `endpoint.body`: Optional request body (for POST queries)
- `channels[].pointer`: JSON Pointer (RFC 6901) path to extract value (e.g., `/data/sensors/0/value`)
- `channels[].type`: Expected JSON type (`"number"`, `"string"`, `"boolean"`, `"object"`, `"array"`, `"null"`).
  If the type is provided, then an error or warning is raised if the response value is
  not of the expected type. If the type is not provided, then the value is passed through
  as-is depending on the conversion rules below.
- `channels[].optional`: If false, missing field error or warning depending on
  `error_on_bad_field`, if true, missing fields are just skipped when writing to Synnax channel.
- `channels[].strict`: If true, type mismatch on numbers (e.g., decimal → int64) causes
  an error or warning depending on `error_on_bad_field`
- `timestamp`: Optional JSON Pointer for server-provided timestamp. If omitted, use software timing (request midpoint).

**Type Conversion for Read Tasks (JSON → Synnax):**

| JSON Type | → Synnax Numeric                        | → Synnax String   | → Synnax JSON   | → Synnax UUID | → Synnax Bytes            |
| --------- | --------------------------------------- | ----------------- | --------------- | ------------- | ------------------------- |
| `number`  | ⚠️ Direct (strict: error on truncation) | ✅ String repr    | ✅ Pass through | ❌ Error      | ✅ Encode bytes           |
| `string`  | ⚠️ Parse number                         | ✅ Direct         | ✅ Pass through | ⚠️ Parse UUID | ✅ UTF-8 encode           |
| `boolean` | ✅ true→1, false→0                      | ✅ "true"/"false" | ✅ Pass through | ❌ Error      | ✅ 0x01 or 0x00           |
| `object`  | ❌ Error                                | ✅ JSON stringify | ✅ Pass through | ❌ Error      | ✅ JSON stringify → UTF-8 |
| `array`   | ❌ Error                                | ✅ JSON stringify | ✅ Pass through | ❌ Error      | ✅ JSON stringify → UTF-8 |
| `null`    | ✅ 0                                    | ✅ "null"         | ✅ Pass through | ❌ Error      | ✅ Empty slice            |

**Legend:**

- ✅ Direct/lossless conversion
- ⚠️ Conversion with potential warning (if parsing fails or type mismatch)
- ❌ Error - conversion not supported

**Behavior on conversion failure:**

- `error_on_bad_field=true`: Task enters error state, no values written
- `error_on_bad_field=false`: Log warning, skip bad value, write good values
- `strict=true` (numeric only): Decimal truncation (3.7→3) is an error
- `strict=false` (numeric only): Decimal truncation logs warning but proceeds

**Configuration-time validation:**

When configuring a read task, the driver looks up the Synnax DataType for each channel and validates that the expected JSON `type` can be converted to that DataType using the conversion table above. If the conversion is marked ❌ Error (e.g., JSON `object` → Synnax Numeric), the task configuration fails with an error rather than waiting for runtime.

**Note:** Only one endpoint per read task. For APIs with separate endpoints per sensor (e.g., `/sensor/1`, `/sensor/2`), create separate read tasks or use query parameter filtering if the API supports it (e.g., `/sensors?ids=1,2`).

### Write Task Configuration

Write task uses a unified `fields` array where each field specifies:

- `pointer`: JSON Pointer path for placement in request body
- `type`: `"static"`, `"channel"`, or `"generated"`
- Type-specific properties

**Example: JSON Object Body**

```json
{
  "device": "device_key",
  "data_saving": true,
  "auto_start": false,
  "throttle_rate": 10.0,
  "on_empty": "last",
  "on_initial": "zero",
  "endpoint": {
    "path": "/api/control",
    "method": "POST"
  },
  "fields": [
    {
      "pointer": "/device_id",
      "type": "static",
      "value": "sensor-001"
    },
    {
      "pointer": "/version",
      "type": "static",
      "value": 2
    },
    {
      "pointer": "/setpoint",
      "type": "channel",
      "channel": 12349,
      "format": "number"
    },
    {
      "pointer": "/mode",
      "type": "channel",
      "channel": 12350,
      "format": "string"
    },
    {
      "pointer": "/request_id",
      "type": "generated",
      "generator": "uuid"
    },
    {
      "pointer": "/sent_at",
      "type": "generated",
      "generator": "timestamp"
    }
  ]
}
```

**Example: Primitive Body (single value)**

When there's only one field with pointer at root (`""`), the body is the value itself:

```json
{
  "device": "device_key",
  "data_saving": true,
  "throttle_rate": 10.0,
  "endpoint": {
    "path": "/api/setpoint",
    "method": "PUT"
  },
  "fields": [
    {
      "pointer": "",
      "type": "channel",
      "channel": 12349,
      "format": "number"
    }
  ]
}
```

This produces request body: `25.5` (just the number, not an object)

Write tasks fields are overridden - if the first field is a JSON object containing
`"key1": {"key2": "value1"}`, but a later
field overrides it with pointer `/key1/key2` and value `"value2"`, then the request body
will be `{"key1": {"key2": "value2"}}`. Errors on configuration are raised if the
pointers for two separate fields are repeated.

**Write Task Fields:**

- `device`: Device key for connection config
- `data_saving`: Whether to persist data to disk
- `auto_start`: Whether to start the task automatically when the driver starts
- `throttle_rate`: Maximum requests per second (event-driven with rate limiting)
- `endpoint.method`: `"POST"`, `"PUT"`, `"PATCH"`, or `"DELETE"`
- `on_empty`: Behavior when a channel field hasn't received a value (see below)
- `on_initial`: Behavior for the first request when using `on_empty: "last"` (see below)
- `fields`: Array of field definitions

**Field Types:**

| Type        | Properties          | Description                                             |
| ----------- | ------------------- | ------------------------------------------------------- |
| `static`    | `value`             | Fixed value (string, number, boolean, object, array)    |
| `channel`   | `channel`, `format` | Value from Synnax channel with optional type conversion |
| `generated` | `generator`         | Auto-generated value                                    |

**Format options for channel fields:**

- `"number"` - Write as JSON number (default for numeric channels)
- `"string"` - Write as JSON string (converts numbers to strings)
- `"boolean"` - Write as JSON boolean (0→false, non-zero→true)
- `"object"` - Write as JSON object (requires JSON/String Synnax channel)
- `"array"` - Write as JSON array (requires JSON/String Synnax channel)
- `"null"` - Write as JSON null (useful for clearing values)

**Missing value behavior (`on_empty`) - Task-level property:**

Controls what happens when channel fields haven't received a value:

- `"omit"` - Don't include the field in the JSON request body (default)
- `"zero"` - Write the zero value for the field's format (0, "", false, null, {}, [])
- `"error"` - Raise an error and don't send the request
- `"last"` - Use the last received value; if no value has ever been received, falls back to `on_initial`

**Initial value behavior (`on_initial`) - Task-level property:**

Only used when `on_empty: "last"` and no value has ever been received:

- `"omit"` - Omit the field until first value is received (default)
- `"zero"` - Use zero value until first value is received

**Type Conversion for Write Tasks (Synnax → JSON):**

| Synnax Type         | → JSON `number`   | → JSON `string`   | → JSON `boolean`                                      | → JSON `object`       | → JSON `array`   | → JSON `null`                              |
| ------------------- | ----------------- | ----------------- | ----------------------------------------------------- | --------------------- | ---------------- | ------------------------------------------ |
| Numeric (int/float) | ✅ Direct         | ✅ String repr    | ✅ 0→false, else→true                                 | ❌ Error              | ❌ Error         | ⚠️ 0→null, else error                      |
| String              | ⚠️ Parse number   | ✅ Direct         | ⚠️ Parse ("true"/"false"/empty as T/F/F), otherwise T | ❌ fail               | ✅array of chars | ⚠️ Parse ("null"/empty), otherwise warning |
| JSON                | ⚠️ Extract number | ⚠️ Extract string | ⚠️ Extract boolean                                    | ⚠️ Extract object     | ⚠️ Extract array | ⚠️ Extract null                            |
| UUID                | ❌ Error          | ✅ UUID string    | ⚠️ Non-zero→true                                      | ❌ Error              | ❌ Error         | ❌ Error                                   |
| Bytes               | ❌ Error          | ⚠️ UTF-8 decode   | ⚠️ 0x01→true, 0x00→false                              | ⚠️ UTF-8 → Parse JSON | ❌ Error         | ⚠️ Empty→null                              |

**Legend:**

- ✅ Direct/lossless conversion
- ⚠️ Conversion with potential warning (if parsing fails or type mismatch)
- ❌ Error - conversion not supported

**Notes on Write Conversions:**

- For JSON Synnax channels, the value is passed through directly without format conversion
- "Extract" means the JSON value must be of that type; otherwise error/warning
- Bytes are interpreted as UTF-8 strings for parsing to structured types

**Configuration-time validation:**

When configuring a write task, the driver looks up the Synnax DataType for each channel field and validates that the DataType can be converted to the specified `format` using the conversion table above. If the conversion is marked ❌ Error (e.g., Synnax Numeric → JSON `object`), the task configuration fails with an error rather than waiting for runtime.

**Generator options:**

- `"uuid"` - Random UUID v4
- `"timestamp"` - Unix timestamp (seconds)
- `"timestamp_ms"` - Unix timestamp (milliseconds)
- `"timestamp_iso"` - ISO 8601 formatted string

### Scan Task Configuration

**Example: HTTP Status Only**

```json
{
  "device": "device_key",
  "auto_start": true,
  "rate": 0.1,
  "path": "/health",
  "method": "GET"
}
```

Health is determined by HTTP 2xx status code only.

**Example: With Response Validation**

```json
{
  "device": "device_key",
  "auto_start": true,
  "rate": 0.1,
  "path": "/health",
  "method": "GET",
  "response": {
    "field": "/status",
    "expected_value": "ok"
  }
}
```

Health requires HTTP 2xx AND response field matches expected value.

**Scan Task Fields:**

- `device`: Device key for connection config
- `auto_start`: Whether to start the task automatically when the driver starts
- `rate`: Health check frequency in Hz
- `path`: Endpoint path for health check (e.g., `/health`)
- `method`: HTTP method (default: `"GET"`)
- `response`: Optional response validation object
- `response.field`: JSON Pointer to validate in response (e.g., `/status`)
- `response.expected_value`: Expected value for the field (e.g., `"ok"`)

**⚠️ Important: HTTP Scan Task Pattern Differs from Other Drivers**

For other drivers (Modbus, OPC UA, LabJack, NI), scan tasks are:

- Automatically created and managed by the driver
- Not configurable by users in the Console
- Used for device discovery and automatic health monitoring

For HTTP, scan tasks follow a **different pattern**:

- **User-configurable** in the Console (health endpoint, expected response, scan rate)
- **User-controlled** start/stop (not automatic)
- No device discovery (HTTP endpoints are known upfront)
- Focused purely on health monitoring of configured endpoints

This difference exists because HTTP endpoints are explicitly configured by users (unlike hardware devices that can be discovered), and health check requirements vary significantly between APIs.

---

## Implementation Details

### JSON Pointer Extraction (`x/cpp/json_pointer/json_pointer.h`)

Reusable utility implementing RFC 6901 JSON Pointer:

```cpp
namespace xjson_pointer {

// Extract value from JSON using RFC 6901 pointer like "/data/sensors/0/value"
std::pair<nlohmann::json, xerrors::Error>
extract(const nlohmann::json& root, const std::string& pointer);

// Set value in JSON at the given pointer path (creates intermediate objects/arrays)
xerrors::Error set(nlohmann::json& root, const std::string& pointer, const nlohmann::json& value);

}  // namespace xjson_pointer
```

### JSON ↔ Synnax Conversion (`x/cpp/json_convert/json_convert.h`)

Reusable utilities for converting between JSON and Synnax telemetry types:

```cpp
namespace xjson_convert {

struct ConvertOptions {
    bool strict = false;         // Fail on lossy conversions (e.g., float→int truncation)
    bool error_on_failure = true; // Return error vs warning on conversion failure
};

// Convert JSON value to Synnax SampleValue based on target DataType
// Used by Read Tasks to convert API responses to Synnax channels
std::pair<telem::SampleValue, xerrors::Error>
to_sample(const nlohmann::json& value, telem::DataType target_type, const ConvertOptions& opts = {});

// Convert Synnax SampleValue to JSON with specified format
// Used by Write Tasks to convert Synnax channels to API request bodies
std::pair<nlohmann::json, xerrors::Error>
from_sample(const telem::SampleValue& value, const std::string& format, const ConvertOptions& opts = {});

// Get zero value for a JSON format type
nlohmann::json zero_value(const std::string& format);

}  // namespace xjson_convert
```

**JSON Pointer Syntax (RFC 6901):**

- `/` - root
- `/foo` - field "foo"
- `/foo/0` - first element of array "foo"
- `/foo/bar/baz` - nested path
- `~0` escapes `~`, `~1` escapes `/`

### HTTP Client Wrapper (`driver/http/device/device.h`)

```cpp
namespace http::device {

struct AuthConfig {
    std::string type;  // "none", "api_key", "basic", "bearer"
    std::string header;
    std::string key;
    std::string username;
    std::string password;
    std::string token;

    explicit AuthConfig(xjson::Parser parser);
};

struct ConnectionConfig {
    std::string base_url;
    uint32_t timeout_ms = 30000;
    AuthConfig auth;
    std::unordered_map<std::string, std::string> headers;

    explicit ConnectionConfig(xjson::Parser parser);
};

class Client {
    CURL* handle_;  // libcurl easy handle
    ConnectionConfig config_;

public:
    explicit Client(ConnectionConfig config);
    ~Client();  // RAII cleanup

    // Move-only semantics
    Client(Client&& other) noexcept;
    Client(const Client&) = delete;

    struct Response {
        long status_code;
        std::string body;
        telem::TimeStamp request_start;
        telem::TimeStamp response_received;
    };

    std::pair<Response, xerrors::Error> get(
        const std::string& path,
        const std::unordered_map<std::string, std::string>& query_params = {}
    );

    std::pair<Response, xerrors::Error> post(
        const std::string& path,
        const std::string& body,
        const std::unordered_map<std::string, std::string>& query_params = {}
    );

    std::pair<Response, xerrors::Error> request(
        const std::string& method,
        const std::string& path,
        const std::string& body = "",
        const std::unordered_map<std::string, std::string>& query_params = {}
    );
};

class Manager {
    std::unordered_map<std::string, std::shared_ptr<Client>> clients_;
    std::mutex mutex_;

public:
    std::pair<std::shared_ptr<Client>, xerrors::Error>
    acquire(const ConnectionConfig& config);
};

}  // namespace http::device
```

### Mock HTTP Server (`driver/http/mock/server.h`)

For unit and integration testing:

```cpp
namespace http::mock {

class Server {
    // cpp-httplib based mock server
public:
    Server(int port);
    ~Server();

    void start();
    void stop();

    // Configure responses
    void on_get(const std::string& path,
                std::function<std::string(const Request&)> handler);
    void on_post(const std::string& path,
                 std::function<std::string(const Request&)> handler);

    // Inspection
    std::vector<Request> received_requests() const;
};

}  // namespace http::mock
```

### Error Types

```cpp
namespace http {

const std::string INTEGRATION_NAME = "http";

namespace errors {
const xerrors::Error CRITICAL = driver::CRITICAL_HARDWARE_ERROR.sub("http");
const xerrors::Error TEMPORARY = driver::TEMPORARY_HARDWARE_ERROR.sub("http");
const xerrors::Error UNREACHABLE = TEMPORARY.sub("unreachable");
const xerrors::Error TIMEOUT = TEMPORARY.sub("timeout");
const xerrors::Error CLIENT_ERROR = CRITICAL.sub("client_error");  // 4xx
const xerrors::Error SERVER_ERROR = TEMPORARY.sub("server_error"); // 5xx
const xerrors::Error PARSE_ERROR = CRITICAL.sub("parse_error");
}  // namespace errors

}  // namespace http
```

**Error Mapping:**

- HTTP 2xx → Success
- HTTP 4xx → `CLIENT_ERROR` (CRITICAL - configuration issue, don't retry)
- HTTP 5xx → `SERVER_ERROR` (TEMPORARY - retry with backoff)
- Connection timeout → `TIMEOUT` (TEMPORARY)
- Connection refused → `UNREACHABLE` (TEMPORARY)
- JSON parse failure → `PARSE_ERROR` (CRITICAL)
- Missing required field → `PARSE_ERROR` (CRITICAL)
- Missing optional field → Warning only, continue

---

## Timestamp Handling

Default behavior:

1. Record `request_start` before HTTP call
2. Record `response_received` after HTTP response
3. Use midpoint: `(request_start + response_received) / 2`

If `timestamp_field` is configured:

1. Extract timestamp from response JSON
2. Parse as ISO 8601 string or Unix timestamp
3. Use parsed value instead of midpoint

---

## Python Client API

The Python client provides a high-level API for configuring HTTP devices and tasks via `synnax.http`:

### Device Creation

```python
import synnax as sy
from synnax.http import HTTPDevice, ReadChannel, StaticField, ChannelField, GeneratedField

client = sy.Synnax(...)

# Create an HTTP device
device = sy.http.create_device(
    client=client,
    name="my-api-server",
    base_url="https://api.example.com",
    auth={
        "type": "bearer",
        "token": "my-jwt-token"
    },
    headers={
        "X-API-Version": "2"
    },
    timeout_ms=30000
)
```

### Read Task Configuration

```python
# Create channels
temp_ch = client.channels.create(name="temperature", data_type=sy.DataType.FLOAT64)
status_ch = client.channels.create(name="status", data_type=sy.DataType.STRING)

# Create read task
read_task = sy.http.create_read_task(
    client=client,
    device=device,
    name="sensor-poller",
    rate=1.0,  # Hz
    auto_start=False,
    data_saving=True,
    error_on_bad_field=False,
    endpoint={
        "path": "/api/sensors",
        "method": "GET",
        "query_params": {"format": "json"}
    },
    channels=[
        ReadChannel(
            pointer="/temperature",
            channel=temp_ch,
            type="number",
            optional=False,
            strict=False
        ),
        ReadChannel(
            pointer="/status",
            channel=status_ch,
            type="string",
            optional=True
        )
    ],
    timestamp="/data/timestamp"  # Optional
)

read_task.start()
```

### Write Task Configuration

```python
setpoint_ch = client.channels.create(name="setpoint", data_type=sy.DataType.FLOAT64)

write_task = sy.http.create_write_task(
    client=client,
    device=device,
    name="controller",
    auto_start=False,
    data_saving=True,
    throttle_rate=10.0,
    on_empty="last",      # Use last received value
    on_initial="zero",    # Use zero until first value received
    endpoint={
        "path": "/api/control",
        "method": "POST"
    },
    fields=[
        StaticField(pointer="/device_id", value="sensor-001"),
        ChannelField(pointer="/setpoint", channel=setpoint_ch, format="number"),
        GeneratedField(pointer="/request_id", generator="uuid")
    ]
)

write_task.start()
```

### Scan Task Configuration

```python
scan_task = sy.http.create_scan_task(
    client=client,
    device=device,
    name="health-monitor",
    auto_start=True,
    rate=0.1,  # Hz
    path="/health",
    method="GET",
    response={
        "field": "/status",
        "expected_value": "ok"
    }
)
```

---

## Integration Testing

### Mock HTTP Server (Python)

The integration tests use a Python mock HTTP server defined in `conftest.py` that can:

- Serve configurable JSON responses for any endpoint
- Log all received requests for assertion
- Simulate various HTTP status codes (2xx, 4xx, 5xx)
- Simulate timeouts and connection errors
- Support all HTTP methods (GET, POST, PUT, PATCH, DELETE)

```python
# integration/tests/driver/conftest.py
from flask import Flask, request, jsonify
import threading

class MockHTTPServer:
    def __init__(self, port: int = 8080):
        self.app = Flask(__name__)
        self.responses = {}
        self.received_requests = []
        self._setup_routes()

    def set_response(self, path: str, method: str, response: dict, status: int = 200):
        """Configure a response for a specific endpoint."""
        self.responses[(path, method.upper())] = (response, status)

    def get_requests(self, path: str = None) -> list:
        """Get logged requests, optionally filtered by path."""
        if path:
            return [r for r in self.received_requests if r['path'] == path]
        return self.received_requests

    def start(self):
        """Start the server in a background thread."""
        self._thread = threading.Thread(target=self.app.run, kwargs={"port": self.port})
        self._thread.daemon = True
        self._thread.start()

    def stop(self):
        """Stop the server."""
        # Flask shutdown logic
        ...
```

### Test Fixtures

```python
# integration/tests/driver/conftest.py
import pytest
import synnax as sy

@pytest.fixture(scope="module")
def mock_server():
    server = MockHTTPServer(port=8080)
    server.start()
    yield server
    server.stop()

@pytest.fixture(scope="module")
def client():
    return sy.Synnax(host="localhost", port=9090, username="synnax", password="seldon")

@pytest.fixture
def http_device(client, mock_server):
    """Create an HTTP device pointing to the mock server."""
    return sy.http.create_device(
        client=client,
        name="test-http-device",
        base_url=f"http://localhost:{mock_server.port}",
        auth={"type": "none"}
    )
```

### Test Example

```python
# integration/tests/driver/http_read.py
import time
import pytest
import synnax as sy
from synnax.http import ReadChannel

def test_read_task_polls_endpoint(client, mock_server, http_device):
    # Configure mock response
    mock_server.set_response("/sensors", "GET", {
        "temperature": 25.5,
        "humidity": 60
    })

    # Create channels
    temp_ch = client.channels.create(name="temp", data_type=sy.DataType.FLOAT64)

    # Create and start read task
    task = sy.http.create_read_task(
        client=client,
        device=http_device,
        rate=1.0,
        endpoint={"path": "/sensors", "method": "GET"},
        channels=[
            ReadChannel(pointer="/temperature", channel=temp_ch, type="number")
        ]
    )
    task.start()

    # Wait and verify data was written
    time.sleep(2)
    task.stop()

    data = temp_ch.read(sy.TimeRange.last(sy.TimeSpan.SECOND * 3))
    assert len(data) >= 1
    assert data[0] == pytest.approx(25.5)
```

---

## Platform Support

All platforms: Windows, Linux, macOS, NI Linux RT

libcurl is available on all platforms. Use Bazel `select()` for any platform-specific linker flags:

```python
linkopts = select({
    "@platforms//os:windows": ["-lcurl", "ws2_32.lib"],
    "//conditions:default": ["-lcurl"],
})
```

---

## Factory Registration

Add to `driver/rack/factories.cpp`:

```cpp
#include "driver/http/http.h"

void configure_http(const rack::Config& config, FactoryList& factories) {
    configure_integration(config, factories, http::INTEGRATION_NAME, []() {
        return std::make_unique<http::Factory>();
    });
}

// In Config::new_factory():
configure_http(*this, factories);
```

---

## Recommended PR Order

PRs are organized by feature: **Device → Read Task → Write Task → Scan Task**

Each feature goes through all layers: C++ → Console → Python → Tests → Docs

---

### Device Connection Feature

#### PR 1: C++ Device Foundation

**Scope:** Core utilities and HTTP client infrastructure

- `MODULE.bazel` - Add libcurl and cpp-httplib dependencies
- `x/cpp/json_pointer/` - JSON Pointer (RFC 6901) extraction utility + tests
- `x/cpp/json_convert/` - JSON ↔ Synnax type conversion utility + tests
- `driver/http/BUILD.bazel`
- `driver/http/http.h` (constants, error types)
- `driver/http/device/` - Client, Manager + tests
- `driver/http/mock/` - Mock HTTP server for C++ unit tests

#### PR 2: Console Device Connection

**Scope:** Console UI for connecting to HTTP devices

- `console/src/hardware/http/device/` - Device configuration UI
- Device properties form (base URL, auth, headers)
- Connection testing UI

#### PR 3: Python Client - Device

**Scope:** Python client support for HTTP devices

- `client/py/synnax/http/__init__.py` - HTTP driver package
- `client/py/synnax/http/types.py` - Device type definitions
- `client/py/examples/http/connect_server.py` - Device connection example
- `client/py/examples/http/server.py` - Mock server for examples
- `client/py/tests/test_http.py` - Device unit tests

#### PR 4: Documentation - Get Started

**Scope:** HTTP driver overview and device connection docs

- `docs/site/src/pages/reference/device-drivers/http/get-started.mdx`
- Overview, connection setup, authentication options, headers

---

### Read Task Feature

#### PR 5: C++ Read Task

**Scope:** Read task implementation

- `driver/http/read_task.h`
- `driver/http/factory.cpp` (partial - read task only)
- Integration with `driver/rack/factories.cpp`
- `driver/http/read_task_test.cpp`

#### PR 6: Console Read Task

**Scope:** Console UI for read task configuration

- `console/src/hardware/http/task/Read.tsx`
- Endpoint configuration UI
- Channel mapping UI with JSON Pointer input
- Poll rate configuration

#### PR 7: Python Client - Read Task

**Scope:** Python client support for HTTP read tasks

- `client/py/synnax/http/read.py` - Read task configuration
- `client/py/examples/http/read_task.py` - Read task example
- Unit tests for read task configuration

#### PR 8: Integration Tests - Read Task

**Scope:** End-to-end read task testing

- `integration/tests/driver/conftest.py` - Shared fixtures, mock HTTP server
- `integration/tests/driver/http_read.py`
  - Polling at various rates
  - JSON Pointer extraction with nested paths
  - Type conversions (number, string, boolean, json, uuid, bytes)
  - Error handling (missing fields, wrong types, `error_on_bad_field`)
  - Timestamp extraction from response

#### PR 9: Documentation - Read Task

**Scope:** Read task documentation

- `docs/site/src/pages/reference/device-drivers/http/read-task.mdx`
- Configuration reference, JSON Pointer syntax, type conversions, examples

---

### Write Task Feature

#### PR 10: C++ Write Task

**Scope:** Write task implementation

- `driver/http/write_task.h`
- `driver/http/util/request_builder.h` + tests
- Update factory for write task
- `driver/http/write_task_test.cpp`

#### PR 11: Console Write Task

**Scope:** Console UI for write task configuration

- `console/src/hardware/http/task/Write.tsx`
- Request body builder UI (static, channel, generated fields)
- Throttle rate configuration
- Missing value behavior (on_empty) configuration

#### PR 12: Python Client - Write Task

**Scope:** Python client support for HTTP write tasks

- `client/py/synnax/http/write.py` - Write task configuration
- `client/py/examples/http/write_task.py` - Write task example
- Unit tests for write task configuration

#### PR 13: Integration Tests - Write Task

**Scope:** End-to-end write task testing

- `integration/tests/driver/http_write.py`
  - Event-driven writes with throttling
  - JSON body construction (object and primitive)
  - Static, channel, and generated fields
  - Type conversions
  - `on_empty` behavior (omit vs zero vs error vs last)
  - `on_initial` behavior (zero vs omit)

#### PR 14: Documentation - Write Task

**Scope:** Write task documentation

- `docs/site/src/pages/reference/device-drivers/http/write-task.mdx`
- Configuration reference, field types, request body construction, examples

---

### Scan Task Feature

#### PR 15: C++ Scan Task

**Scope:** Health monitoring scan task

- `driver/http/scan_task.h`, `scan_task.cpp`
- Update factory for scan task
- `driver/http/scan_task_test.cpp`

#### PR 16: Console Scan Task

**Scope:** Console UI for scan task configuration

- `console/src/hardware/http/task/Scan.tsx`
- Health endpoint configuration UI
- Expected response validation UI

#### PR 17: Python Client - Scan Task

**Scope:** Python client support for HTTP scan tasks

- `client/py/synnax/http/scan.py` - Scan task configuration
- `client/py/examples/http/scan_task.py` - Scan task example
- Unit tests for scan task configuration

#### PR 18: Integration Tests - Scan Task

**Scope:** End-to-end scan task testing

- `integration/tests/driver/http_scan.py`
  - Health checks with HTTP status only
  - Health checks with response validation
  - Device status updates on success/failure

#### PR 19: Documentation - Scan Task

**Scope:** Scan task documentation

- `docs/site/src/pages/reference/device-drivers/http/scan-task.mdx`
- Health check configuration, response validation, monitoring setup

---

## Key Files to Reference

### Driver Patterns

- `/driver/modbus/` - Modbus TCP/IP (similar network protocol)
- `/driver/opc/` - OPC UA (connection pooling pattern)
- `/driver/task/common/read_task.h` - Base read task (lines 103-240)
- `/driver/task/common/write_task.h` - Base write task (lines 130-269)
- `/driver/task/common/sample_clock.h` - SoftwareTimedSampleClock
- `/driver/task/task.h` - Task, Factory, Context interfaces
- `/driver/pipeline/acquisition.h` - Acquisition pipeline
- `/driver/errors/errors.h` - Error hierarchy
- `/x/cpp/xjson/xjson.h` - JSON configuration parsing

### Console Patterns

- `/console/src/hardware/opc/` - OPC UA device/task UI
- `/console/src/hardware/modbus/` - Modbus device/task UI
- `/console/src/hardware/ni/` - National Instruments UI patterns

### Documentation Patterns

- `/docs/site/src/pages/reference/device-drivers/opc-ua/` - OPC UA docs structure
- `/docs/site/src/pages/reference/device-drivers/` - Other driver docs

---

## Open Questions / Future Enhancements

1. **Array-to-Series**: Support mapping JSON arrays to multiple samples in a series
2. **Per-Endpoint Headers**: Allow header overrides per endpoint
3. **Write Response Parsing**: Optionally parse write responses for state feedback
4. **Webhook Support**: HTTP server mode for receiving push notifications
5. **WebSocket Support**: Streaming data over WebSocket connections
6. **Certificate Configuration**: Custom CA certs, client certs for mTLS
7. **More Granular Timeouts**: Separate connect, read, total timeouts
8. **Dynamic Query Params**: Auto-construct query params from channel config

---

## Summary of Design Decisions

| Decision              | Choice                                         | Rationale                                                                      |
| --------------------- | ---------------------------------------------- | ------------------------------------------------------------------------------ |
| HTTP Library          | libcurl (Bazel module)                         | Industry standard, cross-platform, TLS support                                 |
| Data Format           | JSON only                                      | Most common, nlohmann/json already in codebase                                 |
| Authentication        | None/API Key/Basic/Bearer                      | Covers 95%+ of REST APIs                                                       |
| Field Extraction      | JSON Pointer (RFC 6901)                        | Standardized, simple, single-value                                             |
| JSON Pointer Location | `x/cpp/json_pointer/`                          | Reusable utility, not HTTP-specific                                            |
| Write Body Type       | Object or Primitive                            | Supports both JSON objects and single values                                   |
| Type Conversion       | Configurable per field                         | Convert numeric to string, etc.                                                |
| Read Timing           | Single poll_rate                               | Simpler than sample_rate/stream_rate for low-frequency polling                 |
| Write Timing          | Event-driven + throttle                        | Responsive but prevents overwhelming server                                    |
| Endpoints per Task    | Single                                         | Simpler; use query params for filtering, separate tasks for separate endpoints |
| Query Params          | Manual configuration                           | Users know their API's filtering syntax                                        |
| Timestamps            | Midpoint default, configurable                 | Balance accuracy with flexibility                                              |
| Error Handling        | 4xx=CRITICAL, 5xx=TEMPORARY                    | Match HTTP semantics to driver error model                                     |
| Health Config         | Scan task config                               | More flexible than device properties                                           |
| Health Monitoring     | Passive + Active scan                          | Comprehensive monitoring                                                       |
| Connection Reuse      | Yes (libcurl keep-alive)                       | Standard HTTP practice                                                         |
| Write Response        | Status check only                              | Keep simple, use Read Task for state                                           |
| Platforms             | All                                            | libcurl available everywhere                                                   |
| Scan Task Pattern     | User-configurable, start/stop                  | Unlike other drivers where scan is automatic                                   |
| PR Structure          | 19 PRs (Device → Read → Write → Scan features) | Incremental delivery by feature                                                |
