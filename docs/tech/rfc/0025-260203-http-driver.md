# HTTP Driver Specification

## Overview

Add an HTTP driver integration to the Synnax Driver system that enables:

- **Read Tasks**: Poll REST API endpoints and write response data to Synnax channels
- **Write Tasks**: Receive data from Synnax channels and send HTTP requests to control
  devices
- **Scan Tasks**: Proactive health monitoring of HTTP endpoints

Integration name: `http` (task types: `http_read`, `http_write`, `http_scan`)

### Supported Types

**JSON types per endpoint:** `number`, `string`, `boolean`

Objects, arrays, and nulls are not supported as field-level values. The overall request
and response bodies are JSON objects, but individual extracted/inserted fields must be
one of the three types above.

**Synnax channel data types:** Numeric types (int8 through float64) and String.

UUID, Bytes, and JSON Synnax types are not supported by this driver.

---

## Architecture

### Directory Structure

```
x/cpp/xjson/
├── convert.h/.cpp                # JSON ↔ Synnax type conversion (NEW)
└── convert_test.cpp

driver/http/
├── BUILD.bazel
├── http.h                        # Factory, integration constants, error types
├── factory.cpp                   # Factory implementation
├── read_task.h/.cpp              # ReadTask + ReadTaskSource
├── read_task_test.cpp
├── write_task.h/.cpp             # WriteTask + WriteTaskSink
├── write_task_test.cpp
├── scan_task.h/.cpp              # Scanner implementation
├── scan_task_test.cpp
├── device/
│   ├── BUILD.bazel
│   ├── device.h/.cpp             # HTTP client wrapper (RAII over libcurl)
│   ├── device_test.cpp           # Device/client tests
│   ├── manager.h/.cpp            # Connection manager with pooling
│   └── manager_test.cpp          # Connection manager tests
├── util/
│   ├── BUILD.bazel
│   ├── request_builder.h/.cpp    # Request body construction utilities
│   └── request_builder_test.cpp  # Request builder tests
└── mock/
    ├── BUILD.bazel
    ├── server.h/.cpp             # Mock HTTP server for testing
    └── server_test.cpp           # Mock HTTP server tests

console/src/hardware/http/        # Console UI for HTTP devices (NEW)
├── device/                       # Device connection UI
├── task/                         # Task configuration UI
└── ...

client/py/
├── examples/http/                # Example scripts (NEW)
│   ├── __init__.py
│   ├── connect_server.py         # Device connection example
│   ├── read_task.py              # Read task example
│   ├── write_task.py             # Write task example
│   ├── scan_task.py              # Scan task example
│   ├── server.py                 # Mock server for examples
│   └── README.md
├── synnax/http/                  # HTTP driver package (NEW)
│   ├── __init__.py
│   └── types.py                  # HTTP driver types
└── tests/
    └── test_http.py              # HTTP driver unit tests

integration/tests/driver/http/    # Integration tests
├── read.py                       # Read task integration tests
├── write.py                      # Write task integration tests
└── scan.py                       # Scan task integration tests

docs/site/src/pages/reference/device-drivers/http/  # Documentation (NEW)
├── _nav.ts
├── get-started.mdx
├── connect-server.mdx
├── read-task.mdx
├── write-task.mdx
└── scan-task.mdx
```

### Dependencies

- **libcurl**: HTTP client library (add via Bazel Central Registry in MODULE.bazel)
- **nlohmann/json**: Already in codebase for JSON parsing
- **cpp-httplib**: For mock HTTP server in tests (add to MODULE.bazel or vendor)
- **Existing driver infrastructure**:
  - `driver/task/` - Task, Factory, Context interfaces
  - `driver/pipeline/` - Acquisition/Control pipelines
  - `driver/task/common/` - Base task implementations
  - `driver/errors/` - Error type hierarchy
  - `x/cpp/xjson/` - Configuration parsing
  - `x/cpp/breaker/` - Retry with exponential backoff

---

## Configuration Schemas

### Device Properties (stored in `synnax::Device.properties`)

```json
{
  "connection": {
    "base_url": "https://api.example.com",
    "timeout_ms": 30000,
    "auth": {
      "type": "bearer",
      "token": "abc123"
    },
    "headers": {
      "X-API-Version": "2",
      "X-Tenant-ID": "customer-001"
    }
  }
}
```

**Authentication Types:**

- `"none"` - No authentication
- `"api_key"` - `{"type": "api_key", "header": "X-API-Key", "key": "secret"}`
- `"basic"` - `{"type": "basic", "username": "user", "password": "pass"}`
- `"bearer"` - `{"type": "bearer", "token": "jwt-token"}`

### Read Task Configuration (`synnax::Task.config`)

A single read task can poll **multiple endpoints**. Each endpoint has its own set of
fields. All endpoints are polled at the same rate on each cycle.

```json
{
  "device": "device_key",
  "data_saving": true,
  "auto_start": false,
  "rate": 1.0,
  "strict": false,
  "endpoints": [
    {
      "path": "/api/sensors",
      "method": "GET",
      "query_params": { "format": "json", "ids": "1,2,3" },
      "fields": [
        {
          "pointer": "/temperature",
          "channel": 12345,
          "type": "number",
          "time_pointer": "/data/timestamp",
          "time_format": "iso8601"
        },
        {
          "pointer": "/humidity",
          "channel": 12346,
          "type": "number",
          "time_pointer": "/data/timestamp",
          "time_format": "iso8601"
        },
        {
          "pointer": "/status",
          "channel": 12347,
          "type": "string",
          "time_pointer": "/data/timestamp",
          "time_format": "iso8601"
        }
      ]
    },
    {
      "path": "/api/pressure",
      "method": "GET",
      "fields": [
        {
          "pointer": "/value",
          "channel": 12348,
          "type": "number"
        }
      ]
    }
  ]
}
```

**Read Task Fields:**

- `device`: Device key to retrieve connection config
- `data_saving`: Whether to persist data to disk
- `auto_start`: Whether to start the task automatically when the driver starts
- `rate`: Polling frequency in Hz (e.g., 1.0 = once per second). All endpoints are
  polled on each cycle.
- `strict`: Task-level setting. If true, lossy numeric conversions (e.g., float 3.7 →
  int64 truncated to 3) cause the task to enter an error state. If false (default),
  truncation proceeds silently.
- `endpoints`: Array of endpoints to poll. Each endpoint is an independent HTTP request.
- `endpoints[].path`: URL path appended to the device's base_url
- `endpoints[].method`: `"GET"` or `"POST"`
- `endpoints[].query_params`: Optional URL query parameters
- `endpoints[].body`: Optional request body (for POST queries)
- `endpoints[].fields`: Array of field mappings for this endpoint's response
- `endpoints[].fields[].pointer`: JSON Pointer (RFC 6901) path to extract value (e.g.,
  `/data/sensors/0/value`)
- `endpoints[].fields[].type`: **Required.** Expected JSON type: `"number"`, `"string"`,
  or `"boolean"`. An error is raised if the response value does not match this type.
- `endpoints[].fields[].time_pointer`: Optional JSON Pointer to extract a timestamp from
  the response for this field's channel. If omitted, software timing (request midpoint)
  is used for the channel's index.
- `endpoints[].fields[].time_format`: Required when `time_pointer` is set. Timestamp
  format (see below).

**Timestamp Formats (same five options used across read and write tasks):**

- `"iso8601"` - ISO 8601 string (e.g., `"2024-01-15T10:30:00Z"`)
- `"unix_sec"` - Unix timestamp in seconds
- `"unix_ms"` - Unix timestamp in milliseconds
- `"unix_us"` - Unix timestamp in microseconds
- `"unix_ns"` - Unix timestamp in nanoseconds

If no `time_pointer` is configured for a field, the driver uses software timing:
midpoint of `(request_start + response_received) / 2` for that channel's index.

**Type Conversion for Read Tasks (JSON → Synnax):**

| JSON Type | → Synnax Numeric                        | → Synnax String          |
| --------- | --------------------------------------- | ------------------------ |
| `number`  | ⚠️ Direct (strict: error on truncation) | ✅ String representation |
| `string`  | ❌ Error                                | ✅ Direct                |
| `boolean` | ✅ true→1, false→0                      | ✅ "true"/"false"        |

**Legend:**

- ✅ Direct/lossless conversion
- ⚠️ Conversion possible but may warn (e.g., float→int truncation)
- ❌ Error - conversion not supported

**Notes on Read Conversions:**

- JSON `string` → Synnax Numeric is not supported. Parsing arbitrary strings as numbers
  is error-prone and adds complexity. If an API returns numeric values as strings, users
  should store them in Synnax String channels and convert downstream.
- JSON `number` → Synnax Numeric with `strict=true`: if the JSON value is a float (e.g.,
  3.7) but the Synnax channel is an integer type (e.g., int64), this is treated as an
  error because the truncation to 3 is lossy. If the JSON value is too large for the
  Synnax channel type (e.g., 344 → uint8), this is also an error.
- JSON `boolean` → Synnax Numeric: `true` becomes 1, `false` becomes 0 (as the channel's
  numeric type).

**Behavior on conversion failure:**

- Type mismatch (e.g., JSON `string` received but `"number"` expected): Task enters
  error state, no values written for that cycle.
- `strict=true`: Lossy numeric truncation (e.g., float→int) also causes error state.
- `strict=false`: Lossy numeric truncation proceeds silently.

**Configuration-time validation:**

When configuring a read task, the driver validates:

1. **Type compatibility**: For each channel, look up the Synnax DataType and check
   against the specified JSON `type` using the conversion table. If the conversion is ❌
   Error (e.g., JSON `string` → Synnax Numeric), configuration fails immediately.
2. **Channel uniqueness**: No Synnax channel key may appear more than once across all
   endpoints in the task.
3. **Required fields**: `type` is required for every field mapping.
4. **Index resolution**: The driver determines which index channels need to be written
   and where their timestamps come from. For each field, the driver looks up the
   channel's index key. An index channel's timestamp source can be specified in multiple
   ways:
   - A field whose `channel` **is** the index channel directly (the field's `pointer`
     extracts the timestamp value)
   - A field whose `channel` is indexed by that index channel, with `time_pointer` set
     (the `time_pointer` extracts the timestamp value) If the same index channel is
     referenced by multiple fields, all must resolve to the same JSON pointer path and
     format. If they disagree, configuration fails with an error. If no field provides a
     timestamp source for a given index channel, software timing (request midpoint) is
     used for that index.

### Write Task Configuration

A single write task can send to **multiple endpoints**. Each endpoint has its own set of
fields that define the request body. The task is event-driven: when new values arrive on
any subscribed channel, all endpoints are triggered (subject to throttle rate).

Write task uses a unified `fields` array per endpoint where each field specifies:

- `pointer`: JSON Pointer path for placement in request body
- `type`: `"static"`, `"channel"`, or `"generated"`
- Type-specific properties

**Example: Multiple Endpoints**

```json
{
  "device": "device_key",
  "data_saving": true,
  "auto_start": false,
  "throttle_rate": 10.0,
  "on_empty": "last",
  "on_initial": "zero",
  "endpoints": [
    {
      "path": "/api/control",
      "method": "POST",
      "fields": [
        {
          "pointer": "/device_id",
          "type": "static",
          "value": "sensor-001"
        },
        {
          "pointer": "/setpoint",
          "type": "channel",
          "channel": 12349,
          "format": "number",
          "time_pointer": "/setpoint_timestamp",
          "time_format": "unix_ms"
        },
        {
          "pointer": "/request_id",
          "type": "generated",
          "generator": "uuid"
        },
        {
          "pointer": "/sent_at",
          "type": "generated",
          "generator": "timestamp",
          "format": "iso8601"
        }
      ]
    },
    {
      "path": "/api/mode",
      "method": "PUT",
      "fields": [
        {
          "pointer": "",
          "type": "channel",
          "channel": 12350,
          "format": "string"
        }
      ]
    }
  ]
}
```

**Example: Primitive Body (single value)**

When there's only one field with pointer at root (`""`), the body is the value itself:

```json
{
  "device": "device_key",
  "data_saving": true,
  "throttle_rate": 10.0,
  "endpoints": [
    {
      "path": "/api/setpoint",
      "method": "PUT",
      "fields": [
        {
          "pointer": "",
          "type": "channel",
          "channel": 12349,
          "format": "number"
        }
      ]
    }
  ]
}
```

This produces request body: `25.5` (just the number, not an object)

Write task fields are applied in order - if an earlier field sets a nested object and a
later field targets a path within it, the later field wins. Configuration fails if two
fields have identical pointers within the same endpoint.

**Write Task Fields:**

- `device`: Device key for connection config
- `data_saving`: Whether to persist data to disk
- `auto_start`: Whether to start the task automatically when the driver starts
- `throttle_rate`: Maximum iterations per second of the main write task loop. Each
  iteration processes all pending channel values and sends requests to all endpoints.
  The task is event-driven (triggered by new channel values) but will not iterate faster
  than this rate.
- `on_empty`: Behavior when a channel field hasn't received a value (see below)
- `on_initial`: Behavior for the first request when using `on_empty: "last"` (see below)
- `endpoints`: Array of endpoint definitions
- `endpoints[].path`: URL path appended to the device's base_url
- `endpoints[].method`: `"POST"`, `"PUT"`, `"PATCH"`, or `"DELETE"`
- `endpoints[].fields`: Array of field definitions for this endpoint's request body

**Field Types:**

| Type        | Properties                                         | Description                                             |
| ----------- | -------------------------------------------------- | ------------------------------------------------------- |
| `static`    | `value`                                            | Fixed value (string, number, or boolean)                |
| `channel`   | `channel`, `format`, `time_pointer`, `time_format` | Value from Synnax channel with optional type conversion |
| `generated` | `generator` (+ `format` for timestamp)             | Auto-generated value                                    |

**Format options for channel fields:**

- `"number"` - Write as JSON number (default for numeric channels)
- `"string"` - Write as JSON string (converts numbers to strings)
- `"boolean"` - Write as JSON boolean (0→false, non-zero→true)

**Timestamp options for channel fields:**

- `time_pointer`: Optional JSON Pointer path where the channel's timestamp should be
  placed in the request body. The timestamp is the Synnax sample timestamp for the
  channel value being written.
- `time_format`: Required when `time_pointer` is set. Timestamp format, using the same
  five options as read task timestamps:
  - `"iso8601"` - ISO 8601 formatted string
  - `"unix_sec"` - Unix timestamp in seconds
  - `"unix_ms"` - Unix timestamp in milliseconds
  - `"unix_us"` - Unix timestamp in microseconds
  - `"unix_ns"` - Unix timestamp in nanoseconds

**Missing value behavior (`on_empty`) - Task-level property:**

Controls what happens when channel fields haven't received a value:

- `"omit"` - Don't include the field in the JSON request body (default)
- `"zero"` - Write the zero value for the field's format (0, "", false)
- `"error"` - Raise an error and don't send the request
- `"last"` - Use the last received value; if no value has ever been received, falls back
  to `on_initial`

**Initial value behavior (`on_initial`) - Task-level property:**

Only used when `on_empty: "last"` and no value has ever been received:

- `"omit"` - Omit the field until first value is received (default)
- `"zero"` - Use zero value until first value is received

**Type Conversion for Write Tasks (Synnax → JSON):**

| Synnax Type         | → JSON `number` | → JSON `string`          | → JSON `boolean`      |
| ------------------- | --------------- | ------------------------ | --------------------- |
| Numeric (int/float) | ✅ Direct       | ✅ String representation | ✅ 0→false, else→true |
| String              | ❌ Error        | ✅ Direct                | ❌ Error              |

**Legend:**

- ✅ Direct/lossless conversion
- ❌ Error - conversion not supported

**Notes on Write Conversions:**

- Synnax String → JSON `number` is not supported (same rationale as read: parsing
  arbitrary strings as numbers is error-prone).
- Synnax String → JSON `boolean` is not supported for the same reason.
- Numeric → boolean: 0 is false, any non-zero value is true.

**Configuration-time validation:**

When configuring a write task, the driver validates:

1. **Type compatibility**: For each channel field, look up the Synnax DataType and check
   against the specified `format` using the conversion table. If the conversion is ❌
   Error (e.g., Synnax String → JSON `number`), configuration fails immediately.
2. **Pointer uniqueness**: Within each endpoint, no two fields may have the same
   pointer.
3. **Channel type check**: Verify that each referenced channel's DataType is either a
   numeric type or String.

**Generator options:**

- `"uuid"` - Random UUID v4 (written as a JSON string)
- `"timestamp"` - Timestamp value. Requires a `format` field with one of the same five
  timestamp format options used by read task timestamps:
  - `"iso8601"` - ISO 8601 formatted string (written as a JSON string)
  - `"unix_sec"` - Unix timestamp in seconds (written as a JSON number)
  - `"unix_ms"` - Unix timestamp in milliseconds (written as a JSON number)
  - `"unix_us"` - Unix timestamp in microseconds (written as a JSON number)
  - `"unix_ns"` - Unix timestamp in nanoseconds (written as a JSON number)

### Scan Task Configuration

**Example: HTTP Status Only**

```json
{
  "device": "device_key",
  "auto_start": true,
  "rate": 0.1,
  "path": "/health",
  "method": "GET"
}
```

Health is determined by HTTP 2xx status code only.

**Example: With Response Validation**

```json
{
  "device": "device_key",
  "auto_start": true,
  "rate": 0.1,
  "path": "/health",
  "method": "GET",
  "response": {
    "field": "/status",
    "expected_value": "ok"
  }
}
```

Health requires HTTP 2xx AND response field matches expected value.

**Scan Task Fields:**

- `device`: Device key for connection config
- `auto_start`: Whether to start the task automatically when the driver starts
- `rate`: Health check frequency in Hz
- `path`: Endpoint path for health check (e.g., `/health`)
- `method`: HTTP method (default: `"GET"`)
- `response`: Optional response validation object
- `response.field`: JSON Pointer to validate in response (e.g., `/status`)
- `response.expected_value`: Expected value for the field (e.g., `"ok"`)

**HTTP Scan Task Pattern Differs from Other Drivers**

For other drivers (Modbus, OPC UA, LabJack, NI), scan tasks are:

- Automatically created and managed by the driver
- Not configurable by users in the Console
- Used for device discovery and automatic health monitoring

For HTTP, scan tasks follow a **different pattern**:

- **User-configurable** in the Console (health endpoint, expected response, scan rate)
- **User-controlled** start/stop (not automatic)
- No device discovery (HTTP endpoints must be known upfront, similar to Modbus and OPC
  UA)
- Focused purely on health monitoring of configured endpoints

This difference exists because HTTP endpoints can vary widely between APIs. Like Modbus
and OPC UA servers, the device for an HTTP server must be explicitly configured for
users.

---

## Implementation Details

### JSON Pointer Handling

JSON Pointer (RFC 6901) is used throughout the driver for field extraction and request
body construction. Rather than a custom utility, the driver uses
`nlohmann::json_pointer` directly, which is built into the nlohmann/json library already
in the codebase.

At configuration time, pointer strings from the task config (e.g.,
`"/data/sensors/0/value"`) are parsed into `nlohmann::json_pointer` objects and stored
on the field structs. At runtime, these pre-parsed pointers are used for O(depth)
lookups via `json.at(pointer)` and assignments via `json[pointer] = value` — no string
re-parsing on the hot path.

**JSON Pointer Syntax (RFC 6901):**

- `""` - top level of the JSON (for non-object/array values)
- `/foo` - field "foo"
- `/foo/0` - first element of array "foo"
- `/foo/bar/baz` - nested path
- `~0` escapes `~`, `~1` escapes `/`

### JSON ↔ Synnax Conversion (`x/cpp/json/convert.h`)

Reusable utilities for converting between JSON and Synnax telemetry types. Supports
three JSON types (number, string, boolean), Synnax numeric types, strings, and
timestamps.

#### Read Side: `to_sample_value`

`to_sample_value(json, DataType, ReadOptions)` inspects the JSON value's type at runtime
and converts to the target DataType. The caller doesn't need to specify the JSON type —
it's inferred from the value itself. This means a Synnax string channel accepts any JSON
type (number, string, boolean) without any config-time declaration.

Unsupported combinations (e.g., JSON string → numeric, JSON boolean → timestamp) return
a runtime error. The `strict` flag controls whether lossy numeric conversions (e.g.,
float truncation to int, overflow) return errors or silently proceed.

```cpp
namespace x::json {

enum class Type { Number, String, Boolean };

enum class TimeFormat {
    ISO8601,
    UnixSecond,
    UnixMillisecond,
    UnixMicrosecond,
    UnixNanosecond,
};

struct ReadOptions {
    bool strict = false;
    TimeFormat time_format = TimeFormat::ISO8601;
};

// JSON → SampleValue. Inspects value.type() at runtime.
std::pair<telem::SampleValue, errors::Error>
to_sample_value(
    const nlohmann::json& value,
    const telem::DataType& target,
    const ReadOptions& opts = {}
);
```

#### Write Side: `from_sample_value`

`from_sample_value(SampleValue, Type)` converts a Synnax sample value to the specified
JSON type using `std::visit` dispatch on the variant.

`check_from_sample_value(DataType, Type)` validates at config time that the DataType can
be converted to the target JSON Type, returning an error early if unsupported. This is
needed on the write side because the output JSON type is user-configured (not inferred).

```cpp
// Config-time validation.
errors::Error
check_from_sample_value(const telem::DataType& type, Type target);

// Runtime conversion.
std::pair<nlohmann::json, errors::Error>
from_sample_value(const telem::SampleValue& value, Type target);

// Timestamp → JSON in the configured format.
nlohmann::json from_timestamp(telem::TimeStamp ts, TimeFormat format);

// Zero value for a JSON Type (Number → 0, String → "", Boolean → false).
nlohmann::json zero_value(Type format);

}
```

### HTTP Client Wrapper (`driver/http/device/device.h`)

```cpp
namespace http::device {

struct AuthConfig {
    std::string type;  // "none", "api_key", "basic", "bearer"
    std::string header;
    std::string key;
    std::string username;
    std::string password;
    std::string token;

    explicit AuthConfig(xjson::Parser parser);
};

struct ConnectionConfig {
    std::string base_url;
    uint32_t timeout_ms = 30000;
    AuthConfig auth;
    std::unordered_map<std::string, std::string> headers;

    explicit ConnectionConfig(xjson::Parser parser);
};

struct Response {
    long status_code;
    std::string body;
    telem::TimeStamp request_start;
    telem::TimeStamp response_received;
};

struct Request {
    std::string method;  // "GET", "POST", "PUT", "PATCH", "DELETE"
    std::string path;
    std::string body;
    std::unordered_map<std::string, std::string> query_params;
};

// Client wraps libcurl's multi interface for parallel HTTP requests.
// All requests share a connection pool, so multiple endpoints hitting
// the same host reuse keep-alive connections.
struct CURLMDeleter {
    void operator()(CURLM* m) const { curl_multi_cleanup(m); }
};

class Client {
    std::unique_ptr<CURLM, CURLMDeleter> multi_;
    ConnectionConfig config_;

public:
    explicit Client(ConnectionConfig config);

    // Execute a single request.
    std::pair<Response, xerrors::Error> request(const Request& req);

    // Execute multiple requests in parallel using non-blocking I/O.
    // Returns responses in the same order as the input requests.
    std::pair<std::vector<Response>, xerrors::Error>
    request_parallel(const std::vector<Request>& requests);
};

class Manager {
    std::unordered_map<std::string, std::shared_ptr<Client>> clients_;
    std::mutex mutex_;

public:
    std::pair<std::shared_ptr<Client>, xerrors::Error>
    acquire(const ConnectionConfig& config);
};

}
```

### Mock HTTP Server (`driver/http/mock/server.h`)

For unit and integration testing:

```cpp
namespace http::mock {

class Server {
    // cpp-httplib based mock server
public:
    Server(int port);
    ~Server();

    void start();
    void stop();

    // Configure responses
    void on_get(const std::string& path,
                std::function<std::string(const Request&)> handler);
    void on_post(const std::string& path,
                 std::function<std::string(const Request&)> handler);

    // Inspection
    std::vector<Request> received_requests() const;
};

}
```

### Error Types

```cpp
namespace http {

const std::string INTEGRATION_NAME = "http";

namespace errors {
const xerrors::Error CRITICAL = driver::CRITICAL_HARDWARE_ERROR.sub("http");
const xerrors::Error TEMPORARY = driver::TEMPORARY_HARDWARE_ERROR.sub("http");
const xerrors::Error UNREACHABLE = TEMPORARY.sub("unreachable");
const xerrors::Error TIMEOUT = TEMPORARY.sub("timeout");
const xerrors::Error CLIENT_ERROR = CRITICAL.sub("client_error");  // 4xx
const xerrors::Error SERVER_ERROR = TEMPORARY.sub("server_error"); // 5xx
const xerrors::Error PARSE_ERROR = CRITICAL.sub("parse_error");
}

}
```

**Error Mapping:**

- HTTP 2xx → Success
- HTTP 4xx → `CLIENT_ERROR` (CRITICAL - configuration issue, don't retry)
- HTTP 5xx → `SERVER_ERROR` (TEMPORARY - retry with backoff)
- Connection timeout → `TIMEOUT` (TEMPORARY)
- Connection refused → `UNREACHABLE` (TEMPORARY)
- JSON parse failure → `PARSE_ERROR` (CRITICAL)
- Missing field → `PARSE_ERROR` (CRITICAL)

---

## Timestamp Handling

### Read Task Index Resolution

During configuration, the read task resolves which Synnax index channels need to be
written and how their values are sourced. For each field in the task:

1. Look up the field's Synnax channel and its index key
2. Determine the timestamp source for that index:
   - If the field itself **is** the index channel (i.e., `channel` is an index), the
     field's `pointer` is the timestamp source
   - If the field has `time_pointer` set, that pointer is the timestamp source for the
     field's index channel
   - If neither applies, the index uses software timing

3. If multiple fields reference the same index channel, all their timestamp sources must
   resolve to the **same JSON pointer and format**. A mismatch is a configuration error.

### Timestamp Extraction at Runtime

For each index channel that has a resolved JSON pointer:

1. Extract value from the response JSON via the pointer
2. Parse according to the specified `time_format`:
   - `"iso8601"` → Parse ISO 8601 string (e.g., `"2024-01-15T10:30:00.123Z"`)
   - `"unix_sec"` → Interpret as seconds since epoch (integer or decimal)
   - `"unix_ms"` → Interpret as milliseconds since epoch (integer or decimal)
   - `"unix_us"` → Interpret as microseconds since epoch (integer or decimal)
   - `"unix_ns"` → Interpret as integer nanoseconds since epoch (Synnax native)
3. Write the parsed timestamp to the index channel

For index channels using software timing (no `time_pointer` configured):

1. Record `request_start` before HTTP call
2. Record `response_received` after HTTP response
3. Use midpoint: `(request_start + response_received) / 2`

---

## Performance Considerations

### JSON ↔ Synnax Value Conversion

Converters are called once per field per poll cycle. For a task polling 10 endpoints
with 20 fields each at 10 Hz, this is ~2000 conversions/second.

- **Use resolved converters on the hot path.** Call `resolve_read_converter` /
  `resolve_write_converter` once at config time. The returned `std::function` captures
  the exact C++ types — the hot path has no branching on `DataType` (which wraps a
  `std::string`) or `JsonType`.
- **Read converters return a single-sample Series.** The `ReadConvertFn` constructs a
  `telem::Series` directly from the converted value (e.g., `Series(double_value)`),
  avoiding the intermediate `telem::SampleValue` variant and its `std::visit` dispatch.
- **Series allocation is negligible.** Constructing a single-sample Series involves a
  small heap allocation, but this is in the nanosecond range — irrelevant compared to
  HTTP I/O (milliseconds) and JSON parsing (microseconds).
- **Do not re-validate at runtime.** The resolved converter assumes type compatibility
  was already checked at config time by the `resolve_*` call itself (which returns an
  error if the conversion is unsupported).

### Read Task Main Loop

Each poll cycle:

1. Fire HTTP requests to all endpoints in parallel via `curl_multi_*`
2. Parse each response body with `nlohmann::json::parse` (once per response)
3. For each field: extract value via pre-parsed `nlohmann::json_pointer`
4. For each field: call the resolved `ReadConvertFn` to get a single-sample
   `telem::Series`
5. Collect all Series into one `Frame` and write to Synnax in a single batch

**Guidance:**

- JSON parsing (`nlohmann::json::parse`) is the most expensive step. For large response
  bodies, consider parsing once and extracting multiple pointers from the parsed result
  rather than re-parsing.
- JSON Pointer extraction from a parsed `nlohmann::json` object is O(depth) and very
  fast.
- If multiple endpoints are configured, requests are fired in parallel across endpoints
  on each cycle using libcurl's multi interface (`curl_multi_*`). This multiplexes
  multiple easy handles on a single thread with non-blocking I/O, and automatically
  shares the connection pool across handles - so all endpoints hitting the same device
  base_url reuse keep-alive connections. Results are collected before writing to Synnax.

### Write Task Main Loop

The write task main loop is the rate-limited component. `throttle_rate` controls how
often this loop iterates, not the rate of individual HTTP requests. Each iteration of
the loop processes all pending channel values and sends to all configured endpoints.

1. **Wait** for new channel values from Synnax streamer (event-driven)
2. **Rate limit**: If the loop has iterated more recently than `1/throttle_rate` seconds
   ago, sleep until the next allowed iteration
3. **Build** request bodies for all endpoints using current/cached channel values
4. **Send** HTTP requests to all endpoints in parallel via `Client::request_parallel`

For example, with `throttle_rate: 10` and 3 endpoints, the loop runs at most 10
times/second, sending up to 30 HTTP requests/second (3 per iteration, fired in parallel
via libcurl multi).

**Guidance:**

- Request body construction (JSON Pointer set operations) should be fast since the body
  is typically small (<1KB).
- Last-value caching (`on_empty: "last"`) should store converted JSON values, not raw
  Synnax samples, to avoid re-converting on every iteration.

---

## Python Client API

The Python client provides a high-level API for configuring HTTP devices and tasks via
`synnax.http`:

### Device Creation

```python
import synnax as sy
from synnax.http import (
    HTTPDevice, ReadField, ReadEndpoint,
    WriteEndpoint, StaticField, ChannelField, GeneratedField
)

client = sy.Synnax(...)

# Create an HTTP device
device = sy.http.create_device(
    client=client,
    name="my-api-server",
    base_url="https://api.example.com",
    auth={
        "type": "bearer",
        "token": "my-jwt-token"
    },
    headers={
        "X-API-Version": "2"
    },
    timeout_ms=30000
)
```

### Read Task Configuration

```python
# Create channels
index_ch = client.channels.create(
    name="time", data_type=sy.DataType.TIMESTAMP, is_index=True
)
temp_ch = client.channels.create(
    name="temperature", data_type=sy.DataType.FLOAT64, index=index_ch.key
)
status_ch = client.channels.create(
    name="status", data_type=sy.DataType.STRING, index=index_ch.key
)
pressure_ch = client.channels.create(
    name="pressure", data_type=sy.DataType.FLOAT64, index=index_ch.key
)

# Create read task with multiple endpoints
read_task = sy.http.create_read_task(
    client=client,
    device=device,
    name="sensor-poller",
    rate=1.0,  # Hz
    auto_start=False,
    data_saving=True,
    strict=False,
    endpoints=[
        ReadEndpoint(
            path="/api/sensors",
            method="GET",
            query_params={"format": "json"},
            fields=[
                ReadField(
                    pointer="/temperature",
                    channel=temp_ch,
                    type="number",
                    time_pointer="/data/timestamp",
                    time_format="iso8601",
                ),
                ReadField(
                    pointer="/status",
                    channel=status_ch,
                    type="string",
                    time_pointer="/data/timestamp",
                    time_format="iso8601",
                ),
            ],
        ),
        ReadEndpoint(
            path="/api/pressure",
            method="GET",
            fields=[
                # No time_pointer — uses software timing for this field's index
                ReadField(
                    pointer="/value",
                    channel=pressure_ch,
                    type="number",
                ),
            ],
        ),
    ],
)

read_task.start()
```

### Write Task Configuration

```python
setpoint_ch = client.channels.create(
    name="setpoint", data_type=sy.DataType.FLOAT64
)
mode_ch = client.channels.create(name="mode", data_type=sy.DataType.STRING)

write_task = sy.http.create_write_task(
    client=client,
    device=device,
    name="controller",
    auto_start=False,
    data_saving=True,
    throttle_rate=10.0,
    on_empty="last",
    on_initial="zero",
    endpoints=[
        WriteEndpoint(
            path="/api/control",
            method="POST",
            fields=[
                StaticField(pointer="/device_id", value="sensor-001"),
                ChannelField(
                    pointer="/setpoint",
                    channel=setpoint_ch,
                    format="number",
                    time_pointer="/setpoint_timestamp",
                    time_format="unix_ms",
                ),
                GeneratedField(pointer="/request_id", generator="uuid"),
                GeneratedField(
                    pointer="/sent_at",
                    generator="timestamp",
                    format="iso8601",
                ),
            ],
        ),
        WriteEndpoint(
            path="/api/mode",
            method="PUT",
            fields=[
                ChannelField(
                    pointer="",
                    channel=mode_ch,
                    format="string",
                ),
            ],
        ),
    ],
)

write_task.start()
```

### Scan Task Configuration

```python
scan_task = sy.http.create_scan_task(
    client=client,
    device=device,
    name="health-monitor",
    auto_start=True,
    rate=0.1,  # Hz
    path="/health",
    method="GET",
    response={
        "field": "/status",
        "expected_value": "ok"
    }
)
```

---

## Integration Testing

Integration tests follow the existing `TaskCase` → `SimulatorTaskCase` class hierarchy.
The mock HTTP server acts as the "simulator" and is managed via `SimulatorConfig` in
`integration/driver/devices.py`.

### Mock HTTP Server

The mock HTTP server is registered as a simulator in `driver/devices.py`, alongside the
existing Modbus and OPC UA simulators:

```python
# integration/driver/devices.py (additions)
from synnax import http

class KnownDevices:
    @staticmethod
    def http_sim(rack_key: int) -> http.Device:
        """HTTP mock server device configuration."""
        return http.Device(
            base_url="http://127.0.0.1:8080",
            name="HTTP Test Server",
            location="http://127.0.0.1:8080",
            rack=rack_key,
            auth={"type": "none"},
        )

def start_http_server() -> BaseProcess:
    """Start the mock HTTP server in a separate process."""
    process = multiprocessing.Process(target=_run_http_server, daemon=True)
    process.start()
    return process

class Simulator:
    HTTP = SimulatorConfig(
        server_setup=start_http_server,
        startup_delay_seconds=1.0,
        device_factory=KnownDevices.http_sim,
        device_name="HTTP Test Server",
    )
```

The mock server itself (in `integration/examples/http/`) serves configurable JSON
responses, logs received requests, and supports simulating error status codes and
timeouts.

### HTTP Task Base Class

```python
# integration/tests/driver/http/task.py
from abc import abstractmethod
from typing import Any

import synnax as sy
from synnax import http

from driver.devices import Simulator
from tests.driver.simulator_task import SimulatorTaskCase


class HTTPTaskCase(SimulatorTaskCase):
    """
    Base class for HTTP task tests.

    Subclasses implement create_channels() and create() to define
    task-specific channel mappings and task configuration.
    """

    def __init__(
        self,
        *,
        task_name: str,
        **kwargs: Any,
    ) -> None:
        super().__init__(
            task_name=task_name,
            simulator=Simulator.HTTP,
            **kwargs,
        )

    @abstractmethod
    def create_fields(self) -> list[http.ReadField]:
        """Create HTTP-specific task fields."""
        pass
```

### Read Task Test Example

```python
# integration/tests/driver/http/read.py
import synnax as sy
from synnax import http

from tests.driver.http.task import HTTPTaskCase


class HTTPRead(HTTPTaskCase):
    """
    HTTP read task test with a single endpoint.

    Polls /api/sensors and extracts number, string, and boolean fields.
    """

    def __init__(self, **kwargs: object) -> None:
        super().__init__(task_name="HTTP Read", **kwargs)

    def create_fields(self) -> list[http.ReadField]:
        index_c = self.client.channels.create(
            name="http_read_index",
            data_type=sy.DataType.TIMESTAMP,
            is_index=True,
            retrieve_if_name_exists=True,
        )
        return [
            http.ReadField(
                channel=self.client.channels.create(
                    name="http_temperature",
                    data_type=sy.DataType.FLOAT64,
                    index=index_c.key,
                    retrieve_if_name_exists=True,
                ).key,
                pointer="/temperature",
                type="number",
            ),
            http.ReadField(
                channel=self.client.channels.create(
                    name="http_status",
                    data_type=sy.DataType.STRING,
                    index=index_c.key,
                    retrieve_if_name_exists=True,
                ).key,
                pointer="/status",
                type="string",
            ),
        ]

    def create(
        self,
        *,
        device: sy.Device,
        task_name: str,
        sample_rate: sy.Rate,
        stream_rate: sy.Rate,
    ) -> http.ReadTask:
        fields = self.create_fields()
        return http.ReadTask(
            name=task_name,
            device=device.key,
            rate=sample_rate,
            data_saving=True,
            strict=False,
            endpoints=[
                http.ReadEndpoint(
                    path="/api/sensors",
                    method="GET",
                    fields=fields,
                ),
            ],
        )


class HTTPReadMultiEndpoint(HTTPTaskCase):
    """
    HTTP read task test with multiple endpoints.

    Polls /api/temperature and /api/pressure separately.
    """

    def __init__(self, **kwargs: object) -> None:
        super().__init__(
            task_name="HTTP Read Multi-Endpoint", **kwargs
        )

    def create_fields(self) -> list[http.ReadField]:
        index_c = self.client.channels.create(
            name="http_multi_index",
            data_type=sy.DataType.TIMESTAMP,
            is_index=True,
            retrieve_if_name_exists=True,
        )
        return [
            http.ReadField(
                channel=self.client.channels.create(
                    name="http_temp",
                    data_type=sy.DataType.FLOAT64,
                    index=index_c.key,
                    retrieve_if_name_exists=True,
                ).key,
                pointer="/value",
                type="number",
            ),
            http.ReadField(
                channel=self.client.channels.create(
                    name="http_pressure",
                    data_type=sy.DataType.FLOAT64,
                    index=index_c.key,
                    retrieve_if_name_exists=True,
                ).key,
                pointer="/value",
                type="number",
            ),
        ]

    def create(
        self,
        *,
        device: sy.Device,
        task_name: str,
        sample_rate: sy.Rate,
        stream_rate: sy.Rate,
    ) -> http.ReadTask:
        fields = self.create_fields()
        return http.ReadTask(
            name=task_name,
            device=device.key,
            rate=sample_rate,
            data_saving=True,
            strict=False,
            endpoints=[
                http.ReadEndpoint(
                    path="/api/temperature",
                    method="GET",
                    fields=[fields[0]],
                ),
                http.ReadEndpoint(
                    path="/api/pressure",
                    method="GET",
                    fields=[fields[1]],
                ),
            ],
        )
```

---

## Platform Support

All platforms: Windows, Linux, macOS, NI Linux RT

libcurl is available on all platforms. Use Bazel `select()` for any platform-specific
linker flags:

```python
linkopts = select({
    "@platforms//os:windows": ["-lcurl", "ws2_32.lib"],
    "//conditions:default": ["-lcurl"],
})
```

---

## Factory Registration

Add to `driver/rack/factories.cpp`:

```cpp
#include "driver/http/http.h"

void configure_http(const rack::Config& config, FactoryList& factories) {
    configure_integration(config, factories, http::INTEGRATION_NAME, []() {
        return std::make_unique<http::Factory>();
    });
}

// In Config::new_factory():
configure_http(*this, factories);
```

---

## Recommended PR Order

PRs are organized by feature: **Utilities → Device → Read Task → Write Task → Scan
Task**

The first PR establishes the reusable `xjson::convert` utility that the driver depends
on. JSON Pointer functionality is handled by `nlohmann::json_pointer` (built into
nlohmann/json, already in the codebase) and does not need a separate PR. Then each
feature goes through all layers: C++ → Console → Python → Tests → Docs.

---

### Reusable Utilities

#### PR 1: JSON ↔ Synnax Conversion Utility

**Scope:** Type conversion between JSON values and Synnax telemetry types

- `x/cpp/xjson/BUILD.bazel` (update)
- `x/cpp/xjson/convert.h` - `resolve_read_converter`, `resolve_write_converter`,
  `zero_value`
- `x/cpp/xjson/convert.cpp`
- `x/cpp/xjson/convert_test.cpp` - Tests for all supported conversions, resolved
  converters, strict mode, error cases, validation functions, zero values

---

### Device Connection Feature

#### PR 2: C++ Device Foundation

**Scope:** HTTP client infrastructure and driver skeleton

- `MODULE.bazel` - Add libcurl and cpp-httplib dependencies
- `driver/http/BUILD.bazel`
- `driver/http/http.h` (constants, error types)
- `driver/http/device/` - Client, Manager + tests
- `driver/http/mock/` - Mock HTTP server for C++ unit tests

#### PR 3: Console Device Connection

**Scope:** Console UI for connecting to HTTP devices

- `console/src/hardware/http/device/` - Device configuration UI
- Device properties form (base URL, auth, headers)
- Connection testing UI

#### PR 4: Python Client - Device

**Scope:** Python client support for HTTP devices

- `client/py/synnax/http/__init__.py` - HTTP driver package
- `client/py/synnax/http/types.py` - Device type definitions
- `client/py/examples/http/connect_server.py` - Device connection example
- `client/py/examples/http/server.py` - Mock server for examples
- `client/py/tests/test_http.py` - Device unit tests

#### PR 5: Documentation - Get Started

**Scope:** HTTP driver overview and device connection docs

- `docs/site/src/pages/reference/device-drivers/http/get-started.mdx`
- Overview, connection setup, authentication options, headers

---

### Read Task Feature

#### PR 6: C++ Read Task

**Scope:** Read task implementation with multi-endpoint support

- `driver/http/read_task.h/.cpp`
- `driver/http/factory.cpp` (partial - read task only)
- Integration with `driver/rack/factories.cpp`
- `driver/http/read_task_test.cpp`

#### PR 7: Console Read Task

**Scope:** Console UI for read task configuration

- `console/src/hardware/http/task/Read.tsx`
- Multi-endpoint configuration UI
- Channel mapping UI with JSON Pointer input
- Poll rate and strict mode configuration

#### PR 8: Python Client - Read Task

**Scope:** Python client support for HTTP read tasks

- `client/py/synnax/http/read.py` - Read task configuration
- `client/py/examples/http/read_task.py` - Read task example
- Unit tests for read task configuration

#### PR 9: Integration Tests - Read Task

**Scope:** End-to-end read task testing

- `integration/tests/driver/conftest.py` - Shared fixtures, mock HTTP server
- `integration/tests/driver/http_read.py`
  - Polling at various rates
  - Multiple endpoints per task
  - JSON Pointer extraction with nested paths
  - Type conversions (number, string, boolean → numeric, string)
  - Error handling (missing fields, wrong types)
  - Strict mode (float→int truncation)
  - Timestamp extraction with different formats (iso8601, unix_sec, unix_ms, unix_us,
    unix_ns)
  - Configuration-time validation errors (incompatible types, duplicate channels)

#### PR 10: Documentation - Read Task

**Scope:** Read task documentation

- `docs/site/src/pages/reference/device-drivers/http/read-task.mdx`
- Configuration reference, JSON Pointer syntax, type conversions, timestamp formats,
  examples

---

### Write Task Feature

#### PR 11: C++ Write Task

**Scope:** Write task implementation with multi-endpoint support

- `driver/http/write_task.h/.cpp`
- `driver/http/util/request_builder.h/.cpp` + tests
- Update factory for write task
- `driver/http/write_task_test.cpp`

#### PR 12: Console Write Task

**Scope:** Console UI for write task configuration

- `console/src/hardware/http/task/Write.tsx`
- Multi-endpoint configuration UI
- Request body builder UI (static, channel, generated fields)
- Throttle rate and missing value behavior configuration

#### PR 13: Python Client - Write Task

**Scope:** Python client support for HTTP write tasks

- `client/py/synnax/http/write.py` - Write task configuration
- `client/py/examples/http/write_task.py` - Write task example
- Unit tests for write task configuration

#### PR 14: Integration Tests - Write Task

**Scope:** End-to-end write task testing

- `integration/tests/driver/http_write.py`
  - Event-driven writes with throttling
  - Multiple endpoints per task
  - JSON body construction (object and primitive)
  - Static, channel, and generated fields
  - Type conversions (numeric, string → number, string, boolean)
  - `on_empty` behavior (omit vs zero vs error vs last)
  - `on_initial` behavior (zero vs omit)
  - Configuration-time validation errors (incompatible types, duplicate pointers)

#### PR 15: Documentation - Write Task

**Scope:** Write task documentation

- `docs/site/src/pages/reference/device-drivers/http/write-task.mdx`
- Configuration reference, field types, request body construction, examples

---

### Scan Task Feature

#### PR 16: C++ Scan Task

**Scope:** Health monitoring scan task

- `driver/http/scan_task.h/.cpp`
- Update factory for scan task
- `driver/http/scan_task_test.cpp`

#### PR 17: Console Scan Task

**Scope:** Console UI for scan task configuration

- `console/src/hardware/http/task/Scan.tsx`
- Health endpoint configuration UI
- Expected response validation UI

#### PR 18: Python Client - Scan Task

**Scope:** Python client support for HTTP scan tasks

- `client/py/synnax/http/scan.py` - Scan task configuration
- `client/py/examples/http/scan_task.py` - Scan task example
- Unit tests for scan task configuration

#### PR 19: Integration Tests - Scan Task

**Scope:** End-to-end scan task testing

- `integration/tests/driver/http_scan.py`
  - Health checks with HTTP status only
  - Health checks with response validation
  - Device status updates on success/failure

#### PR 20: Documentation - Scan Task

**Scope:** Scan task documentation

- `docs/site/src/pages/reference/device-drivers/http/scan-task.mdx`
- Health check configuration, response validation, monitoring setup

---

## Key Files to Reference

### Driver Patterns

- `/driver/modbus/` - Modbus TCP/IP (similar network protocol)
- `/driver/opc/` - OPC UA (connection pooling pattern)
- `/driver/task/common/read_task.h` - Base read task
- `/driver/task/common/write_task.h` - Base write task
- `/driver/task/common/sample_clock.h` - SoftwareTimedSampleClock
- `/driver/task/task.h` - Task, Factory, Context interfaces
- `/driver/pipeline/acquisition.h` - Acquisition pipeline
- `/driver/errors/errors.h` - Error hierarchy
- `/x/cpp/xjson/xjson.h` - JSON configuration parsing

### Console Patterns

- `/console/src/hardware/opc/` - OPC UA device/task UI
- `/console/src/hardware/modbus/` - Modbus device/task UI
- `/console/src/hardware/ni/` - National Instruments UI patterns

### Documentation Patterns

- `/docs/site/src/pages/reference/device-drivers/opc-ua/` - OPC UA docs structure
- `/docs/site/src/pages/reference/device-drivers/` - Other driver docs

---

## Open Questions / Future Enhancements

1. **Array-to-Series**: Support mapping JSON arrays to multiple samples in a series
2. **Per-Endpoint Headers**: Allow header overrides per endpoint
3. **Write Response Parsing**: Optionally parse write responses for state feedback
4. **Webhook Support**: HTTP server mode for receiving push notifications
5. **WebSocket Support**: Streaming data over WebSocket connections
6. **Certificate Configuration**: Custom CA certs, client certs for mTLS
7. **More Granular Timeouts**: Separate connect, read, total timeouts
8. **JSON/UUID/Bytes Synnax Types**: Support additional Synnax channel types
9. **String-to-Number Parsing**: Parse numeric strings if demand warrants the complexity

---

## Summary of Design Decisions

| Decision              | Choice                                               | Rationale                                                          |
| --------------------- | ---------------------------------------------------- | ------------------------------------------------------------------ |
| HTTP Library          | libcurl (Bazel module)                               | Industry standard, cross-platform, TLS support                     |
| Data Format           | JSON only                                            | Most common, nlohmann/json already in codebase                     |
| JSON Types            | number, string, boolean only                         | Keeps conversion simple; objects/arrays/nulls not needed as fields |
| Synnax Types          | Numeric + String only                                | Covers primary use cases; UUID/Bytes/JSON deferred                 |
| Authentication        | None/API Key/Basic/Bearer                            | Covers 95%+ of REST APIs                                           |
| Field Extraction      | JSON Pointer (RFC 6901) via `nlohmann::json_pointer` | Standardized, built into nlohmann/json, no custom utility needed   |
| JSON Convert Location | `x/cpp/xjson/convert.h`                              | Reusable utility, not HTTP-specific                                |
| Write Body Type       | Object or Primitive                                  | Supports both JSON objects and single values                       |
| String→Number         | Not supported                                        | Error-prone parsing; users should use String channels              |
| Strict Mode           | Task-level setting                                   | Simpler than per-field; consistent behavior across all channels    |
| Read Timing           | Single rate in Hz                                    | Simpler than sample_rate/stream_rate for low-frequency polling     |
| Write Timing          | Event-driven + throttle                              | Responsive but prevents overwhelming server                        |
| Endpoints per Task    | Multiple                                             | Reduces task count; related endpoints grouped together             |
| Timestamps            | Midpoint default, configurable format per endpoint   | Balance accuracy with flexibility                                  |
| Error Handling        | 4xx=CRITICAL, 5xx=TEMPORARY                          | Match HTTP semantics to driver error model                         |
| Scan Task Pattern     | User-configurable, start/stop                        | Unlike other drivers where scan is automatic                       |
| Config Validation     | Type compat + uniqueness at configuration time       | Fail fast rather than runtime surprises                            |
| PR Structure          | 20 PRs (Utilities → Device → Read → Write → Scan)    | Utilities first, then incremental delivery by feature              |
