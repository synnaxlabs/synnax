# 26 - Jerky: Declarative Protobuf Generation and Schema Migration

- **Feature Name**: Jerky - Declarative Protobuf Generation and Schema Migration
- **Status**: Draft
- **Start Date**: 2025-11-26
- **Authors**: Emiliano Bonilla

# 0 - Summary

This RFC proposes `jerky`, a code generation tool that derives protobuf definitions and
translation functions from Go struct definitions. Jerky treats Go structs as the single
source of truth for data structures, automatically generating:

1. Protobuf message definitions (`.proto` files)
2. Forward/backward translation functions between Go and protobuf types
3. Version-aware migration infrastructure for schema evolution

Jerky eliminates the manual synchronization burden between Go domain types, protobuf
wire formats, and translation boilerplate—a pattern that currently requires maintaining
three parallel definitions that must stay perfectly aligned.

# 1 - Vocabulary

- **Domain Struct**: The canonical Go struct definition that serves as the source of
  truth for a data type. Annotated with `//go:generate jerky`.
- **Version Snapshot**: An immutable copy of a domain struct at a specific version,
  stored in the `types/` subdirectory.
- **Forward Translation**: Converting a Go domain struct to its protobuf representation
  (for serialization/transmission).
- **Backward Translation**: Converting a protobuf message to a Go domain struct (for
  deserialization/reception).
- **Migration**: The process of converting data from one version snapshot to another,
  executed at application startup.
- **Bootstrap Migration**: A special migration that converts pre-jerky data (msgpack
  encoded) to the first jerky-managed version.

# 2 - Motivation

## 2.0 - The Synchronization Problem

Synnax's Go codebase extensively uses protobuf for both network transport (gRPC) and
data serialization. The current workflow requires maintaining three parallel
definitions:

```
1. Go domain struct     → The "real" type used in business logic
2. Proto message        → The wire/storage format definition
3. Translation funcs    → Forward() and Backward() to convert between them
```

Every field addition, removal, or type change requires updates to all three locations.
There is no compile-time protection against drift—a forgotten translation line silently
drops data.

## 2.1 - Scale of the Problem

Analysis of the current codebase reveals:

| Package | Translator Structs | Translation Functions |
|---------|-------------------|----------------------|
| `api/grpc/channel.go` | ~10 | ~20 |
| `api/grpc/framer.go` | ~8 | ~16 |
| `api/grpc/ranger.go` | ~6 | ~12 |
| `x/go/telem/pb.go` | 0 | 8 |

Each field in each struct requires:
- A line in the `.proto` file
- A line in `Forward()`: `ProtoField: GoType(msg.Field)`
- A line in `Backward()`: `Field: GoType(msg.ProtoField)`

This is pure mechanical boilerplate with no business logic.

## 2.2 - The Wrong Direction of Derivation

The current workflow treats proto files as independent artifacts that happen to mirror
Go structs. The natural relationship is:

```
Go struct (source of truth)
        ↓ derive
Proto definition + Translation functions
```

Go structs define the domain model. Protobuf is merely a serialization format. Jerky
codifies this relationship.

## 2.3 - Schema Evolution

Beyond synchronization, the codebase lacks systematic schema migration. When a struct
changes:

- How is existing persisted data handled?
- How do we ensure backward compatibility during rolling deployments?
- How do we track which version of a schema was used to write data?

Jerky addresses these by treating versioned snapshots as first-class artifacts with
explicit migration paths.

# 3 - Philosophy

## 3.0 - Go as Source of Truth

The Go domain struct is the canonical definition. All other representations (proto,
translations, migrations) are derived artifacts. Developers never manually edit
generated files.

## 3.1 - Declarative Over Imperative

Migrations are declared by the difference between version snapshots, not by imperative
migration scripts. Jerky computes the diff and generates migration code automatically
where possible.

## 3.2 - Fail-Safe Defaults

When jerky cannot automatically migrate a change (e.g., incompatible type conversion),
it fails at generation time with a clear error, not at runtime with data corruption.

## 3.3 - Unified Encoding

Protobuf serves as the single encoding format for both network transport (gRPC) and
persistent storage (gorp). This eliminates the current split between msgpack (storage)
and protobuf (network).

## 3.4 - Static Analysis

Jerky uses AST parsing, not runtime reflection. All code generation happens at build
time with full type information available.

# 4 - Design Overview

## 4.0 - High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     Developer Workflow                       │
├─────────────────────────────────────────────────────────────┤
│  1. Define/modify Go struct with //go:generate jerky        │
│  2. Run `go generate ./...`                                 │
│  3. Jerky generates types/, proto, translations, migrations │
│  4. Commit generated files                                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Generated Artifacts                       │
├─────────────────────────────────────────────────────────────┤
│  package/                                                   │
│  ├── domain.go              # Source of truth (developer)   │
│  ├── domain_gorp.go         # MarshalGorp/UnmarshalGorp     │
│  └── types/                 # Generated (jerky)             │
│      ├── jerky.state.json   # Version tracking              │
│      ├── v1.go              # Version 1 snapshot            │
│      ├── v1.pb.go           # Proto-generated Go code       │
│      ├── v1_translate.go    # Translation functions         │
│      ├── v2.go              # Version 2 snapshot            │
│      ├── v2.pb.go           #                               │
│      ├── v2_translate.go    #                               │
│      ├── migrations.go      # Migration orchestration       │
│      └── current.go         # Alias to latest version       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Runtime Behavior                          │
├─────────────────────────────────────────────────────────────┤
│  1. Application starts                                      │
│  2. Check migration metadata: "__migrations__/TypeName"     │
│  3. If version < current, run migrations in transaction     │
│  4. Update migration metadata                               │
│  5. Accept requests                                         │
└─────────────────────────────────────────────────────────────┘
```

## 4.1 - Component Overview

### 4.1.0 - Jerky Library

Core logic as an importable Go library (`github.com/synnaxlabs/x/go/jerky`):

- AST parser for Go struct analysis
- Proto file generator
- Translation function generator
- Migration diff calculator
- Migration code generator

### 4.1.1 - Jerky CLI

Thin wrapper around the library:

```bash
jerky generate ./...           # Generate for all packages
jerky generate ./medication    # Generate for specific package
jerky status                   # Show pending migrations
jerky version                  # Show tool version
```

### 4.1.2 - Runtime Migration Executor

Library code that runs at application startup:

```go
import "github.com/synnaxlabs/x/go/jerky/migrate"

func main() {
    db := openDatabase()
    if err := migrate.Run(db, medication.Migrations); err != nil {
        log.Fatal(err)
    }
    // ... start application
}
```

# 5 - Detailed Design

## 5.0 - Annotation Syntax

Domain structs are annotated with a `go:generate` directive:

```go
package medication

import (
    "github.com/google/uuid"
    "github.com/synnaxlabs/x/gorp"
)

//go:generate jerky
type Medication struct {
    Key      uuid.UUID `json:"key"`
    Name     string    `json:"name"`
    Duration int       `json:"duration"`
}

var _ gorp.Entry[uuid.UUID] = Medication{}

func (m Medication) GorpKey() uuid.UUID { return m.Key }
func (m Medication) SetOptions() []any  { return nil }
```

### 5.0.0 - Auto-Versioning

Jerky automatically detects when a struct changes and increments the version. No
manual version annotation is required. When the struct changes:

```go
//go:generate jerky
type Medication struct {
    Key      uuid.UUID `json:"key"`
    Name     string    `json:"name"`
    Duration int       `json:"duration"`
    Dosage   float64   `json:"dosage"`  // New field - jerky auto-detects
}
```

Jerky detects changes by:
1. Computing a hash of the struct's fields, types, and field order
2. Comparing to the previous hash stored in `types/jerky.state.json`
3. If different, automatically incrementing the version number
4. Generating new version artifacts (snapshot, proto, translations, migration)

This eliminates manual version management errors (forgetting to increment, wrong
number, etc.) while maintaining explicit version history in the state file.

## 5.1 - Generated Directory Structure

Running `go generate` produces:

```
medication/
├── medication.go           # Source of truth (unchanged by developer)
├── medication_gorp.go      # Generated: MarshalGorp/UnmarshalGorp methods
└── types/
    ├── jerky.state.json    # Version tracking and dependency hashes
    ├── jerky.go            # Package documentation, DO NOT EDIT header
    ├── v1.go               # Version 1 struct snapshot (Go native types)
    ├── v1.proto            # Proto definition for v1
    ├── v1.pb.go            # protoc-generated code (proto types)
    ├── v1_translate.go     # TranslateMedicationV1Forward/Backward
    ├── v2.go               # Version 2 struct snapshot
    ├── v2.proto            # Proto definition for v2
    ├── v2.pb.go            # protoc-generated code
    ├── v2_translate.go     # TranslateMedicationV2Forward/Backward
    ├── v1_to_v2.go         # Migration from v1 to v2
    ├── migrations.go       # Migration registry and executor
    └── current.go          # Type aliases to latest version
```

Note: `v1.go` contains Go native types (e.g., `uuid.UUID`, `channel.Key`) while
`v1.pb.go` contains proto-compatible types (e.g., `string`, `uint32`). Both are
needed: the Go snapshot for migration functions to work with native types, and
the proto types for wire serialization.

## 5.2 - Version Snapshot Generation

Each version snapshot is an immutable copy of the struct at that version:

```go
// types/v1.go
// Code generated by jerky. DO NOT EDIT.

package types

import "github.com/google/uuid"

type MedicationV1 struct {
    Key      uuid.UUID
    Name     string
    Duration int
}
```

```go
// types/v2.go
// Code generated by jerky. DO NOT EDIT.

package types

import "github.com/google/uuid"

type MedicationV2 struct {
    Key      uuid.UUID
    Name     string
    Duration int
    Dosage   float64
}
```

## 5.3 - Proto Generation

Jerky generates proto files with field numbers based on struct field order:

```protobuf
// types/v1.proto
// Code generated by jerky. DO NOT EDIT.

syntax = "proto3";

package medication.types;

option go_package = "github.com/synnaxlabs/synnax/medication/types";

message MedicationV1 {
    string key = 1;       // uuid.UUID -> string
    string name = 2;
    int64 duration = 3;   // int -> int64
}
```

```protobuf
// types/v2.proto
// Code generated by jerky. DO NOT EDIT.

syntax = "proto3";

package medication.types;

option go_package = "github.com/synnaxlabs/synnax/medication/types";

message MedicationV2 {
    string key = 1;
    string name = 2;
    int64 duration = 3;
    double dosage = 4;    // float64 -> double
}
```

### 5.3.0 - Type Mapping Rules

Jerky maps Go types to proto types following these rules:

| Go Type | Proto Type | Notes |
|---------|------------|-------|
| `bool` | `bool` | Direct |
| `int`, `int64` | `int64` | Widened to 64-bit |
| `int32` | `int32` | Direct |
| `int8`, `int16` | `int32` | Widened |
| `uint`, `uint64` | `uint64` | Widened to 64-bit |
| `uint32` | `uint32` | Direct |
| `uint8`, `uint16` | `uint32` | Widened |
| `float32` | `float` | Direct |
| `float64` | `double` | Direct |
| `string` | `string` | Direct |
| `[]byte` | `bytes` | Direct |
| `uuid.UUID` | `string` | UUID string representation |
| `time.Time` | `int64` | Unix nanoseconds |
| `time.Duration` | `int64` | Nanoseconds |
| `[]T` | `repeated T` | Recursive |
| `map[K]V` | `map<K, V>` | Key must be scalar |
| Custom primitive wrapper | Underlying type | e.g., `type Key uint32` → `uint32` |
| Struct with jerky | Import message | Must have own jerky generation |

### 5.3.1 - Nested Struct Handling

When a struct contains a field that is another jerky-managed struct, jerky generates
an import:

```go
//go:generate jerky
type Prescription struct {
    ID         uuid.UUID
    Medication medication.Medication  // External jerky-managed type
    Patient    string
}
```

Generated proto:

```protobuf
syntax = "proto3";

package prescription.types;

import "medication/types/v1.proto";  // Derived from Go import path

message PrescriptionV1 {
    string id = 1;
    medication.types.MedicationV1 medication = 2;
    string patient = 3;
}
```

Jerky derives the proto import path from the Go package path using convention:
`github.com/synnaxlabs/synnax/medication` → `medication/types/vN.proto`

## 5.4 - Translation Function Generation

Jerky generates standalone translation functions (not Translator interface
implementations):

```go
// types/v2_translate.go
// Code generated by jerky. DO NOT EDIT.

package types

import (
    "github.com/google/uuid"
    "github.com/synnaxlabs/synnax/medication"
)

// TranslateMedicationV2Forward converts a domain Medication to its proto representation.
func TranslateMedicationV2Forward(m medication.Medication) *MedicationV2 {
    return &MedicationV2{
        Key:      m.Key.String(),
        Name:     m.Name,
        Duration: int64(m.Duration),
        Dosage:   m.Dosage,
    }
}

// TranslateMedicationV2Backward converts a proto MedicationV2 to the domain type.
func TranslateMedicationV2Backward(m *MedicationV2) (medication.Medication, error) {
    key, err := uuid.Parse(m.Key)
    if err != nil {
        return medication.Medication{}, err
    }
    return medication.Medication{
        Key:      key,
        Name:     m.Name,
        Duration: int(m.Duration),
        Dosage:   m.Dosage,
    }, nil
}

// TranslateManyMedicationV2Forward converts a slice of domain Medications.
func TranslateManyMedicationV2Forward(ms []medication.Medication) []*MedicationV2 {
    result := make([]*MedicationV2, len(ms))
    for i, m := range ms {
        result[i] = TranslateMedicationV2Forward(m)
    }
    return result
}

// TranslateManyMedicationV2Backward converts a slice of proto MedicationV2s.
func TranslateManyMedicationV2Backward(ms []*MedicationV2) ([]medication.Medication, error) {
    result := make([]medication.Medication, len(ms))
    for i, m := range ms {
        var err error
        result[i], err = TranslateMedicationV2Backward(m)
        if err != nil {
            return nil, err
        }
    }
    return result, nil
}
```

### 5.4.0 - Error Handling in Translation

Backward translation returns an error because:
- String → UUID parsing can fail
- Nested struct translation can fail
- Future: validation rules may fail

Forward translation does not return an error because Go types are already valid.

## 5.5 - Current Version Aliasing

The `current.go` file provides convenient aliases to the latest version:

```go
// types/current.go
// Code generated by jerky. DO NOT EDIT.

package types

import "github.com/synnaxlabs/synnax/medication"

// Current version: 2

type Medication = MedicationV2

var (
    TranslateMedicationForward      = TranslateMedicationV2Forward
    TranslateMedicationBackward     = TranslateMedicationV2Backward
    TranslateManyMedicationForward  = TranslateManyMedicationV2Forward
    TranslateManyMedicationBackward = TranslateManyMedicationV2Backward
)

// CurrentVersion is the latest schema version for Medication.
const CurrentVersion = 2
```

This allows callers to use `types.Medication` and `types.TranslateMedicationForward`
without hard-coding version numbers.

## 5.6 - Migration Generation

### 5.6.0 - Automatic Migration

Jerky computes the diff between consecutive versions and generates migration code:

```go
// types/v1_to_v2.go
// Code generated by jerky. DO NOT EDIT.

package types

// MigrateMedicationV1ToV2 migrates a MedicationV1 to MedicationV2.
func MigrateMedicationV1ToV2(v1 *MedicationV1) *MedicationV2 {
    return &MedicationV2{
        Key:      v1.Key,
        Name:     v1.Name,
        Duration: v1.Duration,
        Dosage:   0,  // New field: zero value
    }
}
```

### 5.6.1 - Automatic Migration Rules

Jerky can automatically migrate:

| Change | Migration |
|--------|-----------|
| Field added | Zero value for new field |
| Field removed | Silent drop (field ignored) |
| Field renamed | Requires annotation (see 5.6.2) |
| `int` → `int64` | Widening cast |
| `int32` → `int64` | Widening cast |
| `float32` → `float64` | Widening cast |
| Compatible numeric | Safe conversion |

### 5.6.2 - Manual Migration

When automatic migration is not possible, jerky requires a developer-provided function:

```go
// medication.go

//go:generate jerky
type Medication struct {
    Key      uuid.UUID
    Name     string
    Duration int
    DosageMg float64  // Renamed from Dosage, unit changed (jerky auto-detects v3)
}

// JerkyMigrateV2ToV3 is called by jerky when migrating from v2 to v3.
// This function is required because DosageMg cannot be auto-migrated from Dosage.
func JerkyMigrateV2ToV3(v2 *types.MedicationV2) *types.MedicationV3 {
    return &types.MedicationV3{
        Key:      v2.Key,
        Name:     v2.Name,
        Duration: v2.Duration,
        DosageMg: v2.Dosage * 1000,  // Convert grams to milligrams
    }
}
```

Jerky detects this function by naming convention: `JerkyMigrateV{N}ToV{N+1}`.

If a change cannot be auto-migrated and no manual function exists, jerky fails at
generation time with a clear error:

```
jerky: medication.go: cannot auto-migrate field "DosageMg" from v2 to v3:
  - field "Dosage" (float64) was removed
  - field "DosageMg" (float64) was added
  hint: provide func JerkyMigrateV2ToV3(*types.MedicationV2) *types.MedicationV3
```

### 5.6.3 - Migration Override

Developers can override automatic migration even when it would succeed:

```go
// Force manual migration even though types are compatible
func JerkyMigrateV1ToV2(v1 *types.MedicationV1) *types.MedicationV2 {
    return &types.MedicationV2{
        Key:      v1.Key,
        Name:     strings.ToUpper(v1.Name),  // Custom: uppercase all names
        Duration: v1.Duration,
        Dosage:   100.0,  // Custom: default dosage instead of zero
    }
}
```

### 5.6.4 - Migration Registry

```go
// types/migrations.go
// Code generated by jerky. DO NOT EDIT.

package types

import (
    "context"
    "github.com/synnaxlabs/x/go/jerky/migrate"
    "github.com/synnaxlabs/x/gorp"
)

// Migrations is the migration registry for Medication.
var Migrations = migrate.Registry{
    TypeName:       "Medication",
    CurrentVersion: 2,
    Migrations: []migrate.Migration{
        {
            FromVersion: 0,  // Bootstrap: pre-jerky msgpack data
            ToVersion:   1,
            Migrate:     migrateBootstrapToV1,
        },
        {
            FromVersion: 1,
            ToVersion:   2,
            Migrate:     func(data []byte) ([]byte, error) {
                v1, err := unmarshalMedicationV1(data)
                if err != nil {
                    return nil, err
                }
                v2 := MigrateMedicationV1ToV2(v1)
                return marshalMedicationV2(v2)
            },
        },
    },
}

func migrateBootstrapToV1(data []byte) ([]byte, error) {
    // Decode msgpack-encoded pre-jerky data
    var legacy medication.Medication
    if err := msgpack.Unmarshal(data, &legacy); err != nil {
        return nil, err
    }
    v1 := TranslateMedicationV1Forward(legacy)
    return marshalMedicationV1(v1)
}
```

## 5.7 - Nested Types and Dependency Management

Synnax types frequently embed other types. When an embedded type changes, all types
that contain it must also be migrated. Jerky handles this through automatic dependency
tracking and version cascading.

### 5.7.0 - Type Categories

**Storage Types**: Types that are persisted as independent records in the database.
They implement `gorp.Entry` and have their own keys. Examples: `Channel`, `Frame`,
`Medication`.

**Embedded Types**: Types that only exist serialized inside storage types. They are
never stored as standalone records. Examples: `TimeRange`, `Series`, `Subject`.

Jerky generates the same artifacts (proto, translations, migrations) for both
categories. The distinction only matters at runtime when deciding which types to
register with the migration coordinator.

### 5.7.1 - Dependency Graph

Consider this type hierarchy:

```go
// telem/time_range.go
//go:generate jerky
type TimeRange struct {
    Start TimeStamp
    End   TimeStamp
}

// telem/series.go
//go:generate jerky
type Series struct {
    TimeRange TimeRange  // Embeds TimeRange
    DataType  DataType
    Data      []byte
}

// channel/channel.go
//go:generate jerky
type Channel struct {
    Key       Key
    Name      string
    TimeRange telem.TimeRange  // Embeds TimeRange
}

// framer/frame.go
//go:generate jerky
type Frame struct {
    Keys   []channel.Key
    Series []telem.Series  // Embeds Series (which embeds TimeRange)
}
```

This creates a dependency graph:

```
TimeRange (leaf)
    ↑
    ├── Series
    │       ↑
    │       └── Frame
    └── Channel
```

### 5.7.2 - Version Cascade

When a type changes, all types that embed it must also get new versions. This is
called **version cascading**.

**Example**: `TimeRange` adds a `Timezone` field (v1 → v2):

```
TimeRange v1 → v2 (field added)
    triggers cascade:
Series v1 → v2 (dependency changed)
Channel v3 → v4 (dependency changed)
Frame v1 → v2 (transitive: Series changed)
```

Jerky detects this automatically by:
1. Computing a hash of each type's fields
2. Computing a hash of each dependency's current version
3. Combining into a composite hash
4. Comparing to the previous composite hash
5. If different, incrementing the version

### 5.7.3 - State File

Jerky maintains a state file to track versions and dependencies:

```json
// types/jerky.state.json
{
  "type": "Channel",
  "package": "github.com/synnaxlabs/synnax/channel",
  "current_version": 4,
  "history": [
    {
      "version": 3,
      "created_at": "2025-11-20T10:00:00Z",
      "struct_hash": "a1b2c3d4",
      "dependency_versions": {
        "github.com/synnaxlabs/x/go/telem.TimeRange": 1
      },
      "composite_hash": "e5f6g7h8"
    },
    {
      "version": 4,
      "created_at": "2025-11-26T14:30:00Z",
      "struct_hash": "a1b2c3d4",
      "dependency_versions": {
        "github.com/synnaxlabs/x/go/telem.TimeRange": 2
      },
      "composite_hash": "i9j0k1l2"
    }
  ]
}
```

Key observations:
- `struct_hash` is the same for v3 and v4 (Channel's own fields didn't change)
- `dependency_versions` shows TimeRange went from 1 to 2
- This triggered Channel's version bump from 3 to 4

The state file is committed to version control, providing:
- Visibility into version history
- Clear PR diffs showing what changed
- Reproducible builds (same source → same versions)

### 5.7.4 - Nested Migration Functions

Jerky generates two types of migration functions:

**Struct-level migrations** (for all types):

```go
// telem/types/v1_to_v2.go
func MigrateTimeRangeV1ToV2(v1 *TimeRangeV1) *TimeRangeV2 {
    return &TimeRangeV2{
        Start:    v1.Start,
        End:      v1.End,
        Timezone: "",  // New field: zero value
    }
}
```

**Composite migrations** (call into nested migrations):

```go
// channel/types/v3_to_v4.go
func MigrateChannelV3ToV4(v3 *ChannelV3) *ChannelV4 {
    return &ChannelV4{
        Key:       v3.Key,
        Name:      v3.Name,
        // Call nested migration for embedded type
        TimeRange: telem.MigrateTimeRangeV1ToV2(v3.TimeRange),
    }
}
```

**Byte-level wrappers** (for storage types, used by coordinator):

```go
// channel/types/migrations.go
func migrateChannelV3ToV4Bytes(data []byte) ([]byte, error) {
    v3, err := unmarshalChannelV3(data)
    if err != nil {
        return nil, err
    }
    v4 := MigrateChannelV3ToV4(v3)
    return marshalChannelV4(v4)
}
```

### 5.7.5 - Migration Execution Order

The migration coordinator executes migrations in topological order (leaves first):

```go
coordinator := migrate.NewCoordinator(
    channel.Migrations,
    framer.Migrations,
    // Note: telem.TimeRange and telem.Series are NOT registered
    // because they're embedded-only (no standalone records)
)

// Coordinator determines order:
// 1. Channel records (embeds TimeRange directly)
// 2. Frame records (embeds Series which embeds TimeRange)
//
// TimeRange migration happens INSIDE Channel/Frame migrations,
// not as a separate step.
```

For deeply nested types like `Frame` → `Series` → `TimeRange`:

```go
func MigrateFrameV1ToV2(v1 *FrameV1) *FrameV2 {
    series := make([]*telem.SeriesV2, len(v1.Series))
    for i, s := range v1.Series {
        // Series migration internally calls TimeRange migration
        series[i] = telem.MigrateSeriesV1ToV2(s)
    }
    return &FrameV2{
        Keys:   v1.Keys,
        Series: series,
    }
}

func MigrateSeriesV1ToV2(v1 *SeriesV1) *SeriesV2 {
    return &SeriesV2{
        TimeRange: MigrateTimeRangeV1ToV2(v1.TimeRange),
        DataType:  v1.DataType,
        Data:      v1.Data,
    }
}
```

### 5.7.6 - Non-Jerky Dependencies

If a type embeds a struct that doesn't use jerky (third-party, stdlib, etc.), jerky
cannot track its changes. Two options:

**Option 1: Wrap in jerky-managed type**

```go
// Instead of embedding time.Time directly:
type Medication struct {
    CreatedAt time.Time  // Can't track changes
}

// Wrap it:
//go:generate jerky
type Timestamp struct {
    Value time.Time
}

type Medication struct {
    CreatedAt Timestamp  // Now trackable
}
```

**Option 2: Treat as stable**

If the non-jerky type is unlikely to change (e.g., `uuid.UUID`), jerky treats it as
a stable primitive. Changes to its internal representation won't trigger cascades.

Jerky emits a warning for non-jerky embedded structs:

```
jerky: warning: Medication embeds time.Time which is not jerky-managed.
  Changes to time.Time will not trigger version cascades.
  Consider wrapping in a jerky-managed type if migration support is needed.
```

### 5.7.7 - Circular Dependencies

Circular embedding is impossible in Go (would create infinite-size struct). However,
circular references via pointers are possible:

```go
type A struct {
    B *B
}

type B struct {
    A *A
}
```

Jerky detects circular dependencies in the version cascade graph and errors:

```
jerky: error: circular dependency detected: A → B → A
  Circular dependencies are not supported.
```

If pointer-based cycles are needed, break the cycle by using a key reference instead
of embedding:

```go
type A struct {
    BKey uuid.UUID  // Reference by key, not embedding
}
```

## 5.8 - Runtime Migration Execution

### 5.8.0 - Migration Metadata

Jerky tracks migration state in the database using a metadata key:

```
Key:   "__jerky__/Medication"
Value: { "version": 2, "migrated_at": "2025-11-26T10:30:00Z" }
```

### 5.8.1 - Startup Migration Flow

```go
func (m *Migrator) Run(ctx context.Context, db *gorp.DB) error {
    return db.WithTx(ctx, func(tx gorp.Tx) error {
        // 1. Read current version from metadata
        currentVersion, err := m.readVersion(tx)
        if err != nil {
            return err
        }

        // 2. If up to date, nothing to do
        if currentVersion >= m.registry.CurrentVersion {
            return nil
        }

        // 3. Run migrations sequentially
        for _, migration := range m.registry.Migrations {
            if migration.FromVersion < currentVersion {
                continue  // Already applied
            }
            if err := m.runMigration(tx, migration); err != nil {
                return err  // Transaction rollback
            }
        }

        // 4. Update metadata
        return m.writeVersion(tx, m.registry.CurrentVersion)
    })
}

func (m *Migrator) runMigration(tx gorp.Tx, migration migrate.Migration) error {
    // Iterate all records of this type
    iter := tx.NewIterator(m.registry.TypeName)
    defer iter.Close()

    for iter.Next() {
        oldData := iter.Value()
        newData, err := migration.Migrate(oldData)
        if err != nil {
            return err
        }
        if err := tx.Set(iter.Key(), newData); err != nil {
            return err
        }
    }
    return iter.Error()
}
```

### 5.8.2 - Bootstrap Migration

For types that existed before jerky adoption, the first migration (v0 → v1) handles
msgpack-encoded data:

```go
{
    FromVersion: 0,  // Special: pre-jerky
    ToVersion:   1,
    Migrate:     func(data []byte) ([]byte, error) {
        // Try msgpack first (legacy format)
        var legacy Medication
        if err := msgpack.Unmarshal(data, &legacy); err != nil {
            // Maybe already proto? Try that.
            if _, err := unmarshalMedicationV1(data); err == nil {
                return data, nil  // Already migrated
            }
            return nil, errors.Newf("unknown data format: %w", err)
        }
        v1 := TranslateMedicationV1Forward(legacy)
        return marshalMedicationV1(v1)
    },
}
```

## 5.9 - gorp Integration

The Go domain struct remains the type that implements `gorp.Entry`. Jerky generates
`MarshalGorp` and `UnmarshalGorp` methods on the domain struct in a separate file,
following Go's pattern of allowing methods to be defined across multiple files in
the same package.

### 5.9.0 - Domain Struct (Unchanged)

```go
// medication.go - written by developer, unchanged by jerky

type Medication struct {
    Key      uuid.UUID
    Name     string
    Duration int
}

var _ gorp.Entry[uuid.UUID] = Medication{}

func (m Medication) GorpKey() uuid.UUID { return m.Key }
func (m Medication) SetOptions() []any  { return nil }
```

### 5.9.1 - Generated Gorp Methods

Jerky generates a separate file with serialization methods:

```go
// medication_gorp.go - generated by jerky, DO NOT EDIT

package medication

import (
    "github.com/synnaxlabs/synnax/medication/types"
    "google.golang.org/protobuf/proto"
)

// MarshalGorp serializes a Medication to bytes using protobuf encoding.
func (m Medication) MarshalGorp() ([]byte, error) {
    pb := types.TranslateMedicationForward(m)
    return proto.Marshal(pb)
}

// UnmarshalGorp deserializes bytes into a Medication, handling migrations if needed.
func (m *Medication) UnmarshalGorp(data []byte) error {
    pb, err := types.UnmarshalWithMigration(data)
    if err != nil {
        return err
    }
    result, err := types.TranslateMedicationBackward(pb)
    if err != nil {
        return err
    }
    *m = result
    return nil
}
```

### 5.9.2 - gorp Interface

gorp checks for these methods via interface:

```go
// In gorp package
type GorpMarshaler interface {
    MarshalGorp() ([]byte, error)
}

type GorpUnmarshaler interface {
    UnmarshalGorp([]byte) error
}
```

If a type implements these interfaces, gorp uses them automatically. No codec
registration is required:

```go
// Application code - just use gorp normally
db := gorp.Wrap(pebbleDB)

// gorp detects MarshalGorp/UnmarshalGorp on Medication automatically
err := db.Set(ctx, medication)
err := db.Get(ctx, key, &medication)
```

### 5.9.3 - Migration on Unmarshal

The `UnmarshalWithMigration` function in `types/` handles version detection and
migration:

```go
// types/migrations.go

func UnmarshalWithMigration(data []byte) (*Medication, error) {
    // Try current version first (fast path)
    var current MedicationV2
    if err := proto.Unmarshal(data, &current); err == nil {
        return &current, nil
    }

    // Try older versions and migrate
    var v1 MedicationV1
    if err := proto.Unmarshal(data, &v1); err == nil {
        return MigrateMedicationV1ToV2(&v1), nil
    }

    // Try bootstrap (msgpack) migration
    return unmarshalBootstrap(data)
}
```

This approach:
1. Eliminates central codec registration (no need to register 50 types)
2. Each type is self-contained with its own serialization logic
3. Follows Go idioms (similar to `json.Marshaler`/`json.Unmarshaler`)
4. Migration happens transparently on read

# 6 - Build System Integration

## 6.0 - Go Generate

Jerky integrates with standard `go generate`:

```bash
go generate ./...
```

This:
1. Finds all `//go:generate jerky` directives
2. Parses annotated structs via AST
3. Generates `types/` directory contents
4. Runs `buf generate` for proto compilation

## 6.1 - Buf Integration

Jerky generates a `buf.yaml` in each `types/` directory:

```yaml
# types/buf.yaml
version: v2
modules:
  - path: .
    name: buf.build/synnaxlabs/medication-types
```

And updates the root `buf.gen.yaml` to include the new module.

## 6.2 - CI Integration

Recommended CI checks:

```yaml
- name: Check jerky generation
  run: |
    go generate ./...
    git diff --exit-code || (echo "Generated files out of date" && exit 1)
```

# 7 - Migration Path

## 7.0 - Adopting Jerky for Existing Types

1. Add `//go:generate jerky` to existing struct
2. Run `go generate`
3. Jerky creates version 1 artifacts and generates bootstrap migration for msgpack data
4. Deploy new version—startup migration converts msgpack → proto
5. Future struct changes are auto-detected and version incremented automatically

## 7.1 - New Types

New types start at version 1 with no bootstrap migration needed.

## 7.2 - Gradual Rollout

Types can adopt jerky independently. A codebase can have:
- Types using jerky (proto encoding)
- Types using legacy msgpack
- Mixed usage during transition

# 8 - Design Decisions

## 8.0 - Version Scope

Should versions be per-struct or per-package?

**Per-struct** (current design):
- `MedicationV2` can coexist with `DosageScheduleV1`
- More flexible but complex dependency tracking
- Cross-type migrations may need coordination

**Per-package**:
- All types in a package share version number
- Simpler but forces all types to migrate together
- May cause unnecessary migrations for unchanged types

**Decision**: Per-struct versioning.

Rationale:
- Synnax types have independent lifecycles—`Channel` changes frequently, `TimeRange`
  is stable
- Per-package forces unnecessary migrations and version bumps for unchanged types
- The dependency tracking in section 5.7 handles cross-type coordination via composite
  hashes
- Per-struct aligns with how protobuf field numbers work (independent per message)

The complexity concern is valid, but section 5.7.3's state file tracks dependencies
explicitly. The "cost" of per-struct is in the tooling, which is a one-time
implementation cost.

## 8.1 - Migration Function Signature

Should migrations be struct-level or field-level?

**Struct-level** (current design):

```go
func JerkyMigrateV2ToV3(*MedicationV2) *MedicationV3
```

**Field-level** alternative:

```go
func JerkyMigrateDosageV2ToV3(v2Dosage float64) float64 {
    return v2Dosage * 1000
}
```

**Decision**: Struct-level only, with a helper pattern for field transforms.

Rationale:
- Field-level migrations add complexity to generation logic (must compose correctly)
- Most migrations are either trivial (auto-generated) or complex enough to warrant
  full struct control
- For simple field transforms, developers can use local helper functions:

```go
func JerkyMigrateV2ToV3(v2 *MedicationV2) *MedicationV3 {
    return &MedicationV3{
        Key:      v2.Key,
        Name:     v2.Name,
        Duration: v2.Duration,
        DosageMg: migrateDosage(v2.Dosage),  // Local helper
    }
}

func migrateDosage(grams float64) float64 {
    return grams * 1000
}
```

This gives the same reusability without complicating jerky's generation.

## 8.2 - Cross-Package Dependencies

When `Prescription` contains `Medication`:
- What if `Medication` upgrades to v3 but `Prescription` still references v2?
- Should jerky enforce version compatibility?
- Should there be a "minimum compatible version" concept?

**Decision**: Enforce at generation time, not just warn.

Rationale:
- "Developer responsibility" leads to runtime failures in production
- Jerky already knows the dependency graph (section 5.7.1)
- Generation should fail if `Prescription` references `MedicationV2` but `Medication`
  is at V3

Proposed behavior:

```
jerky: error: prescription.go: type Prescription embeds medication.Medication
  Prescription was last generated against Medication v2
  Medication is now at v3
  Run `go generate ./medication ./prescription` to update both
```

This makes the failure explicit and actionable. The "minimum compatible version"
concept isn't needed if we enforce current-version alignment.

## 8.3 - Large Dataset Migration Performance

Startup migration may be slow for large datasets. Consider:
- Progress reporting during migration
- Checkpointing for resumable migrations
- Parallel migration of independent records

**Decision**: Start simple, add batched checkpointing.

Rationale:
- Sequential is the correct baseline
- Parallel migration risks ordering issues if types have relationships
- Checkpointing is valuable for crash recovery during long migrations

Phased approach:
1. **V1**: Sequential with progress logging (log every N records)
2. **V2**: Batched writes with checkpoint metadata (resumable)
3. **V3** (if needed): Parallel migration for independent record batches

The checkpoint is stored alongside the version metadata:

```json
{
  "version": 2,
  "migration_in_progress": true,
  "last_migrated_key": "abc123",
  "migrated_count": 50000
}
```

# 9 - Alternatives Considered

## 9.0 - Protocol Buffer Extensions

Use proto extensions or custom options to embed Go type information in proto files,
then generate Go code from proto.

**Rejected**: Inverts the source of truth. Go structs are more expressive than proto
for domain modeling.

## 9.1 - Runtime Reflection

Use Go reflection at runtime instead of code generation.

**Rejected**: Runtime overhead, no compile-time type safety, harder to debug.

## 9.2 - Schema Registry (Kafka-style)

Central schema registry service that tracks versions and compatibility.

**Rejected**: Adds operational complexity. Embedded versioning in code is simpler
for our use case.

## 9.3 - JSON Schema / OpenAPI

Generate from JSON Schema or OpenAPI specs.

**Rejected**: Different ecosystem, doesn't integrate well with gRPC/protobuf tooling
already in use.
