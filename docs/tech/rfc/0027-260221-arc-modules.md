# 27 - Arc Module System

**Feature Name**: Arc Module System <br /> **Status**: Draft <br /> **Start Date**:
2026-02-21 <br /> **Authors**: Emiliano Bonilla <br />

# 0 - Summary

This RFC proposes a module system for the Arc programming language that reorganizes the
standard library into self-contained, composable units. Modules serve as the single
organizing primitive for analyzer symbols, compiler imports, runtime host functions, and
reactive graph nodes. The design replaces the current brittle, index-based WASM binding
architecture with a name-based import contract, eliminates ~11,000 lines of generated
code, and establishes clear architectural boundaries between the language library
(`arc/`) and its host processes (`core/`, the C++ driver).

The module system has two layers: an internal infrastructure layer (the focus of this
RFC) that restructures how STL items are defined, resolved, compiled, and executed, and
a future user-facing layer that adds `import` syntax to Arc source code. The internal
layer must not close off the user-facing layer, but the syntax is not a deliverable of
this effort.

# 1 - Vocabulary

- **Host Function** - A function implemented in Go or C++ and callable from compiled
  WASM bytecode via the `call` instruction. Examples: `channel_read_f64`, `math.pow`.
- **Reactive Node** - A Go-native node in the dataflow graph, executed by the scheduler.
  Never touches WASM. Examples: `set_authority`, `stable_for`, `select`.
- **Compiler Primitive** - A host function emitted implicitly by the compiler for
  language constructs (variable access, assignment, operators). Users never call these
  directly.
- **STL Item** - Any standard library artifact: host function, reactive node, or symbol
  definition.
- **WASM Import Contract** - The set of `(module, name, signature)` tuples declared in a
  compiled WASM binary's import section. This is the interface between the compiler and
  all runtimes.

# 2 - Motivation

## 2.0 - Brittle Index-Based Binding

Arc programs compile to WebAssembly bytecode that calls host functions provided by the
Go or C++ runtime. Today, ~390 host functions are registered under a single WASM module
named `"env"` using positional indices. The compiler emits `call 47`, and both runtimes
must agree on what index 47 means.

Adding a single host function anywhere in the registration order shifts every subsequent
index. Three codebases (the Go compiler, the Go runtime, and the C++ runtime) must stay
in lockstep. The registration code totals ~10,400 lines across these three locations,
most of it generated or manually maintained boilerplate.

## 2.1 - Scattered STL Definitions

STL items are defined across many packages with no unifying structure:

- **Symbol definitions** live in individual `runtime/` packages as package-level vars
- **Node factories** are manually wired into a `MultiFactory` in `core/`
- **Host function implementations** live in a generated `Runtime` struct (~4,890 lines)
- **Import registration** lives in a separate `ImportIndex` struct (~470 lines)

Adding a new STL function like `math.sqrt` requires changes in at least four locations
across two packages. There is no single place where a developer can see the complete
definition of an STL item or trace its path from analyzer resolution to runtime
execution.

## 2.2 - Monolithic Runtime State

All runtime state lives in a single `state.State` struct: channel read/write buffers,
stateful variable persistence, series handles, string handles, authority changes, and
node outputs. Every host function reaches into this monolith. This makes it impossible
to reason about what state a particular subsystem owns, and presents challenges for
future debugger integration.

## 2.3 - No Path to User-Facing Modules

Arc currently has a flat global namespace for all STL symbols. There is no
infrastructure for namespaced access (`math.sqrt`), and no way to organize symbols into
logical groups for the visual editor's node palette. Adding user-facing `import` syntax
requires module infrastructure that doesn't exist today.

# 3 - Design Philosophy

## 3.0 - Modules as the Unit of Organization

A module is the fundamental organizing unit for all STL functionality. It groups related
symbols, host functions, and reactive nodes into a single, self-contained package.
Organization is semantic: a `math` module contains everything related to mathematical
operations, regardless of which execution layer (WASM or reactive graph) a particular
item runs in.

## 3.1 - One List, Three Consumers

The system derives all of its wiring from a single list of modules. From this list, it
produces the symbol resolver (for the analyzer), the node factory chain (for the
scheduler), and the host function registry (for the WASM runtime). Adding a new module
means defining it in one package and adding one entry to this list.

## 3.2 - Name-Based Contracts

The WASM binary's import section is self-describing. It declares
`import("math", "pow_f64")`, and whichever runtime executes it provides a function with
that name. Order is irrelevant. The Go and C++ runtimes resolve imports independently by
`(module, name)` pairs.

## 3.3 - Dependency Injection at the Module Level

`arc/` is a language library. It defines the `Module` interface and the machinery that
consumes modules. Host processes (`core/`, the C++ driver) instantiate concrete modules
with their dependencies and pass them to the `arc/` pipeline. There is no hardcoded STL
inside `arc/`. The set of available modules is determined entirely by the host process.

# 4 - Detailed Design

## 4.0 - The Module Interface

A module IS a `symbol.Resolver` and a `node.Factory` (interface embedding, not getter
methods). It also provides a `BindTo` method for registering host function
implementations with the WASM runtime:

```go
type Module interface {
    symbol.Resolver
    node.Factory
    BindTo(ctx context.Context, rt HostRuntime) error
}
```

Not every module provides all three capabilities. A `math` module might only provide
symbols and host functions (no reactive nodes). A `control` module might only provide
symbols and reactive nodes (no host functions). The interface methods return
`query.NotFound` for capabilities they don't support.

### 4.0.0 - HostRuntime Abstraction

`HostRuntime` abstracts the WASM engine so modules don't import engine-specific
packages:

```go
type HostRuntime interface {
    Export(wasmModule, name string, impl any) error
}
```

The wazero implementation groups exports by WASM module name internally. The wasmtime
(C++) implementation uses its `Linker` API. Both resolve imports by name, not position.

### 4.0.1 - Module Construction and Assembly

Modules are constructed with explicit dependencies. Construction order is enforced by
Go's type system:

```go
// Pure modules (no external deps, live in arc/)
channelMod := channel.NewModule()
mathMod    := math.NewModule()
timeMod    := time.NewModule()
controlMod := control.NewModule()

// Server-dependent modules (live in core/)
statusMod := status.NewModule(statusService)

// Assembly
modules := []stl.Module{channelMod, mathMod, timeMod, controlMod, statusMod}
```

From this one list, the system derives:

- **Symbol resolver**: `stl.CompoundResolver(modules...)` chains all modules
- **Node factory**: `stl.MultiFactory(modules...)` chains all factories
- **WASM host binding**: iterate modules, call `BindTo(ctx, rt)` on each

## 4.1 - Symbol Resolution

### 4.1.0 - ModuleResolver

For modules that own a namespace (like `math`), a concrete `ModuleResolver` helper
strips the prefix before delegating to the module's internal `MapResolver`:

```go
type ModuleResolver struct {
    Name    string
    Members symbol.MapResolver
}

func (m *ModuleResolver) Resolve(ctx context.Context, name string) (symbol.Symbol, error) {
    if !strings.HasPrefix(name, m.Name+".") {
        return symbol.Symbol{}, query.NotFound
    }
    return m.Members.Resolve(ctx, strings.TrimPrefix(name, m.Name+"."))
}
```

For auto-imported symbols (like `set_authority`), modules use a plain `MapResolver` with
bare names. The `symbol.Resolver` interface is unchanged.

### 4.1.1 - Compiler Primitives

Compiler primitives (channel reads, state stores, series arithmetic) have Arc-level
symbols with an `Internal` flag. This means all host functions, whether user-callable or
compiler-emitted, go through the same resolution path. The `Internal` flag prevents them
from appearing in user-facing autocomplete.

### 4.1.2 - Polymorphic Symbols

Arc already has analyzer-side machinery for type variables with constraints. By the time
the compiler runs, all type variables are resolved to concrete types. A function like
`math.sqrt` is defined with a polymorphic symbol `func(T: float) -> T`, and the
constraint system resolves `T` to `f64` or `f32` at each call site.

## 4.2 - Compiler Changes

### 4.2.0 - Two-Phase Compile-Then-Link

The current compiler registers all ~390 imports upfront and assigns indices immediately.
This couples import registration to compilation order and prevents lazy import tracking.
The new design separates compilation from index assignment.

**Phase 1 (compile)**: The compiler compiles all function bodies. When it encounters a
function call, it calls `ctx.Resolve(qualifiedName, concreteType)`, which returns a
temporary handle and records the reference. The writer emits call instructions with
placeholder operands (fixed-width 5-byte padded LEB128).

**Phase 2 (link)**: After all functions are compiled, the resolver knows exactly which
host functions were referenced. It partitions references into imports (no compiled body)
vs locals (compiled body exists). Imports get indices `0..N-1`, locals get `N..N+M-1`. A
fixup pass patches all placeholder operands with real indices.

```go
// Phase 1: compilation
handle := ctx.Resolve("math.sqrt", concreteType)
ctx.Writer.WriteCallPlaceholder(handle)

// Phase 2: linking
patches := resolver.Finalize(wasmModule)
ctx.Writer.PatchCalls(patches)
```

### 4.2.1 - Unified Function Resolution

The resolver replaces three separate mechanisms (`ImportIndex`, `FunctionIndices`,
`compileBuiltinCall`) with a single lookup. Host functions, user-defined functions, and
builtins all resolve through the same path. The compiler doesn't know or care whether a
function is a host import or a local definition until Phase 2 partitions them.

### 4.2.2 - Polymorphic Name Derivation

The compiler resolver derives WASM import coordinates from a qualified name and concrete
type. It looks up the original polymorphic symbol to determine whether type suffixes are
needed:

1. Resolve `"math.sqrt"` against compound resolver to get original symbol with type
   variables
2. Check if original type has type variables: yes, it's polymorphic
3. Construct suffix from concrete type at type variable positions: `"_f64"`
4. Split qualified name on last dot: WASM module `"math"`, function `"sqrt_f64"`

For monomorphic functions like `time.now`, no suffix is appended.

## 4.3 - WASM Import Contract

The WASM binary's import section is the contract between compiler and runtimes. With
name-based binding, order is irrelevant. Both Go and C++ runtimes resolve imports by
`(module, name)` pairs.

| WASM Module | Function Pattern              | Example                  |
| ----------- | ----------------------------- | ------------------------ |
| `channel`   | `read_{type}`, `write_{type}` | `channel.read_f64`       |
| `state`     | `load_{type}`, `store_{type}` | `state.store_i32`        |
| `series`    | `element_{op}_{type}`         | `series.element_add_f64` |
| `math`      | `pow_{type}`                  | `math.pow_f64`           |
| `time`      | `now`                         | `time.now`               |
| `string`    | `from_literal`, `concat`      | `string.concat`          |
| `error`     | `panic`                       | `error.panic`            |

Where `{type}` is `u8|u16|u32|u64|i8|i16|i32|i64|f32|f64` (plus `str` for
channel/state). Where `{op}` is `add|sub|mul|div|mod`.

## 4.4 - Runtime Host Binding

### 4.4.0 - Per-Module Host Modules

Replace the single `"env"` host module with per-STL-module host modules:

```go
type wazeroHostRuntime struct {
    builders map[string]wazero.HostModuleBuilder
}

func (w *wazeroHostRuntime) Export(wasmModule, name string, impl any) error {
    b, ok := w.builders[wasmModule]
    if !ok {
        b = w.rt.NewHostModuleBuilder(wasmModule)
        w.builders[wasmModule] = b
    }
    b.NewFunctionBuilder().WithFunc(impl).Export(name)
    return nil
}
```

### 4.4.1 - Go Generics for Type Variants

Replace ~10,000 lines of generated code with generic templates. Functions that operate
on i32-compatible types share a single implementation:

```go
func bindChannelRead[T ~uint8 | ~uint16 | ~uint32 | ~int8 | ~int16 | ~int32](
    rt HostRuntime, s *channelState, suffix string,
) {
    rt.Export("channel", "read_"+suffix, func(_ context.Context, chID uint32) uint32 {
        series, ok := s.ReadChannelValue(chID)
        if !ok || series.Len() == 0 { return 0 }
        return uint32(telem.ValueAt[T](series, -1))
    })
}
```

Functions for `i64`, `f32`, `f64` need separate registrations because they map to
different WASM types, but the implementation body is still generic. No code generator is
required.

### 4.4.2 - C++ Runtime Migration

The C++ runtime migrates independently from positional `vector<Extern>` to wasmtime's
`Linker` API:

```cpp
wasmtime::Linker linker(engine);
linker.define("math", "pow_f64", wasmtime::Func::wrap(store, [&](double base, double exp) {
    return std::pow(base, exp);
}));
auto instance = linker.instantiate(store, module);
```

The WASM binary's import section is the contract. Order becomes irrelevant. This
migration can happen independently of the Go-side changes.

## 4.5 - State Decomposition

The monolithic `state.State` is decomposed into module-owned state slices. Each module
creates its own state and exposes it through module-specific methods:

```go
channelMod := channel.NewModule()
// channelMod satisfies Module interface
// channelMod.Ingest(frame)  — for core/ to populate reads
// channelMod.Flush()        — for core/ to collect writes
```

The runtime orchestrates the flush cycle using module-specific state handles:

```go
channelMod.Ingest(frame)
scheduler.Next(ctx, elapsed, reason)
channelMod.ClearReads()
controlMod.FlushAuthorityChanges()
channelMod.Flush()
seriesMod.ClearTransient()
stringMod.ClearTransient()
```

Cross-cutting dependencies (e.g., channel reads producing series handles) are explicit
constructor parameters. Each module's state is discoverable through its handle, enabling
future debugger integration.

### 4.5.0 - Node Key Injection

Stateful variables are keyed per-node. The runtime attaches the current node key to the
context before each WASM call:

```go
ctx := context.WithValue(parentCtx, nodeKeyCtxKey, nodeKey)
fn.Call(ctx, params...)
```

Host functions that need per-node state extract the key from context. Non-stateful
modules (like `math`) ignore it entirely.

## 4.6 - Architectural Boundaries

### 4.6.0 - What Lives in `arc/`

`arc/` is the language library. It ships with every module that has no external
dependencies:

- `channel` — read/write host functions (compiler primitives)
- `state` — stateful variable load/store
- `series` — create, index, slice, arithmetic, comparison
- `string` — from_literal, concat, equal, len
- `math` — pow (future: sqrt, sin, cos, abs, clamp)
- `time` — now
- `op` — operator symbols and series arithmetic
- `control` — set_authority, stable_for, select, constant
- `telem` — on, write (source/sink graph nodes)
- `stage` — stage_entry graph node
- `stat` — avg, min, max graph nodes
- `error` — panic

### 4.6.1 - What Lives in `core/`

`core/` provides modules that depend on Synnax server services:

- `status` — set_status (needs `status.Service`)

`core/` assembles the full module list: all of `arc/`'s built-in modules plus its own
server-specific modules. The C++ driver does the same with its own set.

### 4.6.2 - Package Layout

```
arc/go/stl/
    stl.go              Module interface, HostRuntime, CompoundResolver, MultiFactory
    channel/            channel read/write host functions + channel state
    state/              stateful variable load/store + variable state
    series/             series operations + transient handle store
    string/             string operations + transient handle store
    math/               pow (+ future sqrt, sin, cos, abs, clamp)
    time/               now host function + interval/wait graph nodes
    op/                 operator graph nodes + series arithmetic host functions
    control/            set_authority, stable_for, select, constant
    telem/              on, write graph nodes
    stage/              stage_entry graph node
    stat/               avg, min, max graph nodes
    error/              panic host function

arc/go/compiler/
    resolve/            two-phase compile-then-link resolver
```

## 4.7 - Dual Execution: Host Functions as Graph Nodes

A function like `math.sqrt` needs to work in both execution layers:

- As an **inline call** inside a WASM function body: `x := math.sqrt(16.0)`
- As a **reactive node** in the dataflow graph: `sensor -> math.sqrt{} -> output{}`

When a module author wants a host function to also be usable as a graph node, they
provide a dedicated Go graph node factory alongside the host function definition. The
graph node operates on series via `state.Node` ports; the host function operates on
scalar values via WASM params. Both live in the same module package and share the same
underlying implementation where appropriate.

Not every host function automatically becomes a graph node. The module author explicitly
opts in by providing a factory.

# 5 - User-Facing Import Syntax (Future)

The internal module infrastructure established by this RFC enables a future user-facing
`import` syntax:

```arc
import ( math time )

func main() f64 {
    start := time.now()
    return math.sqrt(16.0)
}
```

Key design points for the future syntax:

- Explicit imports via `import ( module1 module2 )` blocks
- Qualified member access: `math.sqrt(16.0)`
- Aliases: `import ( math as m )`
- Hierarchical paths: `import ( math.trig )`
- Last path segment becomes the qualifier
- Unused imports are compile errors
- Certain symbols remain auto-imported (e.g., `set_authority`, `len`) for backwards
  compatibility

The internal infrastructure supports all of these patterns. `ModuleResolver` handles
prefix stripping for qualified names. `CompoundResolver` chains modules in priority
order for auto-imported bare names. The resolver's handling of qualified vs unqualified
lookup is a localized implementation detail that doesn't affect the module interface.

# 6 - Implementation Phases

## 6.0 - Phase 1: Foundation

Create `arc/go/stl/` with the `Module` interface, `HostRuntime` interface, and helper
types. Create empty module stubs that satisfy the interface but delegate to existing
code. Create the compiler resolver type. Existing tests pass unchanged.

## 6.1 - Phase 2: Compiler Migration

Replace `ImportIndex` with the two-phase resolver. Update all compiler callsites. WASM
binaries begin using module namespaces. Temporarily support both old and new import
names in the Go runtime for test continuity.

## 6.2 - Phase 3: Go Runtime Migration

Implement generic host functions in `stl/`. Replace the single `"env"` host module with
per-module builders. Delete generated files (~9,500 lines) and the code generator.

## 6.3 - Phase 4: STL Symbol and Factory Migration

Move symbol definitions and node factories from `runtime/` packages to `stl/`. Each
module provides symbols and factories through the `Module` interface. Delete old
`runtime/` packages.

## 6.4 - Phase 5: State Decomposition

Extract module-owned state slices from the monolithic `state.State`. Update `core/` to
use module state handles for ingest/flush. Delete `runtime/wasm/bindings/` entirely.

## 6.5 - Phase 6: Cleanup

Delete `compiler/bindings/` directory. Produce C++ WASM import contract specification.
Verify no references to old `ImportIndex`, `Bindings`, or `BindRuntime` remain.

# 7 - Risks and Mitigations

## 7.0 - Test Continuity

Each phase maintains passing tests. Phase 2 temporarily supports both old and new import
names so the Go runtime doesn't break while the compiler migrates.

## 7.1 - C++ Compatibility

The C++ runtime is not updated as part of this effort. It continues using positional
binding against the old `"env"` namespace until it independently migrates to wasmtime's
`Linker` API. A compatibility shim in the compiler can optionally emit old-style imports
during the transition.

## 7.2 - Performance

Name-based binding has negligible overhead vs positional. Both wazero and wasmtime use
hash maps internally for import resolution. The only per-call cost is
`context.WithValue` for node key injection (~10-20ns), which is dwarfed by WASM FFI
overhead.

## 7.3 - Missing Specialization Errors

If a module declares a polymorphic symbol but `BindTo` forgets to register a type
variant, the error surfaces at WASM instantiation time (before user code runs). The
compiler cannot catch this because it's runtime-independent. Utilities for generating
all type variants from a template prevent this in practice.

# 8 - Summary

This RFC introduces a module system for Arc's standard library that:

1. **Replaces index-based binding** with a name-based WASM import contract, eliminating
   the lockstep requirement between compiler and runtimes
2. **Defines a Module interface** (`symbol.Resolver` + `node.Factory` + `BindTo`) as the
   single organizing primitive for all STL functionality
3. **Uses dependency injection** at the module level, allowing host processes to compose
   their own set of available modules
4. **Introduces two-phase compile-then-link** to unify host function and user-defined
   function resolution in the compiler
5. **Decomposes monolithic state** into module-owned slices with explicit dependencies
6. **Eliminates ~11,000 lines** of generated and boilerplate code via Go generics and
   name-based binding
7. **Enables future user-facing `import` syntax** without additional architectural
   changes
